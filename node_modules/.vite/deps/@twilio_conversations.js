import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-4B2QHNJT.js";

// node_modules/core-js/internals/global-this.js
var require_global_this = __commonJS({
  "node_modules/core-js/internals/global-this.js"(exports, module) {
    "use strict";
    var check = function(it) {
      return it && it.Math === Math && it;
    };
    module.exports = // eslint-disable-next-line es/no-global-this -- safe
    check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
    check(typeof self == "object" && self) || check(typeof global == "object" && global) || check(typeof exports == "object" && exports) || // eslint-disable-next-line no-new-func -- fallback
    /* @__PURE__ */ function() {
      return this;
    }() || Function("return this")();
  }
});

// node_modules/core-js/internals/fails.js
var require_fails = __commonJS({
  "node_modules/core-js/internals/fails.js"(exports, module) {
    "use strict";
    module.exports = function(exec) {
      try {
        return !!exec();
      } catch (error) {
        return true;
      }
    };
  }
});

// node_modules/core-js/internals/descriptors.js
var require_descriptors = __commonJS({
  "node_modules/core-js/internals/descriptors.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    module.exports = !fails(function() {
      return Object.defineProperty({}, 1, { get: function() {
        return 7;
      } })[1] !== 7;
    });
  }
});

// node_modules/core-js/internals/function-bind-native.js
var require_function_bind_native = __commonJS({
  "node_modules/core-js/internals/function-bind-native.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    module.exports = !fails(function() {
      var test = (function() {
      }).bind();
      return typeof test != "function" || test.hasOwnProperty("prototype");
    });
  }
});

// node_modules/core-js/internals/function-call.js
var require_function_call = __commonJS({
  "node_modules/core-js/internals/function-call.js"(exports, module) {
    "use strict";
    var NATIVE_BIND = require_function_bind_native();
    var call = Function.prototype.call;
    module.exports = NATIVE_BIND ? call.bind(call) : function() {
      return call.apply(call, arguments);
    };
  }
});

// node_modules/core-js/internals/object-property-is-enumerable.js
var require_object_property_is_enumerable = __commonJS({
  "node_modules/core-js/internals/object-property-is-enumerable.js"(exports) {
    "use strict";
    var $propertyIsEnumerable = {}.propertyIsEnumerable;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);
    exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
      var descriptor = getOwnPropertyDescriptor(this, V);
      return !!descriptor && descriptor.enumerable;
    } : $propertyIsEnumerable;
  }
});

// node_modules/core-js/internals/create-property-descriptor.js
var require_create_property_descriptor = __commonJS({
  "node_modules/core-js/internals/create-property-descriptor.js"(exports, module) {
    "use strict";
    module.exports = function(bitmap, value) {
      return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value
      };
    };
  }
});

// node_modules/core-js/internals/function-uncurry-this.js
var require_function_uncurry_this = __commonJS({
  "node_modules/core-js/internals/function-uncurry-this.js"(exports, module) {
    "use strict";
    var NATIVE_BIND = require_function_bind_native();
    var FunctionPrototype = Function.prototype;
    var call = FunctionPrototype.call;
    var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);
    module.exports = NATIVE_BIND ? uncurryThisWithBind : function(fn) {
      return function() {
        return call.apply(fn, arguments);
      };
    };
  }
});

// node_modules/core-js/internals/classof-raw.js
var require_classof_raw = __commonJS({
  "node_modules/core-js/internals/classof-raw.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var toString = uncurryThis({}.toString);
    var stringSlice = uncurryThis("".slice);
    module.exports = function(it) {
      return stringSlice(toString(it), 8, -1);
    };
  }
});

// node_modules/core-js/internals/indexed-object.js
var require_indexed_object = __commonJS({
  "node_modules/core-js/internals/indexed-object.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var classof = require_classof_raw();
    var $Object = Object;
    var split = uncurryThis("".split);
    module.exports = fails(function() {
      return !$Object("z").propertyIsEnumerable(0);
    }) ? function(it) {
      return classof(it) === "String" ? split(it, "") : $Object(it);
    } : $Object;
  }
});

// node_modules/core-js/internals/is-null-or-undefined.js
var require_is_null_or_undefined = __commonJS({
  "node_modules/core-js/internals/is-null-or-undefined.js"(exports, module) {
    "use strict";
    module.exports = function(it) {
      return it === null || it === void 0;
    };
  }
});

// node_modules/core-js/internals/require-object-coercible.js
var require_require_object_coercible = __commonJS({
  "node_modules/core-js/internals/require-object-coercible.js"(exports, module) {
    "use strict";
    var isNullOrUndefined = require_is_null_or_undefined();
    var $TypeError = TypeError;
    module.exports = function(it) {
      if (isNullOrUndefined(it)) throw new $TypeError("Can't call method on " + it);
      return it;
    };
  }
});

// node_modules/core-js/internals/to-indexed-object.js
var require_to_indexed_object = __commonJS({
  "node_modules/core-js/internals/to-indexed-object.js"(exports, module) {
    "use strict";
    var IndexedObject = require_indexed_object();
    var requireObjectCoercible = require_require_object_coercible();
    module.exports = function(it) {
      return IndexedObject(requireObjectCoercible(it));
    };
  }
});

// node_modules/core-js/internals/is-callable.js
var require_is_callable = __commonJS({
  "node_modules/core-js/internals/is-callable.js"(exports, module) {
    "use strict";
    var documentAll = typeof document == "object" && document.all;
    module.exports = typeof documentAll == "undefined" && documentAll !== void 0 ? function(argument) {
      return typeof argument == "function" || argument === documentAll;
    } : function(argument) {
      return typeof argument == "function";
    };
  }
});

// node_modules/core-js/internals/is-object.js
var require_is_object = __commonJS({
  "node_modules/core-js/internals/is-object.js"(exports, module) {
    "use strict";
    var isCallable = require_is_callable();
    module.exports = function(it) {
      return typeof it == "object" ? it !== null : isCallable(it);
    };
  }
});

// node_modules/core-js/internals/get-built-in.js
var require_get_built_in = __commonJS({
  "node_modules/core-js/internals/get-built-in.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var isCallable = require_is_callable();
    var aFunction = function(argument) {
      return isCallable(argument) ? argument : void 0;
    };
    module.exports = function(namespace, method) {
      return arguments.length < 2 ? aFunction(globalThis2[namespace]) : globalThis2[namespace] && globalThis2[namespace][method];
    };
  }
});

// node_modules/core-js/internals/object-is-prototype-of.js
var require_object_is_prototype_of = __commonJS({
  "node_modules/core-js/internals/object-is-prototype-of.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    module.exports = uncurryThis({}.isPrototypeOf);
  }
});

// node_modules/core-js/internals/environment-user-agent.js
var require_environment_user_agent = __commonJS({
  "node_modules/core-js/internals/environment-user-agent.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var navigator2 = globalThis2.navigator;
    var userAgent = navigator2 && navigator2.userAgent;
    module.exports = userAgent ? String(userAgent) : "";
  }
});

// node_modules/core-js/internals/environment-v8-version.js
var require_environment_v8_version = __commonJS({
  "node_modules/core-js/internals/environment-v8-version.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var userAgent = require_environment_user_agent();
    var process = globalThis2.process;
    var Deno2 = globalThis2.Deno;
    var versions = process && process.versions || Deno2 && Deno2.version;
    var v8 = versions && versions.v8;
    var match;
    var version;
    if (v8) {
      match = v8.split(".");
      version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
    }
    if (!version && userAgent) {
      match = userAgent.match(/Edge\/(\d+)/);
      if (!match || match[1] >= 74) {
        match = userAgent.match(/Chrome\/(\d+)/);
        if (match) version = +match[1];
      }
    }
    module.exports = version;
  }
});

// node_modules/core-js/internals/symbol-constructor-detection.js
var require_symbol_constructor_detection = __commonJS({
  "node_modules/core-js/internals/symbol-constructor-detection.js"(exports, module) {
    "use strict";
    var V8_VERSION = require_environment_v8_version();
    var fails = require_fails();
    var globalThis2 = require_global_this();
    var $String = globalThis2.String;
    module.exports = !!Object.getOwnPropertySymbols && !fails(function() {
      var symbol = Symbol("symbol detection");
      return !$String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
      !Symbol.sham && V8_VERSION && V8_VERSION < 41;
    });
  }
});

// node_modules/core-js/internals/use-symbol-as-uid.js
var require_use_symbol_as_uid = __commonJS({
  "node_modules/core-js/internals/use-symbol-as-uid.js"(exports, module) {
    "use strict";
    var NATIVE_SYMBOL = require_symbol_constructor_detection();
    module.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
  }
});

// node_modules/core-js/internals/is-symbol.js
var require_is_symbol = __commonJS({
  "node_modules/core-js/internals/is-symbol.js"(exports, module) {
    "use strict";
    var getBuiltIn = require_get_built_in();
    var isCallable = require_is_callable();
    var isPrototypeOf = require_object_is_prototype_of();
    var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
    var $Object = Object;
    module.exports = USE_SYMBOL_AS_UID ? function(it) {
      return typeof it == "symbol";
    } : function(it) {
      var $Symbol = getBuiltIn("Symbol");
      return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
    };
  }
});

// node_modules/core-js/internals/try-to-string.js
var require_try_to_string = __commonJS({
  "node_modules/core-js/internals/try-to-string.js"(exports, module) {
    "use strict";
    var $String = String;
    module.exports = function(argument) {
      try {
        return $String(argument);
      } catch (error) {
        return "Object";
      }
    };
  }
});

// node_modules/core-js/internals/a-callable.js
var require_a_callable = __commonJS({
  "node_modules/core-js/internals/a-callable.js"(exports, module) {
    "use strict";
    var isCallable = require_is_callable();
    var tryToString = require_try_to_string();
    var $TypeError = TypeError;
    module.exports = function(argument) {
      if (isCallable(argument)) return argument;
      throw new $TypeError(tryToString(argument) + " is not a function");
    };
  }
});

// node_modules/core-js/internals/get-method.js
var require_get_method = __commonJS({
  "node_modules/core-js/internals/get-method.js"(exports, module) {
    "use strict";
    var aCallable = require_a_callable();
    var isNullOrUndefined = require_is_null_or_undefined();
    module.exports = function(V, P) {
      var func = V[P];
      return isNullOrUndefined(func) ? void 0 : aCallable(func);
    };
  }
});

// node_modules/core-js/internals/ordinary-to-primitive.js
var require_ordinary_to_primitive = __commonJS({
  "node_modules/core-js/internals/ordinary-to-primitive.js"(exports, module) {
    "use strict";
    var call = require_function_call();
    var isCallable = require_is_callable();
    var isObject = require_is_object();
    var $TypeError = TypeError;
    module.exports = function(input, pref) {
      var fn, val;
      if (pref === "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
      if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
      if (pref !== "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
      throw new $TypeError("Can't convert object to primitive value");
    };
  }
});

// node_modules/core-js/internals/is-pure.js
var require_is_pure = __commonJS({
  "node_modules/core-js/internals/is-pure.js"(exports, module) {
    "use strict";
    module.exports = false;
  }
});

// node_modules/core-js/internals/define-global-property.js
var require_define_global_property = __commonJS({
  "node_modules/core-js/internals/define-global-property.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var defineProperty = Object.defineProperty;
    module.exports = function(key, value) {
      try {
        defineProperty(globalThis2, key, { value, configurable: true, writable: true });
      } catch (error) {
        globalThis2[key] = value;
      }
      return value;
    };
  }
});

// node_modules/core-js/internals/shared-store.js
var require_shared_store = __commonJS({
  "node_modules/core-js/internals/shared-store.js"(exports, module) {
    "use strict";
    var IS_PURE = require_is_pure();
    var globalThis2 = require_global_this();
    var defineGlobalProperty = require_define_global_property();
    var SHARED = "__core-js_shared__";
    var store = module.exports = globalThis2[SHARED] || defineGlobalProperty(SHARED, {});
    (store.versions || (store.versions = [])).push({
      version: "3.43.0",
      mode: IS_PURE ? "pure" : "global",
      copyright: "Â© 2014-2025 Denis Pushkarev (zloirock.ru)",
      license: "https://github.com/zloirock/core-js/blob/v3.43.0/LICENSE",
      source: "https://github.com/zloirock/core-js"
    });
  }
});

// node_modules/core-js/internals/shared.js
var require_shared = __commonJS({
  "node_modules/core-js/internals/shared.js"(exports, module) {
    "use strict";
    var store = require_shared_store();
    module.exports = function(key, value) {
      return store[key] || (store[key] = value || {});
    };
  }
});

// node_modules/core-js/internals/to-object.js
var require_to_object = __commonJS({
  "node_modules/core-js/internals/to-object.js"(exports, module) {
    "use strict";
    var requireObjectCoercible = require_require_object_coercible();
    var $Object = Object;
    module.exports = function(argument) {
      return $Object(requireObjectCoercible(argument));
    };
  }
});

// node_modules/core-js/internals/has-own-property.js
var require_has_own_property = __commonJS({
  "node_modules/core-js/internals/has-own-property.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var toObject = require_to_object();
    var hasOwnProperty = uncurryThis({}.hasOwnProperty);
    module.exports = Object.hasOwn || function hasOwn(it, key) {
      return hasOwnProperty(toObject(it), key);
    };
  }
});

// node_modules/core-js/internals/uid.js
var require_uid = __commonJS({
  "node_modules/core-js/internals/uid.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var id = 0;
    var postfix = Math.random();
    var toString = uncurryThis(1.1.toString);
    module.exports = function(key) {
      return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString(++id + postfix, 36);
    };
  }
});

// node_modules/core-js/internals/well-known-symbol.js
var require_well_known_symbol = __commonJS({
  "node_modules/core-js/internals/well-known-symbol.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var shared = require_shared();
    var hasOwn = require_has_own_property();
    var uid = require_uid();
    var NATIVE_SYMBOL = require_symbol_constructor_detection();
    var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
    var Symbol2 = globalThis2.Symbol;
    var WellKnownSymbolsStore = shared("wks");
    var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2["for"] || Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;
    module.exports = function(name) {
      if (!hasOwn(WellKnownSymbolsStore, name)) {
        WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol2, name) ? Symbol2[name] : createWellKnownSymbol("Symbol." + name);
      }
      return WellKnownSymbolsStore[name];
    };
  }
});

// node_modules/core-js/internals/to-primitive.js
var require_to_primitive = __commonJS({
  "node_modules/core-js/internals/to-primitive.js"(exports, module) {
    "use strict";
    var call = require_function_call();
    var isObject = require_is_object();
    var isSymbol = require_is_symbol();
    var getMethod = require_get_method();
    var ordinaryToPrimitive = require_ordinary_to_primitive();
    var wellKnownSymbol = require_well_known_symbol();
    var $TypeError = TypeError;
    var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
    module.exports = function(input, pref) {
      if (!isObject(input) || isSymbol(input)) return input;
      var exoticToPrim = getMethod(input, TO_PRIMITIVE);
      var result;
      if (exoticToPrim) {
        if (pref === void 0) pref = "default";
        result = call(exoticToPrim, input, pref);
        if (!isObject(result) || isSymbol(result)) return result;
        throw new $TypeError("Can't convert object to primitive value");
      }
      if (pref === void 0) pref = "number";
      return ordinaryToPrimitive(input, pref);
    };
  }
});

// node_modules/core-js/internals/to-property-key.js
var require_to_property_key = __commonJS({
  "node_modules/core-js/internals/to-property-key.js"(exports, module) {
    "use strict";
    var toPrimitive = require_to_primitive();
    var isSymbol = require_is_symbol();
    module.exports = function(argument) {
      var key = toPrimitive(argument, "string");
      return isSymbol(key) ? key : key + "";
    };
  }
});

// node_modules/core-js/internals/document-create-element.js
var require_document_create_element = __commonJS({
  "node_modules/core-js/internals/document-create-element.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var isObject = require_is_object();
    var document2 = globalThis2.document;
    var EXISTS = isObject(document2) && isObject(document2.createElement);
    module.exports = function(it) {
      return EXISTS ? document2.createElement(it) : {};
    };
  }
});

// node_modules/core-js/internals/ie8-dom-define.js
var require_ie8_dom_define = __commonJS({
  "node_modules/core-js/internals/ie8-dom-define.js"(exports, module) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var fails = require_fails();
    var createElement = require_document_create_element();
    module.exports = !DESCRIPTORS && !fails(function() {
      return Object.defineProperty(createElement("div"), "a", {
        get: function() {
          return 7;
        }
      }).a !== 7;
    });
  }
});

// node_modules/core-js/internals/object-get-own-property-descriptor.js
var require_object_get_own_property_descriptor = __commonJS({
  "node_modules/core-js/internals/object-get-own-property-descriptor.js"(exports) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var call = require_function_call();
    var propertyIsEnumerableModule = require_object_property_is_enumerable();
    var createPropertyDescriptor = require_create_property_descriptor();
    var toIndexedObject = require_to_indexed_object();
    var toPropertyKey = require_to_property_key();
    var hasOwn = require_has_own_property();
    var IE8_DOM_DEFINE = require_ie8_dom_define();
    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
      O = toIndexedObject(O);
      P = toPropertyKey(P);
      if (IE8_DOM_DEFINE) try {
        return $getOwnPropertyDescriptor(O, P);
      } catch (error) {
      }
      if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
    };
  }
});

// node_modules/core-js/internals/v8-prototype-define-bug.js
var require_v8_prototype_define_bug = __commonJS({
  "node_modules/core-js/internals/v8-prototype-define-bug.js"(exports, module) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var fails = require_fails();
    module.exports = DESCRIPTORS && fails(function() {
      return Object.defineProperty(function() {
      }, "prototype", {
        value: 42,
        writable: false
      }).prototype !== 42;
    });
  }
});

// node_modules/core-js/internals/an-object.js
var require_an_object = __commonJS({
  "node_modules/core-js/internals/an-object.js"(exports, module) {
    "use strict";
    var isObject = require_is_object();
    var $String = String;
    var $TypeError = TypeError;
    module.exports = function(argument) {
      if (isObject(argument)) return argument;
      throw new $TypeError($String(argument) + " is not an object");
    };
  }
});

// node_modules/core-js/internals/object-define-property.js
var require_object_define_property = __commonJS({
  "node_modules/core-js/internals/object-define-property.js"(exports) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var IE8_DOM_DEFINE = require_ie8_dom_define();
    var V8_PROTOTYPE_DEFINE_BUG = require_v8_prototype_define_bug();
    var anObject = require_an_object();
    var toPropertyKey = require_to_property_key();
    var $TypeError = TypeError;
    var $defineProperty = Object.defineProperty;
    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var ENUMERABLE = "enumerable";
    var CONFIGURABLE = "configurable";
    var WRITABLE = "writable";
    exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
      anObject(O);
      P = toPropertyKey(P);
      anObject(Attributes);
      if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
        var current = $getOwnPropertyDescriptor(O, P);
        if (current && current[WRITABLE]) {
          O[P] = Attributes.value;
          Attributes = {
            configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
            enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
            writable: false
          };
        }
      }
      return $defineProperty(O, P, Attributes);
    } : $defineProperty : function defineProperty(O, P, Attributes) {
      anObject(O);
      P = toPropertyKey(P);
      anObject(Attributes);
      if (IE8_DOM_DEFINE) try {
        return $defineProperty(O, P, Attributes);
      } catch (error) {
      }
      if ("get" in Attributes || "set" in Attributes) throw new $TypeError("Accessors not supported");
      if ("value" in Attributes) O[P] = Attributes.value;
      return O;
    };
  }
});

// node_modules/core-js/internals/create-non-enumerable-property.js
var require_create_non_enumerable_property = __commonJS({
  "node_modules/core-js/internals/create-non-enumerable-property.js"(exports, module) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var definePropertyModule = require_object_define_property();
    var createPropertyDescriptor = require_create_property_descriptor();
    module.exports = DESCRIPTORS ? function(object, key, value) {
      return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
    } : function(object, key, value) {
      object[key] = value;
      return object;
    };
  }
});

// node_modules/core-js/internals/function-name.js
var require_function_name = __commonJS({
  "node_modules/core-js/internals/function-name.js"(exports, module) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var hasOwn = require_has_own_property();
    var FunctionPrototype = Function.prototype;
    var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
    var EXISTS = hasOwn(FunctionPrototype, "name");
    var PROPER = EXISTS && (function something() {
    }).name === "something";
    var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
    module.exports = {
      EXISTS,
      PROPER,
      CONFIGURABLE
    };
  }
});

// node_modules/core-js/internals/inspect-source.js
var require_inspect_source = __commonJS({
  "node_modules/core-js/internals/inspect-source.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var isCallable = require_is_callable();
    var store = require_shared_store();
    var functionToString = uncurryThis(Function.toString);
    if (!isCallable(store.inspectSource)) {
      store.inspectSource = function(it) {
        return functionToString(it);
      };
    }
    module.exports = store.inspectSource;
  }
});

// node_modules/core-js/internals/weak-map-basic-detection.js
var require_weak_map_basic_detection = __commonJS({
  "node_modules/core-js/internals/weak-map-basic-detection.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var isCallable = require_is_callable();
    var WeakMap = globalThis2.WeakMap;
    module.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));
  }
});

// node_modules/core-js/internals/shared-key.js
var require_shared_key = __commonJS({
  "node_modules/core-js/internals/shared-key.js"(exports, module) {
    "use strict";
    var shared = require_shared();
    var uid = require_uid();
    var keys = shared("keys");
    module.exports = function(key) {
      return keys[key] || (keys[key] = uid(key));
    };
  }
});

// node_modules/core-js/internals/hidden-keys.js
var require_hidden_keys = __commonJS({
  "node_modules/core-js/internals/hidden-keys.js"(exports, module) {
    "use strict";
    module.exports = {};
  }
});

// node_modules/core-js/internals/internal-state.js
var require_internal_state = __commonJS({
  "node_modules/core-js/internals/internal-state.js"(exports, module) {
    "use strict";
    var NATIVE_WEAK_MAP = require_weak_map_basic_detection();
    var globalThis2 = require_global_this();
    var isObject = require_is_object();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var hasOwn = require_has_own_property();
    var shared = require_shared_store();
    var sharedKey = require_shared_key();
    var hiddenKeys = require_hidden_keys();
    var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
    var TypeError2 = globalThis2.TypeError;
    var WeakMap = globalThis2.WeakMap;
    var set;
    var get;
    var has;
    var enforce = function(it) {
      return has(it) ? get(it) : set(it, {});
    };
    var getterFor = function(TYPE) {
      return function(it) {
        var state;
        if (!isObject(it) || (state = get(it)).type !== TYPE) {
          throw new TypeError2("Incompatible receiver, " + TYPE + " required");
        }
        return state;
      };
    };
    if (NATIVE_WEAK_MAP || shared.state) {
      store = shared.state || (shared.state = new WeakMap());
      store.get = store.get;
      store.has = store.has;
      store.set = store.set;
      set = function(it, metadata) {
        if (store.has(it)) throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        store.set(it, metadata);
        return metadata;
      };
      get = function(it) {
        return store.get(it) || {};
      };
      has = function(it) {
        return store.has(it);
      };
    } else {
      STATE = sharedKey("state");
      hiddenKeys[STATE] = true;
      set = function(it, metadata) {
        if (hasOwn(it, STATE)) throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        createNonEnumerableProperty(it, STATE, metadata);
        return metadata;
      };
      get = function(it) {
        return hasOwn(it, STATE) ? it[STATE] : {};
      };
      has = function(it) {
        return hasOwn(it, STATE);
      };
    }
    var store;
    var STATE;
    module.exports = {
      set,
      get,
      has,
      enforce,
      getterFor
    };
  }
});

// node_modules/core-js/internals/make-built-in.js
var require_make_built_in = __commonJS({
  "node_modules/core-js/internals/make-built-in.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var isCallable = require_is_callable();
    var hasOwn = require_has_own_property();
    var DESCRIPTORS = require_descriptors();
    var CONFIGURABLE_FUNCTION_NAME = require_function_name().CONFIGURABLE;
    var inspectSource = require_inspect_source();
    var InternalStateModule = require_internal_state();
    var enforceInternalState = InternalStateModule.enforce;
    var getInternalState = InternalStateModule.get;
    var $String = String;
    var defineProperty = Object.defineProperty;
    var stringSlice = uncurryThis("".slice);
    var replace = uncurryThis("".replace);
    var join = uncurryThis([].join);
    var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function() {
      return defineProperty(function() {
      }, "length", { value: 8 }).length !== 8;
    });
    var TEMPLATE = String(String).split("String");
    var makeBuiltIn = module.exports = function(value, name, options) {
      if (stringSlice($String(name), 0, 7) === "Symbol(") {
        name = "[" + replace($String(name), /^Symbol\(([^)]*)\).*$/, "$1") + "]";
      }
      if (options && options.getter) name = "get " + name;
      if (options && options.setter) name = "set " + name;
      if (!hasOwn(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
        if (DESCRIPTORS) defineProperty(value, "name", { value: name, configurable: true });
        else value.name = name;
      }
      if (CONFIGURABLE_LENGTH && options && hasOwn(options, "arity") && value.length !== options.arity) {
        defineProperty(value, "length", { value: options.arity });
      }
      try {
        if (options && hasOwn(options, "constructor") && options.constructor) {
          if (DESCRIPTORS) defineProperty(value, "prototype", { writable: false });
        } else if (value.prototype) value.prototype = void 0;
      } catch (error) {
      }
      var state = enforceInternalState(value);
      if (!hasOwn(state, "source")) {
        state.source = join(TEMPLATE, typeof name == "string" ? name : "");
      }
      return value;
    };
    Function.prototype.toString = makeBuiltIn(function toString() {
      return isCallable(this) && getInternalState(this).source || inspectSource(this);
    }, "toString");
  }
});

// node_modules/core-js/internals/define-built-in.js
var require_define_built_in = __commonJS({
  "node_modules/core-js/internals/define-built-in.js"(exports, module) {
    "use strict";
    var isCallable = require_is_callable();
    var definePropertyModule = require_object_define_property();
    var makeBuiltIn = require_make_built_in();
    var defineGlobalProperty = require_define_global_property();
    module.exports = function(O, key, value, options) {
      if (!options) options = {};
      var simple = options.enumerable;
      var name = options.name !== void 0 ? options.name : key;
      if (isCallable(value)) makeBuiltIn(value, name, options);
      if (options.global) {
        if (simple) O[key] = value;
        else defineGlobalProperty(key, value);
      } else {
        try {
          if (!options.unsafe) delete O[key];
          else if (O[key]) simple = true;
        } catch (error) {
        }
        if (simple) O[key] = value;
        else definePropertyModule.f(O, key, {
          value,
          enumerable: false,
          configurable: !options.nonConfigurable,
          writable: !options.nonWritable
        });
      }
      return O;
    };
  }
});

// node_modules/core-js/internals/math-trunc.js
var require_math_trunc = __commonJS({
  "node_modules/core-js/internals/math-trunc.js"(exports, module) {
    "use strict";
    var ceil = Math.ceil;
    var floor = Math.floor;
    module.exports = Math.trunc || function trunc(x) {
      var n = +x;
      return (n > 0 ? floor : ceil)(n);
    };
  }
});

// node_modules/core-js/internals/to-integer-or-infinity.js
var require_to_integer_or_infinity = __commonJS({
  "node_modules/core-js/internals/to-integer-or-infinity.js"(exports, module) {
    "use strict";
    var trunc = require_math_trunc();
    module.exports = function(argument) {
      var number = +argument;
      return number !== number || number === 0 ? 0 : trunc(number);
    };
  }
});

// node_modules/core-js/internals/to-absolute-index.js
var require_to_absolute_index = __commonJS({
  "node_modules/core-js/internals/to-absolute-index.js"(exports, module) {
    "use strict";
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var max = Math.max;
    var min = Math.min;
    module.exports = function(index, length) {
      var integer = toIntegerOrInfinity(index);
      return integer < 0 ? max(integer + length, 0) : min(integer, length);
    };
  }
});

// node_modules/core-js/internals/to-length.js
var require_to_length = __commonJS({
  "node_modules/core-js/internals/to-length.js"(exports, module) {
    "use strict";
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var min = Math.min;
    module.exports = function(argument) {
      var len = toIntegerOrInfinity(argument);
      return len > 0 ? min(len, 9007199254740991) : 0;
    };
  }
});

// node_modules/core-js/internals/length-of-array-like.js
var require_length_of_array_like = __commonJS({
  "node_modules/core-js/internals/length-of-array-like.js"(exports, module) {
    "use strict";
    var toLength = require_to_length();
    module.exports = function(obj) {
      return toLength(obj.length);
    };
  }
});

// node_modules/core-js/internals/array-includes.js
var require_array_includes = __commonJS({
  "node_modules/core-js/internals/array-includes.js"(exports, module) {
    "use strict";
    var toIndexedObject = require_to_indexed_object();
    var toAbsoluteIndex = require_to_absolute_index();
    var lengthOfArrayLike = require_length_of_array_like();
    var createMethod = function(IS_INCLUDES) {
      return function($this, el, fromIndex) {
        var O = toIndexedObject($this);
        var length = lengthOfArrayLike(O);
        if (length === 0) return !IS_INCLUDES && -1;
        var index = toAbsoluteIndex(fromIndex, length);
        var value;
        if (IS_INCLUDES && el !== el) while (length > index) {
          value = O[index++];
          if (value !== value) return true;
        }
        else for (; length > index; index++) {
          if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
        }
        return !IS_INCLUDES && -1;
      };
    };
    module.exports = {
      // `Array.prototype.includes` method
      // https://tc39.es/ecma262/#sec-array.prototype.includes
      includes: createMethod(true),
      // `Array.prototype.indexOf` method
      // https://tc39.es/ecma262/#sec-array.prototype.indexof
      indexOf: createMethod(false)
    };
  }
});

// node_modules/core-js/internals/object-keys-internal.js
var require_object_keys_internal = __commonJS({
  "node_modules/core-js/internals/object-keys-internal.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var hasOwn = require_has_own_property();
    var toIndexedObject = require_to_indexed_object();
    var indexOf = require_array_includes().indexOf;
    var hiddenKeys = require_hidden_keys();
    var push = uncurryThis([].push);
    module.exports = function(object, names) {
      var O = toIndexedObject(object);
      var i = 0;
      var result = [];
      var key;
      for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
      while (names.length > i) if (hasOwn(O, key = names[i++])) {
        ~indexOf(result, key) || push(result, key);
      }
      return result;
    };
  }
});

// node_modules/core-js/internals/enum-bug-keys.js
var require_enum_bug_keys = __commonJS({
  "node_modules/core-js/internals/enum-bug-keys.js"(exports, module) {
    "use strict";
    module.exports = [
      "constructor",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "toLocaleString",
      "toString",
      "valueOf"
    ];
  }
});

// node_modules/core-js/internals/object-get-own-property-names.js
var require_object_get_own_property_names = __commonJS({
  "node_modules/core-js/internals/object-get-own-property-names.js"(exports) {
    "use strict";
    var internalObjectKeys = require_object_keys_internal();
    var enumBugKeys = require_enum_bug_keys();
    var hiddenKeys = enumBugKeys.concat("length", "prototype");
    exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
      return internalObjectKeys(O, hiddenKeys);
    };
  }
});

// node_modules/core-js/internals/object-get-own-property-symbols.js
var require_object_get_own_property_symbols = __commonJS({
  "node_modules/core-js/internals/object-get-own-property-symbols.js"(exports) {
    "use strict";
    exports.f = Object.getOwnPropertySymbols;
  }
});

// node_modules/core-js/internals/own-keys.js
var require_own_keys = __commonJS({
  "node_modules/core-js/internals/own-keys.js"(exports, module) {
    "use strict";
    var getBuiltIn = require_get_built_in();
    var uncurryThis = require_function_uncurry_this();
    var getOwnPropertyNamesModule = require_object_get_own_property_names();
    var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();
    var anObject = require_an_object();
    var concat = uncurryThis([].concat);
    module.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys(it) {
      var keys = getOwnPropertyNamesModule.f(anObject(it));
      var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
      return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
    };
  }
});

// node_modules/core-js/internals/copy-constructor-properties.js
var require_copy_constructor_properties = __commonJS({
  "node_modules/core-js/internals/copy-constructor-properties.js"(exports, module) {
    "use strict";
    var hasOwn = require_has_own_property();
    var ownKeys = require_own_keys();
    var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
    var definePropertyModule = require_object_define_property();
    module.exports = function(target, source, exceptions) {
      var keys = ownKeys(source);
      var defineProperty = definePropertyModule.f;
      var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
          defineProperty(target, key, getOwnPropertyDescriptor(source, key));
        }
      }
    };
  }
});

// node_modules/core-js/internals/is-forced.js
var require_is_forced = __commonJS({
  "node_modules/core-js/internals/is-forced.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    var isCallable = require_is_callable();
    var replacement = /#|\.prototype\./;
    var isForced = function(feature, detection) {
      var value = data[normalize(feature)];
      return value === POLYFILL ? true : value === NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
    };
    var normalize = isForced.normalize = function(string) {
      return String(string).replace(replacement, ".").toLowerCase();
    };
    var data = isForced.data = {};
    var NATIVE = isForced.NATIVE = "N";
    var POLYFILL = isForced.POLYFILL = "P";
    module.exports = isForced;
  }
});

// node_modules/core-js/internals/export.js
var require_export = __commonJS({
  "node_modules/core-js/internals/export.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var defineBuiltIn = require_define_built_in();
    var defineGlobalProperty = require_define_global_property();
    var copyConstructorProperties = require_copy_constructor_properties();
    var isForced = require_is_forced();
    module.exports = function(options, source) {
      var TARGET = options.target;
      var GLOBAL = options.global;
      var STATIC = options.stat;
      var FORCED, target, key, targetProperty, sourceProperty, descriptor;
      if (GLOBAL) {
        target = globalThis2;
      } else if (STATIC) {
        target = globalThis2[TARGET] || defineGlobalProperty(TARGET, {});
      } else {
        target = globalThis2[TARGET] && globalThis2[TARGET].prototype;
      }
      if (target) for (key in source) {
        sourceProperty = source[key];
        if (options.dontCallGetSet) {
          descriptor = getOwnPropertyDescriptor(target, key);
          targetProperty = descriptor && descriptor.value;
        } else targetProperty = target[key];
        FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
        if (!FORCED && targetProperty !== void 0) {
          if (typeof sourceProperty == typeof targetProperty) continue;
          copyConstructorProperties(sourceProperty, targetProperty);
        }
        if (options.sham || targetProperty && targetProperty.sham) {
          createNonEnumerableProperty(sourceProperty, "sham", true);
        }
        defineBuiltIn(target, key, sourceProperty, options);
      }
    };
  }
});

// node_modules/core-js/internals/set-to-string-tag.js
var require_set_to_string_tag = __commonJS({
  "node_modules/core-js/internals/set-to-string-tag.js"(exports, module) {
    "use strict";
    var defineProperty = require_object_define_property().f;
    var hasOwn = require_has_own_property();
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    module.exports = function(target, TAG, STATIC) {
      if (target && !STATIC) target = target.prototype;
      if (target && !hasOwn(target, TO_STRING_TAG)) {
        defineProperty(target, TO_STRING_TAG, { configurable: true, value: TAG });
      }
    };
  }
});

// node_modules/core-js/modules/es.reflect.to-string-tag.js
var require_es_reflect_to_string_tag = __commonJS({
  "node_modules/core-js/modules/es.reflect.to-string-tag.js"() {
    "use strict";
    var $ = require_export();
    var globalThis2 = require_global_this();
    var setToStringTag = require_set_to_string_tag();
    $({ global: true }, { Reflect: {} });
    setToStringTag(globalThis2.Reflect, "Reflect", true);
  }
});

// node_modules/core-js/internals/function-apply.js
var require_function_apply = __commonJS({
  "node_modules/core-js/internals/function-apply.js"(exports, module) {
    "use strict";
    var NATIVE_BIND = require_function_bind_native();
    var FunctionPrototype = Function.prototype;
    var apply = FunctionPrototype.apply;
    var call = FunctionPrototype.call;
    module.exports = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function() {
      return call.apply(apply, arguments);
    });
  }
});

// node_modules/core-js/internals/array-slice.js
var require_array_slice = __commonJS({
  "node_modules/core-js/internals/array-slice.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    module.exports = uncurryThis([].slice);
  }
});

// node_modules/core-js/internals/function-bind.js
var require_function_bind = __commonJS({
  "node_modules/core-js/internals/function-bind.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var aCallable = require_a_callable();
    var isObject = require_is_object();
    var hasOwn = require_has_own_property();
    var arraySlice = require_array_slice();
    var NATIVE_BIND = require_function_bind_native();
    var $Function = Function;
    var concat = uncurryThis([].concat);
    var join = uncurryThis([].join);
    var factories = {};
    var construct = function(C, argsLength, args) {
      if (!hasOwn(factories, argsLength)) {
        var list = [];
        var i = 0;
        for (; i < argsLength; i++) list[i] = "a[" + i + "]";
        factories[argsLength] = $Function("C,a", "return new C(" + join(list, ",") + ")");
      }
      return factories[argsLength](C, args);
    };
    module.exports = NATIVE_BIND ? $Function.bind : function bind(that) {
      var F = aCallable(this);
      var Prototype = F.prototype;
      var partArgs = arraySlice(arguments, 1);
      var boundFunction = function bound() {
        var args = concat(partArgs, arraySlice(arguments));
        return this instanceof boundFunction ? construct(F, args.length, args) : F.apply(that, args);
      };
      if (isObject(Prototype)) boundFunction.prototype = Prototype;
      return boundFunction;
    };
  }
});

// node_modules/core-js/internals/to-string-tag-support.js
var require_to_string_tag_support = __commonJS({
  "node_modules/core-js/internals/to-string-tag-support.js"(exports, module) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var test = {};
    test[TO_STRING_TAG] = "z";
    module.exports = String(test) === "[object z]";
  }
});

// node_modules/core-js/internals/classof.js
var require_classof = __commonJS({
  "node_modules/core-js/internals/classof.js"(exports, module) {
    "use strict";
    var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
    var isCallable = require_is_callable();
    var classofRaw = require_classof_raw();
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var $Object = Object;
    var CORRECT_ARGUMENTS = classofRaw(/* @__PURE__ */ function() {
      return arguments;
    }()) === "Arguments";
    var tryGet = function(it, key) {
      try {
        return it[key];
      } catch (error) {
      }
    };
    module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
      var O, tag, result;
      return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) === "Object" && isCallable(O.callee) ? "Arguments" : result;
    };
  }
});

// node_modules/core-js/internals/is-constructor.js
var require_is_constructor = __commonJS({
  "node_modules/core-js/internals/is-constructor.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var isCallable = require_is_callable();
    var classof = require_classof();
    var getBuiltIn = require_get_built_in();
    var inspectSource = require_inspect_source();
    var noop = function() {
    };
    var construct = getBuiltIn("Reflect", "construct");
    var constructorRegExp = /^\s*(?:class|function)\b/;
    var exec = uncurryThis(constructorRegExp.exec);
    var INCORRECT_TO_STRING = !constructorRegExp.test(noop);
    var isConstructorModern = function isConstructor(argument) {
      if (!isCallable(argument)) return false;
      try {
        construct(noop, [], argument);
        return true;
      } catch (error) {
        return false;
      }
    };
    var isConstructorLegacy = function isConstructor(argument) {
      if (!isCallable(argument)) return false;
      switch (classof(argument)) {
        case "AsyncFunction":
        case "GeneratorFunction":
        case "AsyncGeneratorFunction":
          return false;
      }
      try {
        return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
      } catch (error) {
        return true;
      }
    };
    isConstructorLegacy.sham = true;
    module.exports = !construct || fails(function() {
      var called;
      return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
        called = true;
      }) || called;
    }) ? isConstructorLegacy : isConstructorModern;
  }
});

// node_modules/core-js/internals/a-constructor.js
var require_a_constructor = __commonJS({
  "node_modules/core-js/internals/a-constructor.js"(exports, module) {
    "use strict";
    var isConstructor = require_is_constructor();
    var tryToString = require_try_to_string();
    var $TypeError = TypeError;
    module.exports = function(argument) {
      if (isConstructor(argument)) return argument;
      throw new $TypeError(tryToString(argument) + " is not a constructor");
    };
  }
});

// node_modules/core-js/internals/object-keys.js
var require_object_keys = __commonJS({
  "node_modules/core-js/internals/object-keys.js"(exports, module) {
    "use strict";
    var internalObjectKeys = require_object_keys_internal();
    var enumBugKeys = require_enum_bug_keys();
    module.exports = Object.keys || function keys(O) {
      return internalObjectKeys(O, enumBugKeys);
    };
  }
});

// node_modules/core-js/internals/object-define-properties.js
var require_object_define_properties = __commonJS({
  "node_modules/core-js/internals/object-define-properties.js"(exports) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var V8_PROTOTYPE_DEFINE_BUG = require_v8_prototype_define_bug();
    var definePropertyModule = require_object_define_property();
    var anObject = require_an_object();
    var toIndexedObject = require_to_indexed_object();
    var objectKeys = require_object_keys();
    exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
      anObject(O);
      var props = toIndexedObject(Properties);
      var keys = objectKeys(Properties);
      var length = keys.length;
      var index = 0;
      var key;
      while (length > index) definePropertyModule.f(O, key = keys[index++], props[key]);
      return O;
    };
  }
});

// node_modules/core-js/internals/html.js
var require_html = __commonJS({
  "node_modules/core-js/internals/html.js"(exports, module) {
    "use strict";
    var getBuiltIn = require_get_built_in();
    module.exports = getBuiltIn("document", "documentElement");
  }
});

// node_modules/core-js/internals/object-create.js
var require_object_create = __commonJS({
  "node_modules/core-js/internals/object-create.js"(exports, module) {
    "use strict";
    var anObject = require_an_object();
    var definePropertiesModule = require_object_define_properties();
    var enumBugKeys = require_enum_bug_keys();
    var hiddenKeys = require_hidden_keys();
    var html = require_html();
    var documentCreateElement = require_document_create_element();
    var sharedKey = require_shared_key();
    var GT = ">";
    var LT = "<";
    var PROTOTYPE = "prototype";
    var SCRIPT = "script";
    var IE_PROTO = sharedKey("IE_PROTO");
    var EmptyConstructor = function() {
    };
    var scriptTag = function(content) {
      return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
    };
    var NullProtoObjectViaActiveX = function(activeXDocument2) {
      activeXDocument2.write(scriptTag(""));
      activeXDocument2.close();
      var temp = activeXDocument2.parentWindow.Object;
      activeXDocument2 = null;
      return temp;
    };
    var NullProtoObjectViaIFrame = function() {
      var iframe = documentCreateElement("iframe");
      var JS = "java" + SCRIPT + ":";
      var iframeDocument;
      iframe.style.display = "none";
      html.appendChild(iframe);
      iframe.src = String(JS);
      iframeDocument = iframe.contentWindow.document;
      iframeDocument.open();
      iframeDocument.write(scriptTag("document.F=Object"));
      iframeDocument.close();
      return iframeDocument.F;
    };
    var activeXDocument;
    var NullProtoObject = function() {
      try {
        activeXDocument = new ActiveXObject("htmlfile");
      } catch (error) {
      }
      NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
      var length = enumBugKeys.length;
      while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
      return NullProtoObject();
    };
    hiddenKeys[IE_PROTO] = true;
    module.exports = Object.create || function create(O, Properties) {
      var result;
      if (O !== null) {
        EmptyConstructor[PROTOTYPE] = anObject(O);
        result = new EmptyConstructor();
        EmptyConstructor[PROTOTYPE] = null;
        result[IE_PROTO] = O;
      } else result = NullProtoObject();
      return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);
    };
  }
});

// node_modules/core-js/modules/es.reflect.construct.js
var require_es_reflect_construct = __commonJS({
  "node_modules/core-js/modules/es.reflect.construct.js"() {
    "use strict";
    var $ = require_export();
    var getBuiltIn = require_get_built_in();
    var apply = require_function_apply();
    var bind = require_function_bind();
    var aConstructor = require_a_constructor();
    var anObject = require_an_object();
    var isObject = require_is_object();
    var create = require_object_create();
    var fails = require_fails();
    var nativeConstruct = getBuiltIn("Reflect", "construct");
    var ObjectPrototype = Object.prototype;
    var push = [].push;
    var NEW_TARGET_BUG = fails(function() {
      function F() {
      }
      return !(nativeConstruct(function() {
      }, [], F) instanceof F);
    });
    var ARGS_BUG = !fails(function() {
      nativeConstruct(function() {
      });
    });
    var FORCED = NEW_TARGET_BUG || ARGS_BUG;
    $({ target: "Reflect", stat: true, forced: FORCED, sham: FORCED }, {
      construct: function construct(Target, args) {
        aConstructor(Target);
        anObject(args);
        var newTarget = arguments.length < 3 ? Target : aConstructor(arguments[2]);
        if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);
        if (Target === newTarget) {
          switch (args.length) {
            case 0:
              return new Target();
            case 1:
              return new Target(args[0]);
            case 2:
              return new Target(args[0], args[1]);
            case 3:
              return new Target(args[0], args[1], args[2]);
            case 4:
              return new Target(args[0], args[1], args[2], args[3]);
          }
          var $args = [null];
          apply(push, $args, args);
          return new (apply(bind, Target, $args))();
        }
        var proto = newTarget.prototype;
        var instance = create(isObject(proto) ? proto : ObjectPrototype);
        var result = apply(Target, instance, args);
        return isObject(result) ? result : instance;
      }
    });
  }
});

// node_modules/core-js/modules/es.object.keys.js
var require_es_object_keys = __commonJS({
  "node_modules/core-js/modules/es.object.keys.js"() {
    "use strict";
    var $ = require_export();
    var toObject = require_to_object();
    var nativeKeys = require_object_keys();
    var fails = require_fails();
    var FAILS_ON_PRIMITIVES = fails(function() {
      nativeKeys(1);
    });
    $({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES }, {
      keys: function keys(it) {
        return nativeKeys(toObject(it));
      }
    });
  }
});

// node_modules/core-js/internals/to-string.js
var require_to_string = __commonJS({
  "node_modules/core-js/internals/to-string.js"(exports, module) {
    "use strict";
    var classof = require_classof();
    var $String = String;
    module.exports = function(argument) {
      if (classof(argument) === "Symbol") throw new TypeError("Cannot convert a Symbol value to a string");
      return $String(argument);
    };
  }
});

// node_modules/core-js/internals/object-get-own-property-names-external.js
var require_object_get_own_property_names_external = __commonJS({
  "node_modules/core-js/internals/object-get-own-property-names-external.js"(exports, module) {
    "use strict";
    var classof = require_classof_raw();
    var toIndexedObject = require_to_indexed_object();
    var $getOwnPropertyNames = require_object_get_own_property_names().f;
    var arraySlice = require_array_slice();
    var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
    var getWindowNames = function(it) {
      try {
        return $getOwnPropertyNames(it);
      } catch (error) {
        return arraySlice(windowNames);
      }
    };
    module.exports.f = function getOwnPropertyNames(it) {
      return windowNames && classof(it) === "Window" ? getWindowNames(it) : $getOwnPropertyNames(toIndexedObject(it));
    };
  }
});

// node_modules/core-js/internals/define-built-in-accessor.js
var require_define_built_in_accessor = __commonJS({
  "node_modules/core-js/internals/define-built-in-accessor.js"(exports, module) {
    "use strict";
    var makeBuiltIn = require_make_built_in();
    var defineProperty = require_object_define_property();
    module.exports = function(target, name, descriptor) {
      if (descriptor.get) makeBuiltIn(descriptor.get, name, { getter: true });
      if (descriptor.set) makeBuiltIn(descriptor.set, name, { setter: true });
      return defineProperty.f(target, name, descriptor);
    };
  }
});

// node_modules/core-js/internals/well-known-symbol-wrapped.js
var require_well_known_symbol_wrapped = __commonJS({
  "node_modules/core-js/internals/well-known-symbol-wrapped.js"(exports) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    exports.f = wellKnownSymbol;
  }
});

// node_modules/core-js/internals/path.js
var require_path = __commonJS({
  "node_modules/core-js/internals/path.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    module.exports = globalThis2;
  }
});

// node_modules/core-js/internals/well-known-symbol-define.js
var require_well_known_symbol_define = __commonJS({
  "node_modules/core-js/internals/well-known-symbol-define.js"(exports, module) {
    "use strict";
    var path = require_path();
    var hasOwn = require_has_own_property();
    var wrappedWellKnownSymbolModule = require_well_known_symbol_wrapped();
    var defineProperty = require_object_define_property().f;
    module.exports = function(NAME) {
      var Symbol2 = path.Symbol || (path.Symbol = {});
      if (!hasOwn(Symbol2, NAME)) defineProperty(Symbol2, NAME, {
        value: wrappedWellKnownSymbolModule.f(NAME)
      });
    };
  }
});

// node_modules/core-js/internals/symbol-define-to-primitive.js
var require_symbol_define_to_primitive = __commonJS({
  "node_modules/core-js/internals/symbol-define-to-primitive.js"(exports, module) {
    "use strict";
    var call = require_function_call();
    var getBuiltIn = require_get_built_in();
    var wellKnownSymbol = require_well_known_symbol();
    var defineBuiltIn = require_define_built_in();
    module.exports = function() {
      var Symbol2 = getBuiltIn("Symbol");
      var SymbolPrototype = Symbol2 && Symbol2.prototype;
      var valueOf = SymbolPrototype && SymbolPrototype.valueOf;
      var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
      if (SymbolPrototype && !SymbolPrototype[TO_PRIMITIVE]) {
        defineBuiltIn(SymbolPrototype, TO_PRIMITIVE, function(hint) {
          return call(valueOf, this);
        }, { arity: 1 });
      }
    };
  }
});

// node_modules/core-js/internals/function-uncurry-this-clause.js
var require_function_uncurry_this_clause = __commonJS({
  "node_modules/core-js/internals/function-uncurry-this-clause.js"(exports, module) {
    "use strict";
    var classofRaw = require_classof_raw();
    var uncurryThis = require_function_uncurry_this();
    module.exports = function(fn) {
      if (classofRaw(fn) === "Function") return uncurryThis(fn);
    };
  }
});

// node_modules/core-js/internals/function-bind-context.js
var require_function_bind_context = __commonJS({
  "node_modules/core-js/internals/function-bind-context.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this_clause();
    var aCallable = require_a_callable();
    var NATIVE_BIND = require_function_bind_native();
    var bind = uncurryThis(uncurryThis.bind);
    module.exports = function(fn, that) {
      aCallable(fn);
      return that === void 0 ? fn : NATIVE_BIND ? bind(fn, that) : function() {
        return fn.apply(that, arguments);
      };
    };
  }
});

// node_modules/core-js/internals/is-array.js
var require_is_array = __commonJS({
  "node_modules/core-js/internals/is-array.js"(exports, module) {
    "use strict";
    var classof = require_classof_raw();
    module.exports = Array.isArray || function isArray(argument) {
      return classof(argument) === "Array";
    };
  }
});

// node_modules/core-js/internals/array-species-constructor.js
var require_array_species_constructor = __commonJS({
  "node_modules/core-js/internals/array-species-constructor.js"(exports, module) {
    "use strict";
    var isArray = require_is_array();
    var isConstructor = require_is_constructor();
    var isObject = require_is_object();
    var wellKnownSymbol = require_well_known_symbol();
    var SPECIES = wellKnownSymbol("species");
    var $Array = Array;
    module.exports = function(originalArray) {
      var C;
      if (isArray(originalArray)) {
        C = originalArray.constructor;
        if (isConstructor(C) && (C === $Array || isArray(C.prototype))) C = void 0;
        else if (isObject(C)) {
          C = C[SPECIES];
          if (C === null) C = void 0;
        }
      }
      return C === void 0 ? $Array : C;
    };
  }
});

// node_modules/core-js/internals/array-species-create.js
var require_array_species_create = __commonJS({
  "node_modules/core-js/internals/array-species-create.js"(exports, module) {
    "use strict";
    var arraySpeciesConstructor = require_array_species_constructor();
    module.exports = function(originalArray, length) {
      return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
    };
  }
});

// node_modules/core-js/internals/array-iteration.js
var require_array_iteration = __commonJS({
  "node_modules/core-js/internals/array-iteration.js"(exports, module) {
    "use strict";
    var bind = require_function_bind_context();
    var uncurryThis = require_function_uncurry_this();
    var IndexedObject = require_indexed_object();
    var toObject = require_to_object();
    var lengthOfArrayLike = require_length_of_array_like();
    var arraySpeciesCreate = require_array_species_create();
    var push = uncurryThis([].push);
    var createMethod = function(TYPE) {
      var IS_MAP = TYPE === 1;
      var IS_FILTER = TYPE === 2;
      var IS_SOME = TYPE === 3;
      var IS_EVERY = TYPE === 4;
      var IS_FIND_INDEX = TYPE === 6;
      var IS_FILTER_REJECT = TYPE === 7;
      var NO_HOLES = TYPE === 5 || IS_FIND_INDEX;
      return function($this, callbackfn, that, specificCreate) {
        var O = toObject($this);
        var self2 = IndexedObject(O);
        var length = lengthOfArrayLike(self2);
        var boundFunction = bind(callbackfn, that);
        var index = 0;
        var create = specificCreate || arraySpeciesCreate;
        var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : void 0;
        var value, result;
        for (; length > index; index++) if (NO_HOLES || index in self2) {
          value = self2[index];
          result = boundFunction(value, index, O);
          if (TYPE) {
            if (IS_MAP) target[index] = result;
            else if (result) switch (TYPE) {
              case 3:
                return true;
              case 5:
                return value;
              case 6:
                return index;
              case 2:
                push(target, value);
            }
            else switch (TYPE) {
              case 4:
                return false;
              case 7:
                push(target, value);
            }
          }
        }
        return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
      };
    };
    module.exports = {
      // `Array.prototype.forEach` method
      // https://tc39.es/ecma262/#sec-array.prototype.foreach
      forEach: createMethod(0),
      // `Array.prototype.map` method
      // https://tc39.es/ecma262/#sec-array.prototype.map
      map: createMethod(1),
      // `Array.prototype.filter` method
      // https://tc39.es/ecma262/#sec-array.prototype.filter
      filter: createMethod(2),
      // `Array.prototype.some` method
      // https://tc39.es/ecma262/#sec-array.prototype.some
      some: createMethod(3),
      // `Array.prototype.every` method
      // https://tc39.es/ecma262/#sec-array.prototype.every
      every: createMethod(4),
      // `Array.prototype.find` method
      // https://tc39.es/ecma262/#sec-array.prototype.find
      find: createMethod(5),
      // `Array.prototype.findIndex` method
      // https://tc39.es/ecma262/#sec-array.prototype.findIndex
      findIndex: createMethod(6),
      // `Array.prototype.filterReject` method
      // https://github.com/tc39/proposal-array-filtering
      filterReject: createMethod(7)
    };
  }
});

// node_modules/core-js/modules/es.symbol.constructor.js
var require_es_symbol_constructor = __commonJS({
  "node_modules/core-js/modules/es.symbol.constructor.js"() {
    "use strict";
    var $ = require_export();
    var globalThis2 = require_global_this();
    var call = require_function_call();
    var uncurryThis = require_function_uncurry_this();
    var IS_PURE = require_is_pure();
    var DESCRIPTORS = require_descriptors();
    var NATIVE_SYMBOL = require_symbol_constructor_detection();
    var fails = require_fails();
    var hasOwn = require_has_own_property();
    var isPrototypeOf = require_object_is_prototype_of();
    var anObject = require_an_object();
    var toIndexedObject = require_to_indexed_object();
    var toPropertyKey = require_to_property_key();
    var $toString = require_to_string();
    var createPropertyDescriptor = require_create_property_descriptor();
    var nativeObjectCreate = require_object_create();
    var objectKeys = require_object_keys();
    var getOwnPropertyNamesModule = require_object_get_own_property_names();
    var getOwnPropertyNamesExternal = require_object_get_own_property_names_external();
    var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();
    var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
    var definePropertyModule = require_object_define_property();
    var definePropertiesModule = require_object_define_properties();
    var propertyIsEnumerableModule = require_object_property_is_enumerable();
    var defineBuiltIn = require_define_built_in();
    var defineBuiltInAccessor = require_define_built_in_accessor();
    var shared = require_shared();
    var sharedKey = require_shared_key();
    var hiddenKeys = require_hidden_keys();
    var uid = require_uid();
    var wellKnownSymbol = require_well_known_symbol();
    var wrappedWellKnownSymbolModule = require_well_known_symbol_wrapped();
    var defineWellKnownSymbol = require_well_known_symbol_define();
    var defineSymbolToPrimitive = require_symbol_define_to_primitive();
    var setToStringTag = require_set_to_string_tag();
    var InternalStateModule = require_internal_state();
    var $forEach = require_array_iteration().forEach;
    var HIDDEN = sharedKey("hidden");
    var SYMBOL = "Symbol";
    var PROTOTYPE = "prototype";
    var setInternalState = InternalStateModule.set;
    var getInternalState = InternalStateModule.getterFor(SYMBOL);
    var ObjectPrototype = Object[PROTOTYPE];
    var $Symbol = globalThis2.Symbol;
    var SymbolPrototype = $Symbol && $Symbol[PROTOTYPE];
    var RangeError2 = globalThis2.RangeError;
    var TypeError2 = globalThis2.TypeError;
    var QObject = globalThis2.QObject;
    var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
    var nativeDefineProperty = definePropertyModule.f;
    var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
    var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
    var push = uncurryThis([].push);
    var AllSymbols = shared("symbols");
    var ObjectPrototypeSymbols = shared("op-symbols");
    var WellKnownSymbolsStore = shared("wks");
    var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
    var fallbackDefineProperty = function(O, P, Attributes) {
      var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
      if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
      nativeDefineProperty(O, P, Attributes);
      if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
        nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
      }
    };
    var setSymbolDescriptor = DESCRIPTORS && fails(function() {
      return nativeObjectCreate(nativeDefineProperty({}, "a", {
        get: function() {
          return nativeDefineProperty(this, "a", { value: 7 }).a;
        }
      })).a !== 7;
    }) ? fallbackDefineProperty : nativeDefineProperty;
    var wrap = function(tag, description) {
      var symbol = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype);
      setInternalState(symbol, {
        type: SYMBOL,
        tag,
        description
      });
      if (!DESCRIPTORS) symbol.description = description;
      return symbol;
    };
    var $defineProperty = function defineProperty(O, P, Attributes) {
      if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
      anObject(O);
      var key = toPropertyKey(P);
      anObject(Attributes);
      if (hasOwn(AllSymbols, key)) {
        if (!Attributes.enumerable) {
          if (!hasOwn(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, nativeObjectCreate(null)));
          O[HIDDEN][key] = true;
        } else {
          if (hasOwn(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
          Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
        }
        return setSymbolDescriptor(O, key, Attributes);
      }
      return nativeDefineProperty(O, key, Attributes);
    };
    var $defineProperties = function defineProperties(O, Properties) {
      anObject(O);
      var properties = toIndexedObject(Properties);
      var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
      $forEach(keys, function(key) {
        if (!DESCRIPTORS || call($propertyIsEnumerable, properties, key)) $defineProperty(O, key, properties[key]);
      });
      return O;
    };
    var $create = function create(O, Properties) {
      return Properties === void 0 ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
    };
    var $propertyIsEnumerable = function propertyIsEnumerable(V) {
      var P = toPropertyKey(V);
      var enumerable = call(nativePropertyIsEnumerable, this, P);
      if (this === ObjectPrototype && hasOwn(AllSymbols, P) && !hasOwn(ObjectPrototypeSymbols, P)) return false;
      return enumerable || !hasOwn(this, P) || !hasOwn(AllSymbols, P) || hasOwn(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
    };
    var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
      var it = toIndexedObject(O);
      var key = toPropertyKey(P);
      if (it === ObjectPrototype && hasOwn(AllSymbols, key) && !hasOwn(ObjectPrototypeSymbols, key)) return;
      var descriptor = nativeGetOwnPropertyDescriptor(it, key);
      if (descriptor && hasOwn(AllSymbols, key) && !(hasOwn(it, HIDDEN) && it[HIDDEN][key])) {
        descriptor.enumerable = true;
      }
      return descriptor;
    };
    var $getOwnPropertyNames = function getOwnPropertyNames(O) {
      var names = nativeGetOwnPropertyNames(toIndexedObject(O));
      var result = [];
      $forEach(names, function(key) {
        if (!hasOwn(AllSymbols, key) && !hasOwn(hiddenKeys, key)) push(result, key);
      });
      return result;
    };
    var $getOwnPropertySymbols = function(O) {
      var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
      var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
      var result = [];
      $forEach(names, function(key) {
        if (hasOwn(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn(ObjectPrototype, key))) {
          push(result, AllSymbols[key]);
        }
      });
      return result;
    };
    if (!NATIVE_SYMBOL) {
      $Symbol = function Symbol2() {
        if (isPrototypeOf(SymbolPrototype, this)) throw new TypeError2("Symbol is not a constructor");
        var description = !arguments.length || arguments[0] === void 0 ? void 0 : $toString(arguments[0]);
        var tag = uid(description);
        var setter = function(value) {
          var $this = this === void 0 ? globalThis2 : this;
          if ($this === ObjectPrototype) call(setter, ObjectPrototypeSymbols, value);
          if (hasOwn($this, HIDDEN) && hasOwn($this[HIDDEN], tag)) $this[HIDDEN][tag] = false;
          var descriptor = createPropertyDescriptor(1, value);
          try {
            setSymbolDescriptor($this, tag, descriptor);
          } catch (error) {
            if (!(error instanceof RangeError2)) throw error;
            fallbackDefineProperty($this, tag, descriptor);
          }
        };
        if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
        return wrap(tag, description);
      };
      SymbolPrototype = $Symbol[PROTOTYPE];
      defineBuiltIn(SymbolPrototype, "toString", function toString() {
        return getInternalState(this).tag;
      });
      defineBuiltIn($Symbol, "withoutSetter", function(description) {
        return wrap(uid(description), description);
      });
      propertyIsEnumerableModule.f = $propertyIsEnumerable;
      definePropertyModule.f = $defineProperty;
      definePropertiesModule.f = $defineProperties;
      getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
      getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
      getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;
      wrappedWellKnownSymbolModule.f = function(name) {
        return wrap(wellKnownSymbol(name), name);
      };
      if (DESCRIPTORS) {
        defineBuiltInAccessor(SymbolPrototype, "description", {
          configurable: true,
          get: function description() {
            return getInternalState(this).description;
          }
        });
        if (!IS_PURE) {
          defineBuiltIn(ObjectPrototype, "propertyIsEnumerable", $propertyIsEnumerable, { unsafe: true });
        }
      }
    }
    $({ global: true, constructor: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
      Symbol: $Symbol
    });
    $forEach(objectKeys(WellKnownSymbolsStore), function(name) {
      defineWellKnownSymbol(name);
    });
    $({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
      useSetter: function() {
        USE_SETTER = true;
      },
      useSimple: function() {
        USE_SETTER = false;
      }
    });
    $({ target: "Object", stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
      // `Object.create` method
      // https://tc39.es/ecma262/#sec-object.create
      create: $create,
      // `Object.defineProperty` method
      // https://tc39.es/ecma262/#sec-object.defineproperty
      defineProperty: $defineProperty,
      // `Object.defineProperties` method
      // https://tc39.es/ecma262/#sec-object.defineproperties
      defineProperties: $defineProperties,
      // `Object.getOwnPropertyDescriptor` method
      // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
      getOwnPropertyDescriptor: $getOwnPropertyDescriptor
    });
    $({ target: "Object", stat: true, forced: !NATIVE_SYMBOL }, {
      // `Object.getOwnPropertyNames` method
      // https://tc39.es/ecma262/#sec-object.getownpropertynames
      getOwnPropertyNames: $getOwnPropertyNames
    });
    defineSymbolToPrimitive();
    setToStringTag($Symbol, SYMBOL);
    hiddenKeys[HIDDEN] = true;
  }
});

// node_modules/core-js/internals/symbol-registry-detection.js
var require_symbol_registry_detection = __commonJS({
  "node_modules/core-js/internals/symbol-registry-detection.js"(exports, module) {
    "use strict";
    var NATIVE_SYMBOL = require_symbol_constructor_detection();
    module.exports = NATIVE_SYMBOL && !!Symbol["for"] && !!Symbol.keyFor;
  }
});

// node_modules/core-js/modules/es.symbol.for.js
var require_es_symbol_for = __commonJS({
  "node_modules/core-js/modules/es.symbol.for.js"() {
    "use strict";
    var $ = require_export();
    var getBuiltIn = require_get_built_in();
    var hasOwn = require_has_own_property();
    var toString = require_to_string();
    var shared = require_shared();
    var NATIVE_SYMBOL_REGISTRY = require_symbol_registry_detection();
    var StringToSymbolRegistry = shared("string-to-symbol-registry");
    var SymbolToStringRegistry = shared("symbol-to-string-registry");
    $({ target: "Symbol", stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
      "for": function(key) {
        var string = toString(key);
        if (hasOwn(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
        var symbol = getBuiltIn("Symbol")(string);
        StringToSymbolRegistry[string] = symbol;
        SymbolToStringRegistry[symbol] = string;
        return symbol;
      }
    });
  }
});

// node_modules/core-js/modules/es.symbol.key-for.js
var require_es_symbol_key_for = __commonJS({
  "node_modules/core-js/modules/es.symbol.key-for.js"() {
    "use strict";
    var $ = require_export();
    var hasOwn = require_has_own_property();
    var isSymbol = require_is_symbol();
    var tryToString = require_try_to_string();
    var shared = require_shared();
    var NATIVE_SYMBOL_REGISTRY = require_symbol_registry_detection();
    var SymbolToStringRegistry = shared("symbol-to-string-registry");
    $({ target: "Symbol", stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
      keyFor: function keyFor(sym) {
        if (!isSymbol(sym)) throw new TypeError(tryToString(sym) + " is not a symbol");
        if (hasOwn(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
      }
    });
  }
});

// node_modules/core-js/internals/get-json-replacer-function.js
var require_get_json_replacer_function = __commonJS({
  "node_modules/core-js/internals/get-json-replacer-function.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var isArray = require_is_array();
    var isCallable = require_is_callable();
    var classof = require_classof_raw();
    var toString = require_to_string();
    var push = uncurryThis([].push);
    module.exports = function(replacer) {
      if (isCallable(replacer)) return replacer;
      if (!isArray(replacer)) return;
      var rawLength = replacer.length;
      var keys = [];
      for (var i = 0; i < rawLength; i++) {
        var element = replacer[i];
        if (typeof element == "string") push(keys, element);
        else if (typeof element == "number" || classof(element) === "Number" || classof(element) === "String") push(keys, toString(element));
      }
      var keysLength = keys.length;
      var root = true;
      return function(key, value) {
        if (root) {
          root = false;
          return value;
        }
        if (isArray(this)) return value;
        for (var j = 0; j < keysLength; j++) if (keys[j] === key) return value;
      };
    };
  }
});

// node_modules/core-js/modules/es.json.stringify.js
var require_es_json_stringify = __commonJS({
  "node_modules/core-js/modules/es.json.stringify.js"() {
    "use strict";
    var $ = require_export();
    var getBuiltIn = require_get_built_in();
    var apply = require_function_apply();
    var call = require_function_call();
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var isCallable = require_is_callable();
    var isSymbol = require_is_symbol();
    var arraySlice = require_array_slice();
    var getReplacerFunction = require_get_json_replacer_function();
    var NATIVE_SYMBOL = require_symbol_constructor_detection();
    var $String = String;
    var $stringify = getBuiltIn("JSON", "stringify");
    var exec = uncurryThis(/./.exec);
    var charAt = uncurryThis("".charAt);
    var charCodeAt = uncurryThis("".charCodeAt);
    var replace = uncurryThis("".replace);
    var numberToString = uncurryThis(1.1.toString);
    var tester = /[\uD800-\uDFFF]/g;
    var low = /^[\uD800-\uDBFF]$/;
    var hi = /^[\uDC00-\uDFFF]$/;
    var WRONG_SYMBOLS_CONVERSION = !NATIVE_SYMBOL || fails(function() {
      var symbol = getBuiltIn("Symbol")("stringify detection");
      return $stringify([symbol]) !== "[null]" || $stringify({ a: symbol }) !== "{}" || $stringify(Object(symbol)) !== "{}";
    });
    var ILL_FORMED_UNICODE = fails(function() {
      return $stringify("\uDF06\uD834") !== '"\\udf06\\ud834"' || $stringify("\uDEAD") !== '"\\udead"';
    });
    var stringifyWithSymbolsFix = function(it, replacer) {
      var args = arraySlice(arguments);
      var $replacer = getReplacerFunction(replacer);
      if (!isCallable($replacer) && (it === void 0 || isSymbol(it))) return;
      args[1] = function(key, value) {
        if (isCallable($replacer)) value = call($replacer, this, $String(key), value);
        if (!isSymbol(value)) return value;
      };
      return apply($stringify, null, args);
    };
    var fixIllFormed = function(match, offset, string) {
      var prev = charAt(string, offset - 1);
      var next = charAt(string, offset + 1);
      if (exec(low, match) && !exec(hi, next) || exec(hi, match) && !exec(low, prev)) {
        return "\\u" + numberToString(charCodeAt(match, 0), 16);
      }
      return match;
    };
    if ($stringify) {
      $({ target: "JSON", stat: true, arity: 3, forced: WRONG_SYMBOLS_CONVERSION || ILL_FORMED_UNICODE }, {
        // eslint-disable-next-line no-unused-vars -- required for `.length`
        stringify: function stringify(it, replacer, space) {
          var args = arraySlice(arguments);
          var result = apply(WRONG_SYMBOLS_CONVERSION ? stringifyWithSymbolsFix : $stringify, null, args);
          return ILL_FORMED_UNICODE && typeof result == "string" ? replace(result, tester, fixIllFormed) : result;
        }
      });
    }
  }
});

// node_modules/core-js/modules/es.object.get-own-property-symbols.js
var require_es_object_get_own_property_symbols = __commonJS({
  "node_modules/core-js/modules/es.object.get-own-property-symbols.js"() {
    "use strict";
    var $ = require_export();
    var NATIVE_SYMBOL = require_symbol_constructor_detection();
    var fails = require_fails();
    var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();
    var toObject = require_to_object();
    var FORCED = !NATIVE_SYMBOL || fails(function() {
      getOwnPropertySymbolsModule.f(1);
    });
    $({ target: "Object", stat: true, forced: FORCED }, {
      getOwnPropertySymbols: function getOwnPropertySymbols(it) {
        var $getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
        return $getOwnPropertySymbols ? $getOwnPropertySymbols(toObject(it)) : [];
      }
    });
  }
});

// node_modules/core-js/modules/es.symbol.js
var require_es_symbol = __commonJS({
  "node_modules/core-js/modules/es.symbol.js"() {
    "use strict";
    require_es_symbol_constructor();
    require_es_symbol_for();
    require_es_symbol_key_for();
    require_es_json_stringify();
    require_es_object_get_own_property_symbols();
  }
});

// node_modules/core-js/internals/array-method-has-species-support.js
var require_array_method_has_species_support = __commonJS({
  "node_modules/core-js/internals/array-method-has-species-support.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    var wellKnownSymbol = require_well_known_symbol();
    var V8_VERSION = require_environment_v8_version();
    var SPECIES = wellKnownSymbol("species");
    module.exports = function(METHOD_NAME) {
      return V8_VERSION >= 51 || !fails(function() {
        var array = [];
        var constructor = array.constructor = {};
        constructor[SPECIES] = function() {
          return { foo: 1 };
        };
        return array[METHOD_NAME](Boolean).foo !== 1;
      });
    };
  }
});

// node_modules/core-js/modules/es.array.filter.js
var require_es_array_filter = __commonJS({
  "node_modules/core-js/modules/es.array.filter.js"() {
    "use strict";
    var $ = require_export();
    var $filter = require_array_iteration().filter;
    var arrayMethodHasSpeciesSupport = require_array_method_has_species_support();
    var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("filter");
    $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
      filter: function filter(callbackfn) {
        return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
  }
});

// node_modules/core-js/modules/es.object.get-own-property-descriptor.js
var require_es_object_get_own_property_descriptor = __commonJS({
  "node_modules/core-js/modules/es.object.get-own-property-descriptor.js"() {
    "use strict";
    var $ = require_export();
    var fails = require_fails();
    var toIndexedObject = require_to_indexed_object();
    var nativeGetOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
    var DESCRIPTORS = require_descriptors();
    var FORCED = !DESCRIPTORS || fails(function() {
      nativeGetOwnPropertyDescriptor(1);
    });
    $({ target: "Object", stat: true, forced: FORCED, sham: !DESCRIPTORS }, {
      getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
        return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);
      }
    });
  }
});

// node_modules/core-js/internals/create-property.js
var require_create_property = __commonJS({
  "node_modules/core-js/internals/create-property.js"(exports, module) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var definePropertyModule = require_object_define_property();
    var createPropertyDescriptor = require_create_property_descriptor();
    module.exports = function(object, key, value) {
      if (DESCRIPTORS) definePropertyModule.f(object, key, createPropertyDescriptor(0, value));
      else object[key] = value;
    };
  }
});

// node_modules/core-js/modules/es.object.get-own-property-descriptors.js
var require_es_object_get_own_property_descriptors = __commonJS({
  "node_modules/core-js/modules/es.object.get-own-property-descriptors.js"() {
    "use strict";
    var $ = require_export();
    var DESCRIPTORS = require_descriptors();
    var ownKeys = require_own_keys();
    var toIndexedObject = require_to_indexed_object();
    var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
    var createProperty = require_create_property();
    $({ target: "Object", stat: true, sham: !DESCRIPTORS }, {
      getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
        var O = toIndexedObject(object);
        var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
        var keys = ownKeys(O);
        var result = {};
        var index = 0;
        var key, descriptor;
        while (keys.length > index) {
          descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
          if (descriptor !== void 0) createProperty(result, key, descriptor);
        }
        return result;
      }
    });
  }
});

// node_modules/@babel/runtime/helpers/asyncToGenerator.js
var require_asyncToGenerator = __commonJS({
  "node_modules/@babel/runtime/helpers/asyncToGenerator.js"(exports, module) {
    function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
        var i = n[a](c), u = i.value;
      } catch (n2) {
        return void e(n2);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
          var a = n.apply(t, e);
          function _next(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    module.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/assertThisInitialized.js
var require_assertThisInitialized = __commonJS({
  "node_modules/@babel/runtime/helpers/assertThisInitialized.js"(exports, module) {
    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/setPrototypeOf.js
var require_setPrototypeOf = __commonJS({
  "node_modules/@babel/runtime/helpers/setPrototypeOf.js"(exports, module) {
    function _setPrototypeOf(t, e) {
      return module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _setPrototypeOf(t, e);
    }
    module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/inherits.js
var require_inherits = __commonJS({
  "node_modules/@babel/runtime/helpers/inherits.js"(exports, module) {
    var setPrototypeOf = require_setPrototypeOf();
    function _inherits(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: true,
          configurable: true
        }
      }), Object.defineProperty(t, "prototype", {
        writable: false
      }), e && setPrototypeOf(t, e);
    }
    module.exports = _inherits, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/typeof.js
var require_typeof = __commonJS({
  "node_modules/@babel/runtime/helpers/typeof.js"(exports, module) {
    function _typeof(o) {
      "@babel/helpers - typeof";
      return module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(o);
    }
    module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/possibleConstructorReturn.js
var require_possibleConstructorReturn = __commonJS({
  "node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"(exports, module) {
    var _typeof = require_typeof()["default"];
    var assertThisInitialized = require_assertThisInitialized();
    function _possibleConstructorReturn(t, e) {
      if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
      if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
      return assertThisInitialized(t);
    }
    module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/getPrototypeOf.js
var require_getPrototypeOf = __commonJS({
  "node_modules/@babel/runtime/helpers/getPrototypeOf.js"(exports, module) {
    function _getPrototypeOf(t) {
      return module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _getPrototypeOf(t);
    }
    module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/toPrimitive.js
var require_toPrimitive = __commonJS({
  "node_modules/@babel/runtime/helpers/toPrimitive.js"(exports, module) {
    var _typeof = require_typeof()["default"];
    function toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    module.exports = toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/toPropertyKey.js
var require_toPropertyKey = __commonJS({
  "node_modules/@babel/runtime/helpers/toPropertyKey.js"(exports, module) {
    var _typeof = require_typeof()["default"];
    var toPrimitive = require_toPrimitive();
    function toPropertyKey(t) {
      var i = toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    module.exports = toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/defineProperty.js
var require_defineProperty = __commonJS({
  "node_modules/@babel/runtime/helpers/defineProperty.js"(exports, module) {
    var toPropertyKey = require_toPropertyKey();
    function _defineProperty(e, r, t) {
      return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
      }) : e[r] = t, e;
    }
    module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/createClass.js
var require_createClass = __commonJS({
  "node_modules/@babel/runtime/helpers/createClass.js"(exports, module) {
    var toPropertyKey = require_toPropertyKey();
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
        writable: false
      }), e;
    }
    module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/classCallCheck.js
var require_classCallCheck = __commonJS({
  "node_modules/@babel/runtime/helpers/classCallCheck.js"(exports, module) {
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/core-js/modules/es.array.map.js
var require_es_array_map = __commonJS({
  "node_modules/core-js/modules/es.array.map.js"() {
    "use strict";
    var $ = require_export();
    var $map = require_array_iteration().map;
    var arrayMethodHasSpeciesSupport = require_array_method_has_species_support();
    var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("map");
    $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
      map: function map(callbackfn) {
        return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
  }
});

// node_modules/core-js/internals/object-to-string.js
var require_object_to_string = __commonJS({
  "node_modules/core-js/internals/object-to-string.js"(exports, module) {
    "use strict";
    var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
    var classof = require_classof();
    module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
      return "[object " + classof(this) + "]";
    };
  }
});

// node_modules/core-js/modules/es.object.to-string.js
var require_es_object_to_string = __commonJS({
  "node_modules/core-js/modules/es.object.to-string.js"() {
    "use strict";
    var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
    var defineBuiltIn = require_define_built_in();
    var toString = require_object_to_string();
    if (!TO_STRING_TAG_SUPPORT) {
      defineBuiltIn(Object.prototype, "toString", toString, { unsafe: true });
    }
  }
});

// node_modules/core-js/internals/dom-iterables.js
var require_dom_iterables = __commonJS({
  "node_modules/core-js/internals/dom-iterables.js"(exports, module) {
    "use strict";
    module.exports = {
      CSSRuleList: 0,
      CSSStyleDeclaration: 0,
      CSSValueList: 0,
      ClientRectList: 0,
      DOMRectList: 0,
      DOMStringList: 0,
      DOMTokenList: 1,
      DataTransferItemList: 0,
      FileList: 0,
      HTMLAllCollection: 0,
      HTMLCollection: 0,
      HTMLFormElement: 0,
      HTMLSelectElement: 0,
      MediaList: 0,
      MimeTypeArray: 0,
      NamedNodeMap: 0,
      NodeList: 1,
      PaintRequestList: 0,
      Plugin: 0,
      PluginArray: 0,
      SVGLengthList: 0,
      SVGNumberList: 0,
      SVGPathSegList: 0,
      SVGPointList: 0,
      SVGStringList: 0,
      SVGTransformList: 0,
      SourceBufferList: 0,
      StyleSheetList: 0,
      TextTrackCueList: 0,
      TextTrackList: 0,
      TouchList: 0
    };
  }
});

// node_modules/core-js/internals/dom-token-list-prototype.js
var require_dom_token_list_prototype = __commonJS({
  "node_modules/core-js/internals/dom-token-list-prototype.js"(exports, module) {
    "use strict";
    var documentCreateElement = require_document_create_element();
    var classList = documentCreateElement("span").classList;
    var DOMTokenListPrototype = classList && classList.constructor && classList.constructor.prototype;
    module.exports = DOMTokenListPrototype === Object.prototype ? void 0 : DOMTokenListPrototype;
  }
});

// node_modules/core-js/internals/array-method-is-strict.js
var require_array_method_is_strict = __commonJS({
  "node_modules/core-js/internals/array-method-is-strict.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    module.exports = function(METHOD_NAME, argument) {
      var method = [][METHOD_NAME];
      return !!method && fails(function() {
        method.call(null, argument || function() {
          return 1;
        }, 1);
      });
    };
  }
});

// node_modules/core-js/internals/array-for-each.js
var require_array_for_each = __commonJS({
  "node_modules/core-js/internals/array-for-each.js"(exports, module) {
    "use strict";
    var $forEach = require_array_iteration().forEach;
    var arrayMethodIsStrict = require_array_method_is_strict();
    var STRICT_METHOD = arrayMethodIsStrict("forEach");
    module.exports = !STRICT_METHOD ? function forEach(callbackfn) {
      return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    } : [].forEach;
  }
});

// node_modules/core-js/modules/web.dom-collections.for-each.js
var require_web_dom_collections_for_each = __commonJS({
  "node_modules/core-js/modules/web.dom-collections.for-each.js"() {
    "use strict";
    var globalThis2 = require_global_this();
    var DOMIterables = require_dom_iterables();
    var DOMTokenListPrototype = require_dom_token_list_prototype();
    var forEach = require_array_for_each();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var handlePrototype = function(CollectionPrototype) {
      if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {
        createNonEnumerableProperty(CollectionPrototype, "forEach", forEach);
      } catch (error) {
        CollectionPrototype.forEach = forEach;
      }
    };
    for (COLLECTION_NAME in DOMIterables) {
      if (DOMIterables[COLLECTION_NAME]) {
        handlePrototype(globalThis2[COLLECTION_NAME] && globalThis2[COLLECTION_NAME].prototype);
      }
    }
    var COLLECTION_NAME;
    handlePrototype(DOMTokenListPrototype);
  }
});

// node_modules/core-js/internals/environment.js
var require_environment = __commonJS({
  "node_modules/core-js/internals/environment.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var userAgent = require_environment_user_agent();
    var classof = require_classof_raw();
    var userAgentStartsWith = function(string) {
      return userAgent.slice(0, string.length) === string;
    };
    module.exports = function() {
      if (userAgentStartsWith("Bun/")) return "BUN";
      if (userAgentStartsWith("Cloudflare-Workers")) return "CLOUDFLARE";
      if (userAgentStartsWith("Deno/")) return "DENO";
      if (userAgentStartsWith("Node.js/")) return "NODE";
      if (globalThis2.Bun && typeof Bun.version == "string") return "BUN";
      if (globalThis2.Deno && typeof Deno.version == "object") return "DENO";
      if (classof(globalThis2.process) === "process") return "NODE";
      if (globalThis2.window && globalThis2.document) return "BROWSER";
      return "REST";
    }();
  }
});

// node_modules/core-js/internals/environment-is-node.js
var require_environment_is_node = __commonJS({
  "node_modules/core-js/internals/environment-is-node.js"(exports, module) {
    "use strict";
    var ENVIRONMENT = require_environment();
    module.exports = ENVIRONMENT === "NODE";
  }
});

// node_modules/core-js/internals/function-uncurry-this-accessor.js
var require_function_uncurry_this_accessor = __commonJS({
  "node_modules/core-js/internals/function-uncurry-this-accessor.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var aCallable = require_a_callable();
    module.exports = function(object, key, method) {
      try {
        return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object, key)[method]));
      } catch (error) {
      }
    };
  }
});

// node_modules/core-js/internals/is-possible-prototype.js
var require_is_possible_prototype = __commonJS({
  "node_modules/core-js/internals/is-possible-prototype.js"(exports, module) {
    "use strict";
    var isObject = require_is_object();
    module.exports = function(argument) {
      return isObject(argument) || argument === null;
    };
  }
});

// node_modules/core-js/internals/a-possible-prototype.js
var require_a_possible_prototype = __commonJS({
  "node_modules/core-js/internals/a-possible-prototype.js"(exports, module) {
    "use strict";
    var isPossiblePrototype = require_is_possible_prototype();
    var $String = String;
    var $TypeError = TypeError;
    module.exports = function(argument) {
      if (isPossiblePrototype(argument)) return argument;
      throw new $TypeError("Can't set " + $String(argument) + " as a prototype");
    };
  }
});

// node_modules/core-js/internals/object-set-prototype-of.js
var require_object_set_prototype_of = __commonJS({
  "node_modules/core-js/internals/object-set-prototype-of.js"(exports, module) {
    "use strict";
    var uncurryThisAccessor = require_function_uncurry_this_accessor();
    var isObject = require_is_object();
    var requireObjectCoercible = require_require_object_coercible();
    var aPossiblePrototype = require_a_possible_prototype();
    module.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
      var CORRECT_SETTER = false;
      var test = {};
      var setter;
      try {
        setter = uncurryThisAccessor(Object.prototype, "__proto__", "set");
        setter(test, []);
        CORRECT_SETTER = test instanceof Array;
      } catch (error) {
      }
      return function setPrototypeOf(O, proto) {
        requireObjectCoercible(O);
        aPossiblePrototype(proto);
        if (!isObject(O)) return O;
        if (CORRECT_SETTER) setter(O, proto);
        else O.__proto__ = proto;
        return O;
      };
    }() : void 0);
  }
});

// node_modules/core-js/internals/set-species.js
var require_set_species = __commonJS({
  "node_modules/core-js/internals/set-species.js"(exports, module) {
    "use strict";
    var getBuiltIn = require_get_built_in();
    var defineBuiltInAccessor = require_define_built_in_accessor();
    var wellKnownSymbol = require_well_known_symbol();
    var DESCRIPTORS = require_descriptors();
    var SPECIES = wellKnownSymbol("species");
    module.exports = function(CONSTRUCTOR_NAME) {
      var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
      if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
        defineBuiltInAccessor(Constructor, SPECIES, {
          configurable: true,
          get: function() {
            return this;
          }
        });
      }
    };
  }
});

// node_modules/core-js/internals/an-instance.js
var require_an_instance = __commonJS({
  "node_modules/core-js/internals/an-instance.js"(exports, module) {
    "use strict";
    var isPrototypeOf = require_object_is_prototype_of();
    var $TypeError = TypeError;
    module.exports = function(it, Prototype) {
      if (isPrototypeOf(Prototype, it)) return it;
      throw new $TypeError("Incorrect invocation");
    };
  }
});

// node_modules/core-js/internals/species-constructor.js
var require_species_constructor = __commonJS({
  "node_modules/core-js/internals/species-constructor.js"(exports, module) {
    "use strict";
    var anObject = require_an_object();
    var aConstructor = require_a_constructor();
    var isNullOrUndefined = require_is_null_or_undefined();
    var wellKnownSymbol = require_well_known_symbol();
    var SPECIES = wellKnownSymbol("species");
    module.exports = function(O, defaultConstructor) {
      var C = anObject(O).constructor;
      var S;
      return C === void 0 || isNullOrUndefined(S = anObject(C)[SPECIES]) ? defaultConstructor : aConstructor(S);
    };
  }
});

// node_modules/core-js/internals/validate-arguments-length.js
var require_validate_arguments_length = __commonJS({
  "node_modules/core-js/internals/validate-arguments-length.js"(exports, module) {
    "use strict";
    var $TypeError = TypeError;
    module.exports = function(passed, required) {
      if (passed < required) throw new $TypeError("Not enough arguments");
      return passed;
    };
  }
});

// node_modules/core-js/internals/environment-is-ios.js
var require_environment_is_ios = __commonJS({
  "node_modules/core-js/internals/environment-is-ios.js"(exports, module) {
    "use strict";
    var userAgent = require_environment_user_agent();
    module.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent);
  }
});

// node_modules/core-js/internals/task.js
var require_task = __commonJS({
  "node_modules/core-js/internals/task.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var apply = require_function_apply();
    var bind = require_function_bind_context();
    var isCallable = require_is_callable();
    var hasOwn = require_has_own_property();
    var fails = require_fails();
    var html = require_html();
    var arraySlice = require_array_slice();
    var createElement = require_document_create_element();
    var validateArgumentsLength = require_validate_arguments_length();
    var IS_IOS = require_environment_is_ios();
    var IS_NODE = require_environment_is_node();
    var set = globalThis2.setImmediate;
    var clear = globalThis2.clearImmediate;
    var process = globalThis2.process;
    var Dispatch = globalThis2.Dispatch;
    var Function2 = globalThis2.Function;
    var MessageChannel = globalThis2.MessageChannel;
    var String2 = globalThis2.String;
    var counter = 0;
    var queue = {};
    var ONREADYSTATECHANGE = "onreadystatechange";
    var $location;
    var defer;
    var channel;
    var port;
    fails(function() {
      $location = globalThis2.location;
    });
    var run = function(id) {
      if (hasOwn(queue, id)) {
        var fn = queue[id];
        delete queue[id];
        fn();
      }
    };
    var runner = function(id) {
      return function() {
        run(id);
      };
    };
    var eventListener = function(event) {
      run(event.data);
    };
    var globalPostMessageDefer = function(id) {
      globalThis2.postMessage(String2(id), $location.protocol + "//" + $location.host);
    };
    if (!set || !clear) {
      set = function setImmediate(handler) {
        validateArgumentsLength(arguments.length, 1);
        var fn = isCallable(handler) ? handler : Function2(handler);
        var args = arraySlice(arguments, 1);
        queue[++counter] = function() {
          apply(fn, void 0, args);
        };
        defer(counter);
        return counter;
      };
      clear = function clearImmediate(id) {
        delete queue[id];
      };
      if (IS_NODE) {
        defer = function(id) {
          process.nextTick(runner(id));
        };
      } else if (Dispatch && Dispatch.now) {
        defer = function(id) {
          Dispatch.now(runner(id));
        };
      } else if (MessageChannel && !IS_IOS) {
        channel = new MessageChannel();
        port = channel.port2;
        channel.port1.onmessage = eventListener;
        defer = bind(port.postMessage, port);
      } else if (globalThis2.addEventListener && isCallable(globalThis2.postMessage) && !globalThis2.importScripts && $location && $location.protocol !== "file:" && !fails(globalPostMessageDefer)) {
        defer = globalPostMessageDefer;
        globalThis2.addEventListener("message", eventListener, false);
      } else if (ONREADYSTATECHANGE in createElement("script")) {
        defer = function(id) {
          html.appendChild(createElement("script"))[ONREADYSTATECHANGE] = function() {
            html.removeChild(this);
            run(id);
          };
        };
      } else {
        defer = function(id) {
          setTimeout(runner(id), 0);
        };
      }
    }
    module.exports = {
      set,
      clear
    };
  }
});

// node_modules/core-js/internals/safe-get-built-in.js
var require_safe_get_built_in = __commonJS({
  "node_modules/core-js/internals/safe-get-built-in.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var DESCRIPTORS = require_descriptors();
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    module.exports = function(name) {
      if (!DESCRIPTORS) return globalThis2[name];
      var descriptor = getOwnPropertyDescriptor(globalThis2, name);
      return descriptor && descriptor.value;
    };
  }
});

// node_modules/core-js/internals/queue.js
var require_queue = __commonJS({
  "node_modules/core-js/internals/queue.js"(exports, module) {
    "use strict";
    var Queue = function() {
      this.head = null;
      this.tail = null;
    };
    Queue.prototype = {
      add: function(item) {
        var entry = { item, next: null };
        var tail = this.tail;
        if (tail) tail.next = entry;
        else this.head = entry;
        this.tail = entry;
      },
      get: function() {
        var entry = this.head;
        if (entry) {
          var next = this.head = entry.next;
          if (next === null) this.tail = null;
          return entry.item;
        }
      }
    };
    module.exports = Queue;
  }
});

// node_modules/core-js/internals/environment-is-ios-pebble.js
var require_environment_is_ios_pebble = __commonJS({
  "node_modules/core-js/internals/environment-is-ios-pebble.js"(exports, module) {
    "use strict";
    var userAgent = require_environment_user_agent();
    module.exports = /ipad|iphone|ipod/i.test(userAgent) && typeof Pebble != "undefined";
  }
});

// node_modules/core-js/internals/environment-is-webos-webkit.js
var require_environment_is_webos_webkit = __commonJS({
  "node_modules/core-js/internals/environment-is-webos-webkit.js"(exports, module) {
    "use strict";
    var userAgent = require_environment_user_agent();
    module.exports = /web0s(?!.*chrome)/i.test(userAgent);
  }
});

// node_modules/core-js/internals/microtask.js
var require_microtask = __commonJS({
  "node_modules/core-js/internals/microtask.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var safeGetBuiltIn = require_safe_get_built_in();
    var bind = require_function_bind_context();
    var macrotask = require_task().set;
    var Queue = require_queue();
    var IS_IOS = require_environment_is_ios();
    var IS_IOS_PEBBLE = require_environment_is_ios_pebble();
    var IS_WEBOS_WEBKIT = require_environment_is_webos_webkit();
    var IS_NODE = require_environment_is_node();
    var MutationObserver = globalThis2.MutationObserver || globalThis2.WebKitMutationObserver;
    var document2 = globalThis2.document;
    var process = globalThis2.process;
    var Promise2 = globalThis2.Promise;
    var microtask = safeGetBuiltIn("queueMicrotask");
    var notify;
    var toggle;
    var node;
    var promise;
    var then;
    if (!microtask) {
      queue = new Queue();
      flush = function() {
        var parent, fn;
        if (IS_NODE && (parent = process.domain)) parent.exit();
        while (fn = queue.get()) try {
          fn();
        } catch (error) {
          if (queue.head) notify();
          throw error;
        }
        if (parent) parent.enter();
      };
      if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver && document2) {
        toggle = true;
        node = document2.createTextNode("");
        new MutationObserver(flush).observe(node, { characterData: true });
        notify = function() {
          node.data = toggle = !toggle;
        };
      } else if (!IS_IOS_PEBBLE && Promise2 && Promise2.resolve) {
        promise = Promise2.resolve(void 0);
        promise.constructor = Promise2;
        then = bind(promise.then, promise);
        notify = function() {
          then(flush);
        };
      } else if (IS_NODE) {
        notify = function() {
          process.nextTick(flush);
        };
      } else {
        macrotask = bind(macrotask, globalThis2);
        notify = function() {
          macrotask(flush);
        };
      }
      microtask = function(fn) {
        if (!queue.head) notify();
        queue.add(fn);
      };
    }
    var queue;
    var flush;
    module.exports = microtask;
  }
});

// node_modules/core-js/internals/host-report-errors.js
var require_host_report_errors = __commonJS({
  "node_modules/core-js/internals/host-report-errors.js"(exports, module) {
    "use strict";
    module.exports = function(a, b) {
      try {
        arguments.length === 1 ? console.error(a) : console.error(a, b);
      } catch (error) {
      }
    };
  }
});

// node_modules/core-js/internals/perform.js
var require_perform = __commonJS({
  "node_modules/core-js/internals/perform.js"(exports, module) {
    "use strict";
    module.exports = function(exec) {
      try {
        return { error: false, value: exec() };
      } catch (error) {
        return { error: true, value: error };
      }
    };
  }
});

// node_modules/core-js/internals/promise-native-constructor.js
var require_promise_native_constructor = __commonJS({
  "node_modules/core-js/internals/promise-native-constructor.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    module.exports = globalThis2.Promise;
  }
});

// node_modules/core-js/internals/promise-constructor-detection.js
var require_promise_constructor_detection = __commonJS({
  "node_modules/core-js/internals/promise-constructor-detection.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var NativePromiseConstructor = require_promise_native_constructor();
    var isCallable = require_is_callable();
    var isForced = require_is_forced();
    var inspectSource = require_inspect_source();
    var wellKnownSymbol = require_well_known_symbol();
    var ENVIRONMENT = require_environment();
    var IS_PURE = require_is_pure();
    var V8_VERSION = require_environment_v8_version();
    var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
    var SPECIES = wellKnownSymbol("species");
    var SUBCLASSING = false;
    var NATIVE_PROMISE_REJECTION_EVENT = isCallable(globalThis2.PromiseRejectionEvent);
    var FORCED_PROMISE_CONSTRUCTOR = isForced("Promise", function() {
      var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor);
      var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor);
      if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66) return true;
      if (IS_PURE && !(NativePromisePrototype["catch"] && NativePromisePrototype["finally"])) return true;
      if (!V8_VERSION || V8_VERSION < 51 || !/native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) {
        var promise = new NativePromiseConstructor(function(resolve) {
          resolve(1);
        });
        var FakePromise = function(exec) {
          exec(function() {
          }, function() {
          });
        };
        var constructor = promise.constructor = {};
        constructor[SPECIES] = FakePromise;
        SUBCLASSING = promise.then(function() {
        }) instanceof FakePromise;
        if (!SUBCLASSING) return true;
      }
      return !GLOBAL_CORE_JS_PROMISE && (ENVIRONMENT === "BROWSER" || ENVIRONMENT === "DENO") && !NATIVE_PROMISE_REJECTION_EVENT;
    });
    module.exports = {
      CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR,
      REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT,
      SUBCLASSING
    };
  }
});

// node_modules/core-js/internals/new-promise-capability.js
var require_new_promise_capability = __commonJS({
  "node_modules/core-js/internals/new-promise-capability.js"(exports, module) {
    "use strict";
    var aCallable = require_a_callable();
    var $TypeError = TypeError;
    var PromiseCapability = function(C) {
      var resolve, reject;
      this.promise = new C(function($$resolve, $$reject) {
        if (resolve !== void 0 || reject !== void 0) throw new $TypeError("Bad Promise constructor");
        resolve = $$resolve;
        reject = $$reject;
      });
      this.resolve = aCallable(resolve);
      this.reject = aCallable(reject);
    };
    module.exports.f = function(C) {
      return new PromiseCapability(C);
    };
  }
});

// node_modules/core-js/modules/es.promise.constructor.js
var require_es_promise_constructor = __commonJS({
  "node_modules/core-js/modules/es.promise.constructor.js"() {
    "use strict";
    var $ = require_export();
    var IS_PURE = require_is_pure();
    var IS_NODE = require_environment_is_node();
    var globalThis2 = require_global_this();
    var path = require_path();
    var call = require_function_call();
    var defineBuiltIn = require_define_built_in();
    var setPrototypeOf = require_object_set_prototype_of();
    var setToStringTag = require_set_to_string_tag();
    var setSpecies = require_set_species();
    var aCallable = require_a_callable();
    var isCallable = require_is_callable();
    var isObject = require_is_object();
    var anInstance = require_an_instance();
    var speciesConstructor = require_species_constructor();
    var task = require_task().set;
    var microtask = require_microtask();
    var hostReportErrors = require_host_report_errors();
    var perform = require_perform();
    var Queue = require_queue();
    var InternalStateModule = require_internal_state();
    var NativePromiseConstructor = require_promise_native_constructor();
    var PromiseConstructorDetection = require_promise_constructor_detection();
    var newPromiseCapabilityModule = require_new_promise_capability();
    var PROMISE = "Promise";
    var FORCED_PROMISE_CONSTRUCTOR = PromiseConstructorDetection.CONSTRUCTOR;
    var NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;
    var NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;
    var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
    var setInternalState = InternalStateModule.set;
    var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
    var PromiseConstructor = NativePromiseConstructor;
    var PromisePrototype = NativePromisePrototype;
    var TypeError2 = globalThis2.TypeError;
    var document2 = globalThis2.document;
    var process = globalThis2.process;
    var newPromiseCapability = newPromiseCapabilityModule.f;
    var newGenericPromiseCapability = newPromiseCapability;
    var DISPATCH_EVENT = !!(document2 && document2.createEvent && globalThis2.dispatchEvent);
    var UNHANDLED_REJECTION = "unhandledrejection";
    var REJECTION_HANDLED = "rejectionhandled";
    var PENDING = 0;
    var FULFILLED = 1;
    var REJECTED = 2;
    var HANDLED = 1;
    var UNHANDLED = 2;
    var Internal;
    var OwnPromiseCapability;
    var PromiseWrapper;
    var nativeThen;
    var isThenable = function(it) {
      var then;
      return isObject(it) && isCallable(then = it.then) ? then : false;
    };
    var callReaction = function(reaction, state) {
      var value = state.value;
      var ok = state.state === FULFILLED;
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (state.rejection === UNHANDLED) onHandleUnhandled(state);
            state.rejection = HANDLED;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value);
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(new TypeError2("Promise-chain cycle"));
          } else if (then = isThenable(result)) {
            call(then, result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (error) {
        if (domain && !exited) domain.exit();
        reject(error);
      }
    };
    var notify = function(state, isReject) {
      if (state.notified) return;
      state.notified = true;
      microtask(function() {
        var reactions = state.reactions;
        var reaction;
        while (reaction = reactions.get()) {
          callReaction(reaction, state);
        }
        state.notified = false;
        if (isReject && !state.rejection) onUnhandled(state);
      });
    };
    var dispatchEvent = function(name, promise, reason) {
      var event, handler;
      if (DISPATCH_EVENT) {
        event = document2.createEvent("Event");
        event.promise = promise;
        event.reason = reason;
        event.initEvent(name, false, true);
        globalThis2.dispatchEvent(event);
      } else event = { promise, reason };
      if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = globalThis2["on" + name])) handler(event);
      else if (name === UNHANDLED_REJECTION) hostReportErrors("Unhandled promise rejection", reason);
    };
    var onUnhandled = function(state) {
      call(task, globalThis2, function() {
        var promise = state.facade;
        var value = state.value;
        var IS_UNHANDLED = isUnhandled(state);
        var result;
        if (IS_UNHANDLED) {
          result = perform(function() {
            if (IS_NODE) {
              process.emit("unhandledRejection", value, promise);
            } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
          });
          state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
          if (result.error) throw result.value;
        }
      });
    };
    var isUnhandled = function(state) {
      return state.rejection !== HANDLED && !state.parent;
    };
    var onHandleUnhandled = function(state) {
      call(task, globalThis2, function() {
        var promise = state.facade;
        if (IS_NODE) {
          process.emit("rejectionHandled", promise);
        } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
      });
    };
    var bind = function(fn, state, unwrap) {
      return function(value) {
        fn(state, value, unwrap);
      };
    };
    var internalReject = function(state, value, unwrap) {
      if (state.done) return;
      state.done = true;
      if (unwrap) state = unwrap;
      state.value = value;
      state.state = REJECTED;
      notify(state, true);
    };
    var internalResolve = function(state, value, unwrap) {
      if (state.done) return;
      state.done = true;
      if (unwrap) state = unwrap;
      try {
        if (state.facade === value) throw new TypeError2("Promise can't be resolved itself");
        var then = isThenable(value);
        if (then) {
          microtask(function() {
            var wrapper = { done: false };
            try {
              call(
                then,
                value,
                bind(internalResolve, wrapper, state),
                bind(internalReject, wrapper, state)
              );
            } catch (error) {
              internalReject(wrapper, error, state);
            }
          });
        } else {
          state.value = value;
          state.state = FULFILLED;
          notify(state, false);
        }
      } catch (error) {
        internalReject({ done: false }, error, state);
      }
    };
    if (FORCED_PROMISE_CONSTRUCTOR) {
      PromiseConstructor = function Promise2(executor) {
        anInstance(this, PromisePrototype);
        aCallable(executor);
        call(Internal, this);
        var state = getInternalPromiseState(this);
        try {
          executor(bind(internalResolve, state), bind(internalReject, state));
        } catch (error) {
          internalReject(state, error);
        }
      };
      PromisePrototype = PromiseConstructor.prototype;
      Internal = function Promise2(executor) {
        setInternalState(this, {
          type: PROMISE,
          done: false,
          notified: false,
          parent: false,
          reactions: new Queue(),
          rejection: false,
          state: PENDING,
          value: null
        });
      };
      Internal.prototype = defineBuiltIn(PromisePrototype, "then", function then(onFulfilled, onRejected) {
        var state = getInternalPromiseState(this);
        var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
        state.parent = true;
        reaction.ok = isCallable(onFulfilled) ? onFulfilled : true;
        reaction.fail = isCallable(onRejected) && onRejected;
        reaction.domain = IS_NODE ? process.domain : void 0;
        if (state.state === PENDING) state.reactions.add(reaction);
        else microtask(function() {
          callReaction(reaction, state);
        });
        return reaction.promise;
      });
      OwnPromiseCapability = function() {
        var promise = new Internal();
        var state = getInternalPromiseState(promise);
        this.promise = promise;
        this.resolve = bind(internalResolve, state);
        this.reject = bind(internalReject, state);
      };
      newPromiseCapabilityModule.f = newPromiseCapability = function(C) {
        return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
      };
      if (!IS_PURE && isCallable(NativePromiseConstructor) && NativePromisePrototype !== Object.prototype) {
        nativeThen = NativePromisePrototype.then;
        if (!NATIVE_PROMISE_SUBCLASSING) {
          defineBuiltIn(NativePromisePrototype, "then", function then(onFulfilled, onRejected) {
            var that = this;
            return new PromiseConstructor(function(resolve, reject) {
              call(nativeThen, that, resolve, reject);
            }).then(onFulfilled, onRejected);
          }, { unsafe: true });
        }
        try {
          delete NativePromisePrototype.constructor;
        } catch (error) {
        }
        if (setPrototypeOf) {
          setPrototypeOf(NativePromisePrototype, PromisePrototype);
        }
      }
    }
    $({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
      Promise: PromiseConstructor
    });
    PromiseWrapper = path.Promise;
    setToStringTag(PromiseConstructor, PROMISE, false, true);
    setSpecies(PROMISE);
  }
});

// node_modules/core-js/internals/iterators.js
var require_iterators = __commonJS({
  "node_modules/core-js/internals/iterators.js"(exports, module) {
    "use strict";
    module.exports = {};
  }
});

// node_modules/core-js/internals/is-array-iterator-method.js
var require_is_array_iterator_method = __commonJS({
  "node_modules/core-js/internals/is-array-iterator-method.js"(exports, module) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    var Iterators = require_iterators();
    var ITERATOR = wellKnownSymbol("iterator");
    var ArrayPrototype = Array.prototype;
    module.exports = function(it) {
      return it !== void 0 && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
    };
  }
});

// node_modules/core-js/internals/get-iterator-method.js
var require_get_iterator_method = __commonJS({
  "node_modules/core-js/internals/get-iterator-method.js"(exports, module) {
    "use strict";
    var classof = require_classof();
    var getMethod = require_get_method();
    var isNullOrUndefined = require_is_null_or_undefined();
    var Iterators = require_iterators();
    var wellKnownSymbol = require_well_known_symbol();
    var ITERATOR = wellKnownSymbol("iterator");
    module.exports = function(it) {
      if (!isNullOrUndefined(it)) return getMethod(it, ITERATOR) || getMethod(it, "@@iterator") || Iterators[classof(it)];
    };
  }
});

// node_modules/core-js/internals/get-iterator.js
var require_get_iterator = __commonJS({
  "node_modules/core-js/internals/get-iterator.js"(exports, module) {
    "use strict";
    var call = require_function_call();
    var aCallable = require_a_callable();
    var anObject = require_an_object();
    var tryToString = require_try_to_string();
    var getIteratorMethod = require_get_iterator_method();
    var $TypeError = TypeError;
    module.exports = function(argument, usingIterator) {
      var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
      if (aCallable(iteratorMethod)) return anObject(call(iteratorMethod, argument));
      throw new $TypeError(tryToString(argument) + " is not iterable");
    };
  }
});

// node_modules/core-js/internals/iterator-close.js
var require_iterator_close = __commonJS({
  "node_modules/core-js/internals/iterator-close.js"(exports, module) {
    "use strict";
    var call = require_function_call();
    var anObject = require_an_object();
    var getMethod = require_get_method();
    module.exports = function(iterator, kind, value) {
      var innerResult, innerError;
      anObject(iterator);
      try {
        innerResult = getMethod(iterator, "return");
        if (!innerResult) {
          if (kind === "throw") throw value;
          return value;
        }
        innerResult = call(innerResult, iterator);
      } catch (error) {
        innerError = true;
        innerResult = error;
      }
      if (kind === "throw") throw value;
      if (innerError) throw innerResult;
      anObject(innerResult);
      return value;
    };
  }
});

// node_modules/core-js/internals/iterate.js
var require_iterate = __commonJS({
  "node_modules/core-js/internals/iterate.js"(exports, module) {
    "use strict";
    var bind = require_function_bind_context();
    var call = require_function_call();
    var anObject = require_an_object();
    var tryToString = require_try_to_string();
    var isArrayIteratorMethod = require_is_array_iterator_method();
    var lengthOfArrayLike = require_length_of_array_like();
    var isPrototypeOf = require_object_is_prototype_of();
    var getIterator = require_get_iterator();
    var getIteratorMethod = require_get_iterator_method();
    var iteratorClose = require_iterator_close();
    var $TypeError = TypeError;
    var Result = function(stopped, result) {
      this.stopped = stopped;
      this.result = result;
    };
    var ResultPrototype = Result.prototype;
    module.exports = function(iterable, unboundFunction, options) {
      var that = options && options.that;
      var AS_ENTRIES = !!(options && options.AS_ENTRIES);
      var IS_RECORD = !!(options && options.IS_RECORD);
      var IS_ITERATOR = !!(options && options.IS_ITERATOR);
      var INTERRUPTED = !!(options && options.INTERRUPTED);
      var fn = bind(unboundFunction, that);
      var iterator, iterFn, index, length, result, next, step;
      var stop = function(condition) {
        if (iterator) iteratorClose(iterator, "normal");
        return new Result(true, condition);
      };
      var callFn = function(value) {
        if (AS_ENTRIES) {
          anObject(value);
          return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
        }
        return INTERRUPTED ? fn(value, stop) : fn(value);
      };
      if (IS_RECORD) {
        iterator = iterable.iterator;
      } else if (IS_ITERATOR) {
        iterator = iterable;
      } else {
        iterFn = getIteratorMethod(iterable);
        if (!iterFn) throw new $TypeError(tryToString(iterable) + " is not iterable");
        if (isArrayIteratorMethod(iterFn)) {
          for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
            result = callFn(iterable[index]);
            if (result && isPrototypeOf(ResultPrototype, result)) return result;
          }
          return new Result(false);
        }
        iterator = getIterator(iterable, iterFn);
      }
      next = IS_RECORD ? iterable.next : iterator.next;
      while (!(step = call(next, iterator)).done) {
        try {
          result = callFn(step.value);
        } catch (error) {
          iteratorClose(iterator, "throw", error);
        }
        if (typeof result == "object" && result && isPrototypeOf(ResultPrototype, result)) return result;
      }
      return new Result(false);
    };
  }
});

// node_modules/core-js/internals/check-correctness-of-iteration.js
var require_check_correctness_of_iteration = __commonJS({
  "node_modules/core-js/internals/check-correctness-of-iteration.js"(exports, module) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    var ITERATOR = wellKnownSymbol("iterator");
    var SAFE_CLOSING = false;
    try {
      called = 0;
      iteratorWithReturn = {
        next: function() {
          return { done: !!called++ };
        },
        "return": function() {
          SAFE_CLOSING = true;
        }
      };
      iteratorWithReturn[ITERATOR] = function() {
        return this;
      };
      Array.from(iteratorWithReturn, function() {
        throw 2;
      });
    } catch (error) {
    }
    var called;
    var iteratorWithReturn;
    module.exports = function(exec, SKIP_CLOSING) {
      try {
        if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
      } catch (error) {
        return false;
      }
      var ITERATION_SUPPORT = false;
      try {
        var object = {};
        object[ITERATOR] = function() {
          return {
            next: function() {
              return { done: ITERATION_SUPPORT = true };
            }
          };
        };
        exec(object);
      } catch (error) {
      }
      return ITERATION_SUPPORT;
    };
  }
});

// node_modules/core-js/internals/promise-statics-incorrect-iteration.js
var require_promise_statics_incorrect_iteration = __commonJS({
  "node_modules/core-js/internals/promise-statics-incorrect-iteration.js"(exports, module) {
    "use strict";
    var NativePromiseConstructor = require_promise_native_constructor();
    var checkCorrectnessOfIteration = require_check_correctness_of_iteration();
    var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
    module.exports = FORCED_PROMISE_CONSTRUCTOR || !checkCorrectnessOfIteration(function(iterable) {
      NativePromiseConstructor.all(iterable).then(void 0, function() {
      });
    });
  }
});

// node_modules/core-js/modules/es.promise.all.js
var require_es_promise_all = __commonJS({
  "node_modules/core-js/modules/es.promise.all.js"() {
    "use strict";
    var $ = require_export();
    var call = require_function_call();
    var aCallable = require_a_callable();
    var newPromiseCapabilityModule = require_new_promise_capability();
    var perform = require_perform();
    var iterate = require_iterate();
    var PROMISE_STATICS_INCORRECT_ITERATION = require_promise_statics_incorrect_iteration();
    $({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
      all: function all(iterable) {
        var C = this;
        var capability = newPromiseCapabilityModule.f(C);
        var resolve = capability.resolve;
        var reject = capability.reject;
        var result = perform(function() {
          var $promiseResolve = aCallable(C.resolve);
          var values = [];
          var counter = 0;
          var remaining = 1;
          iterate(iterable, function(promise) {
            var index = counter++;
            var alreadyCalled = false;
            remaining++;
            call($promiseResolve, C, promise).then(function(value) {
              if (alreadyCalled) return;
              alreadyCalled = true;
              values[index] = value;
              --remaining || resolve(values);
            }, reject);
          });
          --remaining || resolve(values);
        });
        if (result.error) reject(result.value);
        return capability.promise;
      }
    });
  }
});

// node_modules/core-js/modules/es.promise.catch.js
var require_es_promise_catch = __commonJS({
  "node_modules/core-js/modules/es.promise.catch.js"() {
    "use strict";
    var $ = require_export();
    var IS_PURE = require_is_pure();
    var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
    var NativePromiseConstructor = require_promise_native_constructor();
    var getBuiltIn = require_get_built_in();
    var isCallable = require_is_callable();
    var defineBuiltIn = require_define_built_in();
    var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
    $({ target: "Promise", proto: true, forced: FORCED_PROMISE_CONSTRUCTOR, real: true }, {
      "catch": function(onRejected) {
        return this.then(void 0, onRejected);
      }
    });
    if (!IS_PURE && isCallable(NativePromiseConstructor)) {
      method = getBuiltIn("Promise").prototype["catch"];
      if (NativePromisePrototype["catch"] !== method) {
        defineBuiltIn(NativePromisePrototype, "catch", method, { unsafe: true });
      }
    }
    var method;
  }
});

// node_modules/core-js/modules/es.promise.race.js
var require_es_promise_race = __commonJS({
  "node_modules/core-js/modules/es.promise.race.js"() {
    "use strict";
    var $ = require_export();
    var call = require_function_call();
    var aCallable = require_a_callable();
    var newPromiseCapabilityModule = require_new_promise_capability();
    var perform = require_perform();
    var iterate = require_iterate();
    var PROMISE_STATICS_INCORRECT_ITERATION = require_promise_statics_incorrect_iteration();
    $({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
      race: function race(iterable) {
        var C = this;
        var capability = newPromiseCapabilityModule.f(C);
        var reject = capability.reject;
        var result = perform(function() {
          var $promiseResolve = aCallable(C.resolve);
          iterate(iterable, function(promise) {
            call($promiseResolve, C, promise).then(capability.resolve, reject);
          });
        });
        if (result.error) reject(result.value);
        return capability.promise;
      }
    });
  }
});

// node_modules/core-js/modules/es.promise.reject.js
var require_es_promise_reject = __commonJS({
  "node_modules/core-js/modules/es.promise.reject.js"() {
    "use strict";
    var $ = require_export();
    var newPromiseCapabilityModule = require_new_promise_capability();
    var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
    $({ target: "Promise", stat: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
      reject: function reject(r) {
        var capability = newPromiseCapabilityModule.f(this);
        var capabilityReject = capability.reject;
        capabilityReject(r);
        return capability.promise;
      }
    });
  }
});

// node_modules/core-js/internals/promise-resolve.js
var require_promise_resolve = __commonJS({
  "node_modules/core-js/internals/promise-resolve.js"(exports, module) {
    "use strict";
    var anObject = require_an_object();
    var isObject = require_is_object();
    var newPromiseCapability = require_new_promise_capability();
    module.exports = function(C, x) {
      anObject(C);
      if (isObject(x) && x.constructor === C) return x;
      var promiseCapability = newPromiseCapability.f(C);
      var resolve = promiseCapability.resolve;
      resolve(x);
      return promiseCapability.promise;
    };
  }
});

// node_modules/core-js/modules/es.promise.resolve.js
var require_es_promise_resolve = __commonJS({
  "node_modules/core-js/modules/es.promise.resolve.js"() {
    "use strict";
    var $ = require_export();
    var getBuiltIn = require_get_built_in();
    var IS_PURE = require_is_pure();
    var NativePromiseConstructor = require_promise_native_constructor();
    var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
    var promiseResolve = require_promise_resolve();
    var PromiseConstructorWrapper = getBuiltIn("Promise");
    var CHECK_WRAPPER = IS_PURE && !FORCED_PROMISE_CONSTRUCTOR;
    $({ target: "Promise", stat: true, forced: IS_PURE || FORCED_PROMISE_CONSTRUCTOR }, {
      resolve: function resolve(x) {
        return promiseResolve(CHECK_WRAPPER && this === PromiseConstructorWrapper ? NativePromiseConstructor : this, x);
      }
    });
  }
});

// node_modules/core-js/modules/es.promise.js
var require_es_promise = __commonJS({
  "node_modules/core-js/modules/es.promise.js"() {
    "use strict";
    require_es_promise_constructor();
    require_es_promise_all();
    require_es_promise_catch();
    require_es_promise_race();
    require_es_promise_reject();
    require_es_promise_resolve();
  }
});

// node_modules/@babel/runtime/helpers/OverloadYield.js
var require_OverloadYield = __commonJS({
  "node_modules/@babel/runtime/helpers/OverloadYield.js"(exports, module) {
    function _OverloadYield(e, d) {
      this.v = e, this.k = d;
    }
    module.exports = _OverloadYield, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/regeneratorDefine.js
var require_regeneratorDefine = __commonJS({
  "node_modules/@babel/runtime/helpers/regeneratorDefine.js"(exports, module) {
    function _regeneratorDefine(e, r, n, t) {
      var i = Object.defineProperty;
      try {
        i({}, "", {});
      } catch (e2) {
        i = 0;
      }
      module.exports = _regeneratorDefine = function regeneratorDefine(e2, r2, n2, t2) {
        if (r2) i ? i(e2, r2, {
          value: n2,
          enumerable: !t2,
          configurable: !t2,
          writable: !t2
        }) : e2[r2] = n2;
        else {
          var o = function o2(r3, n3) {
            _regeneratorDefine(e2, r3, function(e3) {
              return this._invoke(r3, n3, e3);
            });
          };
          o("next", 0), o("throw", 1), o("return", 2);
        }
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _regeneratorDefine(e, r, n, t);
    }
    module.exports = _regeneratorDefine, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/regenerator.js
var require_regenerator = __commonJS({
  "node_modules/@babel/runtime/helpers/regenerator.js"(exports, module) {
    var regeneratorDefine = require_regeneratorDefine();
    function _regenerator() {
      var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag";
      function i(r2, n2, o2, i2) {
        var c2 = n2 && n2.prototype instanceof Generator ? n2 : Generator, u2 = Object.create(c2.prototype);
        return regeneratorDefine(u2, "_invoke", function(r3, n3, o3) {
          var i3, c3, u3, f2 = 0, p = o3 || [], y = false, G = {
            p: 0,
            n: 0,
            v: e,
            a: d,
            f: d.bind(e, 4),
            d: function d2(t2, r4) {
              return i3 = t2, c3 = 0, u3 = e, G.n = r4, a;
            }
          };
          function d(r4, n4) {
            for (c3 = r4, u3 = n4, t = 0; !y && f2 && !o4 && t < p.length; t++) {
              var o4, i4 = p[t], d2 = G.p, l = i4[2];
              r4 > 3 ? (o4 = l === n4) && (u3 = i4[(c3 = i4[4]) ? 5 : (c3 = 3, 3)], i4[4] = i4[5] = e) : i4[0] <= d2 && ((o4 = r4 < 2 && d2 < i4[1]) ? (c3 = 0, G.v = n4, G.n = i4[1]) : d2 < l && (o4 = r4 < 3 || i4[0] > n4 || n4 > l) && (i4[4] = r4, i4[5] = n4, G.n = l, c3 = 0));
            }
            if (o4 || r4 > 1) return a;
            throw y = true, n4;
          }
          return function(o4, p2, l) {
            if (f2 > 1) throw TypeError("Generator is already running");
            for (y && 1 === p2 && d(p2, l), c3 = p2, u3 = l; (t = c3 < 2 ? e : u3) || !y; ) {
              i3 || (c3 ? c3 < 3 ? (c3 > 1 && (G.n = -1), d(c3, u3)) : G.n = u3 : G.v = u3);
              try {
                if (f2 = 2, i3) {
                  if (c3 || (o4 = "next"), t = i3[o4]) {
                    if (!(t = t.call(i3, u3))) throw TypeError("iterator result is not an object");
                    if (!t.done) return t;
                    u3 = t.value, c3 < 2 && (c3 = 0);
                  } else 1 === c3 && (t = i3["return"]) && t.call(i3), c3 < 2 && (u3 = TypeError("The iterator does not provide a '" + o4 + "' method"), c3 = 1);
                  i3 = e;
                } else if ((t = (y = G.n < 0) ? u3 : r3.call(n3, G)) !== a) break;
              } catch (t2) {
                i3 = e, c3 = 1, u3 = t2;
              } finally {
                f2 = 1;
              }
            }
            return {
              value: t,
              done: y
            };
          };
        }(r2, o2, i2), true), u2;
      }
      var a = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      t = Object.getPrototypeOf;
      var c = [][n] ? t(t([][n]())) : (regeneratorDefine(t = {}, n, function() {
        return this;
      }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c);
      function f(e2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(e2, GeneratorFunctionPrototype) : (e2.__proto__ = GeneratorFunctionPrototype, regeneratorDefine(e2, o, "GeneratorFunction")), e2.prototype = Object.create(u), e2;
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, regeneratorDefine(u, "constructor", GeneratorFunctionPrototype), regeneratorDefine(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", regeneratorDefine(GeneratorFunctionPrototype, o, "GeneratorFunction"), regeneratorDefine(u), regeneratorDefine(u, o, "Generator"), regeneratorDefine(u, n, function() {
        return this;
      }), regeneratorDefine(u, "toString", function() {
        return "[object Generator]";
      }), (module.exports = _regenerator = function _regenerator2() {
        return {
          w: i,
          m: f
        };
      }, module.exports.__esModule = true, module.exports["default"] = module.exports)();
    }
    module.exports = _regenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/regeneratorAsyncIterator.js
var require_regeneratorAsyncIterator = __commonJS({
  "node_modules/@babel/runtime/helpers/regeneratorAsyncIterator.js"(exports, module) {
    var OverloadYield = require_OverloadYield();
    var regeneratorDefine = require_regeneratorDefine();
    function AsyncIterator(t, e) {
      function n(r2, o, i, f) {
        try {
          var c = t[r2](o), u = c.value;
          return u instanceof OverloadYield ? e.resolve(u.v).then(function(t2) {
            n("next", t2, i, f);
          }, function(t2) {
            n("throw", t2, i, f);
          }) : e.resolve(u).then(function(t2) {
            c.value = t2, i(c);
          }, function(t2) {
            return n("throw", t2, i, f);
          });
        } catch (t2) {
          f(t2);
        }
      }
      var r;
      this.next || (regeneratorDefine(AsyncIterator.prototype), regeneratorDefine(AsyncIterator.prototype, "function" == typeof Symbol && Symbol.asyncIterator || "@asyncIterator", function() {
        return this;
      })), regeneratorDefine(this, "_invoke", function(t2, o, i) {
        function f() {
          return new e(function(e2, r2) {
            n(t2, i, e2, r2);
          });
        }
        return r = r ? r.then(f, f) : f();
      }, true);
    }
    module.exports = AsyncIterator, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/regeneratorAsyncGen.js
var require_regeneratorAsyncGen = __commonJS({
  "node_modules/@babel/runtime/helpers/regeneratorAsyncGen.js"(exports, module) {
    var regenerator = require_regenerator();
    var regeneratorAsyncIterator = require_regeneratorAsyncIterator();
    function _regeneratorAsyncGen(r, e, t, o, n) {
      return new regeneratorAsyncIterator(regenerator().w(r, e, t, o), n || Promise);
    }
    module.exports = _regeneratorAsyncGen, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/regeneratorAsync.js
var require_regeneratorAsync = __commonJS({
  "node_modules/@babel/runtime/helpers/regeneratorAsync.js"(exports, module) {
    var regeneratorAsyncGen = require_regeneratorAsyncGen();
    function _regeneratorAsync(n, e, r, t, o) {
      var a = regeneratorAsyncGen(n, e, r, t, o);
      return a.next().then(function(n2) {
        return n2.done ? n2.value : a.next();
      });
    }
    module.exports = _regeneratorAsync, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/regeneratorKeys.js
var require_regeneratorKeys = __commonJS({
  "node_modules/@babel/runtime/helpers/regeneratorKeys.js"(exports, module) {
    function _regeneratorKeys(e) {
      var n = Object(e), r = [];
      for (var t in n) r.unshift(t);
      return function e2() {
        for (; r.length; ) if ((t = r.pop()) in n) return e2.value = t, e2.done = false, e2;
        return e2.done = true, e2;
      };
    }
    module.exports = _regeneratorKeys, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/regeneratorValues.js
var require_regeneratorValues = __commonJS({
  "node_modules/@babel/runtime/helpers/regeneratorValues.js"(exports, module) {
    var _typeof = require_typeof()["default"];
    function _regeneratorValues(e) {
      if (null != e) {
        var t = e["function" == typeof Symbol && Symbol.iterator || "@@iterator"], r = 0;
        if (t) return t.call(e);
        if ("function" == typeof e.next) return e;
        if (!isNaN(e.length)) return {
          next: function next() {
            return e && r >= e.length && (e = void 0), {
              value: e && e[r++],
              done: !e
            };
          }
        };
      }
      throw new TypeError(_typeof(e) + " is not iterable");
    }
    module.exports = _regeneratorValues, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/regeneratorRuntime.js
var require_regeneratorRuntime = __commonJS({
  "node_modules/@babel/runtime/helpers/regeneratorRuntime.js"(exports, module) {
    var OverloadYield = require_OverloadYield();
    var regenerator = require_regenerator();
    var regeneratorAsync = require_regeneratorAsync();
    var regeneratorAsyncGen = require_regeneratorAsyncGen();
    var regeneratorAsyncIterator = require_regeneratorAsyncIterator();
    var regeneratorKeys = require_regeneratorKeys();
    var regeneratorValues = require_regeneratorValues();
    function _regeneratorRuntime() {
      "use strict";
      var r = regenerator(), e = r.m(_regeneratorRuntime), t = (Object.getPrototypeOf ? Object.getPrototypeOf(e) : e.__proto__).constructor;
      function n(r2) {
        var e2 = "function" == typeof r2 && r2.constructor;
        return !!e2 && (e2 === t || "GeneratorFunction" === (e2.displayName || e2.name));
      }
      var o = {
        "throw": 1,
        "return": 2,
        "break": 3,
        "continue": 3
      };
      function a(r2) {
        var e2, t2;
        return function(n2) {
          e2 || (e2 = {
            stop: function stop() {
              return t2(n2.a, 2);
            },
            "catch": function _catch() {
              return n2.v;
            },
            abrupt: function abrupt(r3, e3) {
              return t2(n2.a, o[r3], e3);
            },
            delegateYield: function delegateYield(r3, o2, a2) {
              return e2.resultName = o2, t2(n2.d, regeneratorValues(r3), a2);
            },
            finish: function finish(r3) {
              return t2(n2.f, r3);
            }
          }, t2 = function t3(r3, _t, o2) {
            n2.p = e2.prev, n2.n = e2.next;
            try {
              return r3(_t, o2);
            } finally {
              e2.next = n2.n;
            }
          }), e2.resultName && (e2[e2.resultName] = n2.v, e2.resultName = void 0), e2.sent = n2.v, e2.next = n2.n;
          try {
            return r2.call(this, e2);
          } finally {
            n2.p = e2.prev, n2.n = e2.next;
          }
        };
      }
      return (module.exports = _regeneratorRuntime = function _regeneratorRuntime2() {
        return {
          wrap: function wrap(e2, t2, n2, o2) {
            return r.w(a(e2), t2, n2, o2 && o2.reverse());
          },
          isGeneratorFunction: n,
          mark: r.m,
          awrap: function awrap(r2, e2) {
            return new OverloadYield(r2, e2);
          },
          AsyncIterator: regeneratorAsyncIterator,
          async: function async(r2, e2, t2, o2, u) {
            return (n(e2) ? regeneratorAsyncGen : regeneratorAsync)(a(r2), e2, t2, o2, u);
          },
          keys: regeneratorKeys,
          values: regeneratorValues
        };
      }, module.exports.__esModule = true, module.exports["default"] = module.exports)();
    }
    module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/regenerator/index.js
var require_regenerator2 = __commonJS({
  "node_modules/@babel/runtime/regenerator/index.js"(exports, module) {
    var runtime = require_regeneratorRuntime()();
    module.exports = runtime;
    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
      } else {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }
  }
});

// node_modules/core-js/internals/does-not-exceed-safe-integer.js
var require_does_not_exceed_safe_integer = __commonJS({
  "node_modules/core-js/internals/does-not-exceed-safe-integer.js"(exports, module) {
    "use strict";
    var $TypeError = TypeError;
    var MAX_SAFE_INTEGER = 9007199254740991;
    module.exports = function(it) {
      if (it > MAX_SAFE_INTEGER) throw $TypeError("Maximum allowed index exceeded");
      return it;
    };
  }
});

// node_modules/core-js/modules/es.array.concat.js
var require_es_array_concat = __commonJS({
  "node_modules/core-js/modules/es.array.concat.js"() {
    "use strict";
    var $ = require_export();
    var fails = require_fails();
    var isArray = require_is_array();
    var isObject = require_is_object();
    var toObject = require_to_object();
    var lengthOfArrayLike = require_length_of_array_like();
    var doesNotExceedSafeInteger = require_does_not_exceed_safe_integer();
    var createProperty = require_create_property();
    var arraySpeciesCreate = require_array_species_create();
    var arrayMethodHasSpeciesSupport = require_array_method_has_species_support();
    var wellKnownSymbol = require_well_known_symbol();
    var V8_VERSION = require_environment_v8_version();
    var IS_CONCAT_SPREADABLE = wellKnownSymbol("isConcatSpreadable");
    var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function() {
      var array = [];
      array[IS_CONCAT_SPREADABLE] = false;
      return array.concat()[0] !== array;
    });
    var isConcatSpreadable = function(O) {
      if (!isObject(O)) return false;
      var spreadable = O[IS_CONCAT_SPREADABLE];
      return spreadable !== void 0 ? !!spreadable : isArray(O);
    };
    var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !arrayMethodHasSpeciesSupport("concat");
    $({ target: "Array", proto: true, arity: 1, forced: FORCED }, {
      // eslint-disable-next-line no-unused-vars -- required for `.length`
      concat: function concat(arg) {
        var O = toObject(this);
        var A = arraySpeciesCreate(O, 0);
        var n = 0;
        var i, k, length, len, E;
        for (i = -1, length = arguments.length; i < length; i++) {
          E = i === -1 ? O : arguments[i];
          if (isConcatSpreadable(E)) {
            len = lengthOfArrayLike(E);
            doesNotExceedSafeInteger(n + len);
            for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
          } else {
            doesNotExceedSafeInteger(n + 1);
            createProperty(A, n++, E);
          }
        }
        A.length = n;
        return A;
      }
    });
  }
});

// node_modules/core-js/internals/call-with-safe-iteration-closing.js
var require_call_with_safe_iteration_closing = __commonJS({
  "node_modules/core-js/internals/call-with-safe-iteration-closing.js"(exports, module) {
    "use strict";
    var anObject = require_an_object();
    var iteratorClose = require_iterator_close();
    module.exports = function(iterator, fn, value, ENTRIES) {
      try {
        return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
      } catch (error) {
        iteratorClose(iterator, "throw", error);
      }
    };
  }
});

// node_modules/core-js/internals/array-from.js
var require_array_from = __commonJS({
  "node_modules/core-js/internals/array-from.js"(exports, module) {
    "use strict";
    var bind = require_function_bind_context();
    var call = require_function_call();
    var toObject = require_to_object();
    var callWithSafeIterationClosing = require_call_with_safe_iteration_closing();
    var isArrayIteratorMethod = require_is_array_iterator_method();
    var isConstructor = require_is_constructor();
    var lengthOfArrayLike = require_length_of_array_like();
    var createProperty = require_create_property();
    var getIterator = require_get_iterator();
    var getIteratorMethod = require_get_iterator_method();
    var $Array = Array;
    module.exports = function from(arrayLike) {
      var O = toObject(arrayLike);
      var IS_CONSTRUCTOR = isConstructor(this);
      var argumentsLength = arguments.length;
      var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
      var mapping = mapfn !== void 0;
      if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : void 0);
      var iteratorMethod = getIteratorMethod(O);
      var index = 0;
      var length, result, step, iterator, next, value;
      if (iteratorMethod && !(this === $Array && isArrayIteratorMethod(iteratorMethod))) {
        result = IS_CONSTRUCTOR ? new this() : [];
        iterator = getIterator(O, iteratorMethod);
        next = iterator.next;
        for (; !(step = call(next, iterator)).done; index++) {
          value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
          createProperty(result, index, value);
        }
      } else {
        length = lengthOfArrayLike(O);
        result = IS_CONSTRUCTOR ? new this(length) : $Array(length);
        for (; length > index; index++) {
          value = mapping ? mapfn(O[index], index) : O[index];
          createProperty(result, index, value);
        }
      }
      result.length = index;
      return result;
    };
  }
});

// node_modules/core-js/modules/es.array.from.js
var require_es_array_from = __commonJS({
  "node_modules/core-js/modules/es.array.from.js"() {
    "use strict";
    var $ = require_export();
    var from = require_array_from();
    var checkCorrectnessOfIteration = require_check_correctness_of_iteration();
    var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function(iterable) {
      Array.from(iterable);
    });
    $({ target: "Array", stat: true, forced: INCORRECT_ITERATION }, {
      from
    });
  }
});

// node_modules/core-js/internals/string-multibyte.js
var require_string_multibyte = __commonJS({
  "node_modules/core-js/internals/string-multibyte.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var toString = require_to_string();
    var requireObjectCoercible = require_require_object_coercible();
    var charAt = uncurryThis("".charAt);
    var charCodeAt = uncurryThis("".charCodeAt);
    var stringSlice = uncurryThis("".slice);
    var createMethod = function(CONVERT_TO_STRING) {
      return function($this, pos) {
        var S = toString(requireObjectCoercible($this));
        var position = toIntegerOrInfinity(pos);
        var size = S.length;
        var first, second;
        if (position < 0 || position >= size) return CONVERT_TO_STRING ? "" : void 0;
        first = charCodeAt(S, position);
        return first < 55296 || first > 56319 || position + 1 === size || (second = charCodeAt(S, position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? charAt(S, position) : first : CONVERT_TO_STRING ? stringSlice(S, position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
      };
    };
    module.exports = {
      // `String.prototype.codePointAt` method
      // https://tc39.es/ecma262/#sec-string.prototype.codepointat
      codeAt: createMethod(false),
      // `String.prototype.at` method
      // https://github.com/mathiasbynens/String.prototype.at
      charAt: createMethod(true)
    };
  }
});

// node_modules/core-js/internals/correct-prototype-getter.js
var require_correct_prototype_getter = __commonJS({
  "node_modules/core-js/internals/correct-prototype-getter.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    module.exports = !fails(function() {
      function F() {
      }
      F.prototype.constructor = null;
      return Object.getPrototypeOf(new F()) !== F.prototype;
    });
  }
});

// node_modules/core-js/internals/object-get-prototype-of.js
var require_object_get_prototype_of = __commonJS({
  "node_modules/core-js/internals/object-get-prototype-of.js"(exports, module) {
    "use strict";
    var hasOwn = require_has_own_property();
    var isCallable = require_is_callable();
    var toObject = require_to_object();
    var sharedKey = require_shared_key();
    var CORRECT_PROTOTYPE_GETTER = require_correct_prototype_getter();
    var IE_PROTO = sharedKey("IE_PROTO");
    var $Object = Object;
    var ObjectPrototype = $Object.prototype;
    module.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function(O) {
      var object = toObject(O);
      if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
      var constructor = object.constructor;
      if (isCallable(constructor) && object instanceof constructor) {
        return constructor.prototype;
      }
      return object instanceof $Object ? ObjectPrototype : null;
    };
  }
});

// node_modules/core-js/internals/iterators-core.js
var require_iterators_core = __commonJS({
  "node_modules/core-js/internals/iterators-core.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    var isCallable = require_is_callable();
    var isObject = require_is_object();
    var create = require_object_create();
    var getPrototypeOf = require_object_get_prototype_of();
    var defineBuiltIn = require_define_built_in();
    var wellKnownSymbol = require_well_known_symbol();
    var IS_PURE = require_is_pure();
    var ITERATOR = wellKnownSymbol("iterator");
    var BUGGY_SAFARI_ITERATORS = false;
    var IteratorPrototype;
    var PrototypeOfArrayIteratorPrototype;
    var arrayIterator;
    if ([].keys) {
      arrayIterator = [].keys();
      if (!("next" in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
      else {
        PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
        if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
      }
    }
    var NEW_ITERATOR_PROTOTYPE = !isObject(IteratorPrototype) || fails(function() {
      var test = {};
      return IteratorPrototype[ITERATOR].call(test) !== test;
    });
    if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};
    else if (IS_PURE) IteratorPrototype = create(IteratorPrototype);
    if (!isCallable(IteratorPrototype[ITERATOR])) {
      defineBuiltIn(IteratorPrototype, ITERATOR, function() {
        return this;
      });
    }
    module.exports = {
      IteratorPrototype,
      BUGGY_SAFARI_ITERATORS
    };
  }
});

// node_modules/core-js/internals/iterator-create-constructor.js
var require_iterator_create_constructor = __commonJS({
  "node_modules/core-js/internals/iterator-create-constructor.js"(exports, module) {
    "use strict";
    var IteratorPrototype = require_iterators_core().IteratorPrototype;
    var create = require_object_create();
    var createPropertyDescriptor = require_create_property_descriptor();
    var setToStringTag = require_set_to_string_tag();
    var Iterators = require_iterators();
    var returnThis = function() {
      return this;
    };
    module.exports = function(IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
      var TO_STRING_TAG = NAME + " Iterator";
      IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
      setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
      Iterators[TO_STRING_TAG] = returnThis;
      return IteratorConstructor;
    };
  }
});

// node_modules/core-js/internals/iterator-define.js
var require_iterator_define = __commonJS({
  "node_modules/core-js/internals/iterator-define.js"(exports, module) {
    "use strict";
    var $ = require_export();
    var call = require_function_call();
    var IS_PURE = require_is_pure();
    var FunctionName = require_function_name();
    var isCallable = require_is_callable();
    var createIteratorConstructor = require_iterator_create_constructor();
    var getPrototypeOf = require_object_get_prototype_of();
    var setPrototypeOf = require_object_set_prototype_of();
    var setToStringTag = require_set_to_string_tag();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var defineBuiltIn = require_define_built_in();
    var wellKnownSymbol = require_well_known_symbol();
    var Iterators = require_iterators();
    var IteratorsCore = require_iterators_core();
    var PROPER_FUNCTION_NAME = FunctionName.PROPER;
    var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
    var IteratorPrototype = IteratorsCore.IteratorPrototype;
    var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
    var ITERATOR = wellKnownSymbol("iterator");
    var KEYS = "keys";
    var VALUES = "values";
    var ENTRIES = "entries";
    var returnThis = function() {
      return this;
    };
    module.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
      createIteratorConstructor(IteratorConstructor, NAME, next);
      var getIterationMethod = function(KIND) {
        if (KIND === DEFAULT && defaultIterator) return defaultIterator;
        if (!BUGGY_SAFARI_ITERATORS && KIND && KIND in IterablePrototype) return IterablePrototype[KIND];
        switch (KIND) {
          case KEYS:
            return function keys() {
              return new IteratorConstructor(this, KIND);
            };
          case VALUES:
            return function values() {
              return new IteratorConstructor(this, KIND);
            };
          case ENTRIES:
            return function entries() {
              return new IteratorConstructor(this, KIND);
            };
        }
        return function() {
          return new IteratorConstructor(this);
        };
      };
      var TO_STRING_TAG = NAME + " Iterator";
      var INCORRECT_VALUES_NAME = false;
      var IterablePrototype = Iterable.prototype;
      var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
      var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
      var anyNativeIterator = NAME === "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
      var CurrentIteratorPrototype, methods, KEY;
      if (anyNativeIterator) {
        CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
        if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
          if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
            if (setPrototypeOf) {
              setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
            } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
              defineBuiltIn(CurrentIteratorPrototype, ITERATOR, returnThis);
            }
          }
          setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
          if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
        }
      }
      if (PROPER_FUNCTION_NAME && DEFAULT === VALUES && nativeIterator && nativeIterator.name !== VALUES) {
        if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
          createNonEnumerableProperty(IterablePrototype, "name", VALUES);
        } else {
          INCORRECT_VALUES_NAME = true;
          defaultIterator = function values() {
            return call(nativeIterator, this);
          };
        }
      }
      if (DEFAULT) {
        methods = {
          values: getIterationMethod(VALUES),
          keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
          entries: getIterationMethod(ENTRIES)
        };
        if (FORCED) for (KEY in methods) {
          if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
            defineBuiltIn(IterablePrototype, KEY, methods[KEY]);
          }
        }
        else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
      }
      if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
        defineBuiltIn(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
      }
      Iterators[NAME] = defaultIterator;
      return methods;
    };
  }
});

// node_modules/core-js/internals/create-iter-result-object.js
var require_create_iter_result_object = __commonJS({
  "node_modules/core-js/internals/create-iter-result-object.js"(exports, module) {
    "use strict";
    module.exports = function(value, done) {
      return { value, done };
    };
  }
});

// node_modules/core-js/modules/es.string.iterator.js
var require_es_string_iterator = __commonJS({
  "node_modules/core-js/modules/es.string.iterator.js"() {
    "use strict";
    var charAt = require_string_multibyte().charAt;
    var toString = require_to_string();
    var InternalStateModule = require_internal_state();
    var defineIterator = require_iterator_define();
    var createIterResultObject = require_create_iter_result_object();
    var STRING_ITERATOR = "String Iterator";
    var setInternalState = InternalStateModule.set;
    var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
    defineIterator(String, "String", function(iterated) {
      setInternalState(this, {
        type: STRING_ITERATOR,
        string: toString(iterated),
        index: 0
      });
    }, function next() {
      var state = getInternalState(this);
      var string = state.string;
      var index = state.index;
      var point;
      if (index >= string.length) return createIterResultObject(void 0, true);
      point = charAt(string, index);
      state.index += point.length;
      return createIterResultObject(point, false);
    });
  }
});

// node_modules/loglevel/lib/loglevel.js
var require_loglevel = __commonJS({
  "node_modules/loglevel/lib/loglevel.js"(exports, module) {
    (function(root, definition) {
      "use strict";
      if (typeof define === "function" && define.amd) {
        define(definition);
      } else if (typeof module === "object" && module.exports) {
        module.exports = definition();
      } else {
        root.log = definition();
      }
    })(exports, function() {
      "use strict";
      var noop = function() {
      };
      var undefinedType = "undefined";
      var isIE = typeof window !== undefinedType && typeof window.navigator !== undefinedType && /Trident\/|MSIE /.test(window.navigator.userAgent);
      var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
      ];
      var _loggersByName = {};
      var defaultLogger = null;
      function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === "function") {
          return method.bind(obj);
        } else {
          try {
            return Function.prototype.bind.call(method, obj);
          } catch (e) {
            return function() {
              return Function.prototype.apply.apply(method, [obj, arguments]);
            };
          }
        }
      }
      function traceForIE() {
        if (console.log) {
          if (console.log.apply) {
            console.log.apply(console, arguments);
          } else {
            Function.prototype.apply.apply(console.log, [console, arguments]);
          }
        }
        if (console.trace) console.trace();
      }
      function realMethod(methodName) {
        if (methodName === "debug") {
          methodName = "log";
        }
        if (typeof console === undefinedType) {
          return false;
        } else if (methodName === "trace" && isIE) {
          return traceForIE;
        } else if (console[methodName] !== void 0) {
          return bindMethod(console, methodName);
        } else if (console.log !== void 0) {
          return bindMethod(console, "log");
        } else {
          return noop;
        }
      }
      function replaceLoggingMethods() {
        var level = this.getLevel();
        for (var i = 0; i < logMethods.length; i++) {
          var methodName = logMethods[i];
          this[methodName] = i < level ? noop : this.methodFactory(methodName, level, this.name);
        }
        this.log = this.debug;
        if (typeof console === undefinedType && level < this.levels.SILENT) {
          return "No console available for logging";
        }
      }
      function enableLoggingWhenConsoleArrives(methodName) {
        return function() {
          if (typeof console !== undefinedType) {
            replaceLoggingMethods.call(this);
            this[methodName].apply(this, arguments);
          }
        };
      }
      function defaultMethodFactory(methodName, _level, _loggerName) {
        return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);
      }
      function Logger(name, factory) {
        var self2 = this;
        var inheritedLevel;
        var defaultLevel;
        var userLevel;
        var storageKey = "loglevel";
        if (typeof name === "string") {
          storageKey += ":" + name;
        } else if (typeof name === "symbol") {
          storageKey = void 0;
        }
        function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || "silent").toUpperCase();
          if (typeof window === undefinedType || !storageKey) return;
          try {
            window.localStorage[storageKey] = levelName;
            return;
          } catch (ignore) {
          }
          try {
            window.document.cookie = encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {
          }
        }
        function getPersistedLevel() {
          var storedLevel;
          if (typeof window === undefinedType || !storageKey) return;
          try {
            storedLevel = window.localStorage[storageKey];
          } catch (ignore) {
          }
          if (typeof storedLevel === undefinedType) {
            try {
              var cookie = window.document.cookie;
              var cookieName = encodeURIComponent(storageKey);
              var location = cookie.indexOf(cookieName + "=");
              if (location !== -1) {
                storedLevel = /^([^;]+)/.exec(
                  cookie.slice(location + cookieName.length + 1)
                )[1];
              }
            } catch (ignore) {
            }
          }
          if (self2.levels[storedLevel] === void 0) {
            storedLevel = void 0;
          }
          return storedLevel;
        }
        function clearPersistedLevel() {
          if (typeof window === undefinedType || !storageKey) return;
          try {
            window.localStorage.removeItem(storageKey);
          } catch (ignore) {
          }
          try {
            window.document.cookie = encodeURIComponent(storageKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
          } catch (ignore) {
          }
        }
        function normalizeLevel(input) {
          var level = input;
          if (typeof level === "string" && self2.levels[level.toUpperCase()] !== void 0) {
            level = self2.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self2.levels.SILENT) {
            return level;
          } else {
            throw new TypeError("log.setLevel() called with invalid level: " + input);
          }
        }
        self2.name = name;
        self2.levels = {
          "TRACE": 0,
          "DEBUG": 1,
          "INFO": 2,
          "WARN": 3,
          "ERROR": 4,
          "SILENT": 5
        };
        self2.methodFactory = factory || defaultMethodFactory;
        self2.getLevel = function() {
          if (userLevel != null) {
            return userLevel;
          } else if (defaultLevel != null) {
            return defaultLevel;
          } else {
            return inheritedLevel;
          }
        };
        self2.setLevel = function(level, persist) {
          userLevel = normalizeLevel(level);
          if (persist !== false) {
            persistLevelIfPossible(userLevel);
          }
          return replaceLoggingMethods.call(self2);
        };
        self2.setDefaultLevel = function(level) {
          defaultLevel = normalizeLevel(level);
          if (!getPersistedLevel()) {
            self2.setLevel(level, false);
          }
        };
        self2.resetLevel = function() {
          userLevel = null;
          clearPersistedLevel();
          replaceLoggingMethods.call(self2);
        };
        self2.enableAll = function(persist) {
          self2.setLevel(self2.levels.TRACE, persist);
        };
        self2.disableAll = function(persist) {
          self2.setLevel(self2.levels.SILENT, persist);
        };
        self2.rebuild = function() {
          if (defaultLogger !== self2) {
            inheritedLevel = normalizeLevel(defaultLogger.getLevel());
          }
          replaceLoggingMethods.call(self2);
          if (defaultLogger === self2) {
            for (var childName in _loggersByName) {
              _loggersByName[childName].rebuild();
            }
          }
        };
        inheritedLevel = normalizeLevel(
          defaultLogger ? defaultLogger.getLevel() : "WARN"
        );
        var initialLevel = getPersistedLevel();
        if (initialLevel != null) {
          userLevel = normalizeLevel(initialLevel);
        }
        replaceLoggingMethods.call(self2);
      }
      defaultLogger = new Logger();
      defaultLogger.getLogger = function getLogger(name) {
        if (typeof name !== "symbol" && typeof name !== "string" || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }
        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name,
            defaultLogger.methodFactory
          );
        }
        return logger;
      };
      var _log = typeof window !== undefinedType ? window.log : void 0;
      defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType && window.log === defaultLogger) {
          window.log = _log;
        }
        return defaultLogger;
      };
      defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
      };
      defaultLogger["default"] = defaultLogger;
      return defaultLogger;
    });
  }
});

// node_modules/iso8601-duration/src/index.js
var src_exports = {};
__export(src_exports, {
  default: () => src_default,
  end: () => end,
  parse: () => parse,
  pattern: () => pattern,
  toSeconds: () => toSeconds
});
var numbers, weekPattern, datePattern, timePattern, iso8601, objMap, pattern, parse, end, toSeconds, src_default;
var init_src = __esm({
  "node_modules/iso8601-duration/src/index.js"() {
    numbers = "\\d+(?:[\\.,]\\d+)?";
    weekPattern = `(${numbers}W)`;
    datePattern = `(${numbers}Y)?(${numbers}M)?(${numbers}D)?`;
    timePattern = `T(${numbers}H)?(${numbers}M)?(${numbers}S)?`;
    iso8601 = `P(?:${weekPattern}|${datePattern}(?:${timePattern})?)`;
    objMap = ["weeks", "years", "months", "days", "hours", "minutes", "seconds"];
    pattern = new RegExp(iso8601);
    parse = (durationString) => {
      return durationString.match(pattern).slice(1).reduce((prev, next, idx) => {
        prev[objMap[idx]] = parseFloat(next) || 0;
        return prev;
      }, {});
    };
    end = (duration, startDate) => {
      const timestamp = startDate ? startDate.getTime() : Date.now();
      const then = new Date(timestamp);
      then.setFullYear(then.getFullYear() + duration.years);
      then.setMonth(then.getMonth() + duration.months);
      then.setDate(then.getDate() + duration.days);
      then.setHours(then.getHours() + duration.hours);
      then.setMinutes(then.getMinutes() + duration.minutes);
      then.setMilliseconds(then.getMilliseconds() + duration.seconds * 1e3);
      then.setDate(then.getDate() + duration.weeks * 7);
      return then;
    };
    toSeconds = (duration, startDate) => {
      const timestamp = startDate ? startDate.getTime() : Date.now();
      const now = new Date(timestamp);
      const then = end(duration, now);
      const seconds = (then.getTime() - now.getTime()) / 1e3;
      return seconds;
    };
    src_default = {
      end,
      toSeconds,
      pattern,
      parse
    };
  }
});

// node_modules/core-js/internals/add-to-unscopables.js
var require_add_to_unscopables = __commonJS({
  "node_modules/core-js/internals/add-to-unscopables.js"(exports, module) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    var create = require_object_create();
    var defineProperty = require_object_define_property().f;
    var UNSCOPABLES = wellKnownSymbol("unscopables");
    var ArrayPrototype = Array.prototype;
    if (ArrayPrototype[UNSCOPABLES] === void 0) {
      defineProperty(ArrayPrototype, UNSCOPABLES, {
        configurable: true,
        value: create(null)
      });
    }
    module.exports = function(key) {
      ArrayPrototype[UNSCOPABLES][key] = true;
    };
  }
});

// node_modules/core-js/modules/es.array.iterator.js
var require_es_array_iterator = __commonJS({
  "node_modules/core-js/modules/es.array.iterator.js"(exports, module) {
    "use strict";
    var toIndexedObject = require_to_indexed_object();
    var addToUnscopables = require_add_to_unscopables();
    var Iterators = require_iterators();
    var InternalStateModule = require_internal_state();
    var defineProperty = require_object_define_property().f;
    var defineIterator = require_iterator_define();
    var createIterResultObject = require_create_iter_result_object();
    var IS_PURE = require_is_pure();
    var DESCRIPTORS = require_descriptors();
    var ARRAY_ITERATOR = "Array Iterator";
    var setInternalState = InternalStateModule.set;
    var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
    module.exports = defineIterator(Array, "Array", function(iterated, kind) {
      setInternalState(this, {
        type: ARRAY_ITERATOR,
        target: toIndexedObject(iterated),
        // target
        index: 0,
        // next index
        kind
        // kind
      });
    }, function() {
      var state = getInternalState(this);
      var target = state.target;
      var index = state.index++;
      if (!target || index >= target.length) {
        state.target = null;
        return createIterResultObject(void 0, true);
      }
      switch (state.kind) {
        case "keys":
          return createIterResultObject(index, false);
        case "values":
          return createIterResultObject(target[index], false);
      }
      return createIterResultObject([index, target[index]], false);
    }, "values");
    var values = Iterators.Arguments = Iterators.Array;
    addToUnscopables("keys");
    addToUnscopables("values");
    addToUnscopables("entries");
    if (!IS_PURE && DESCRIPTORS && values.name !== "values") try {
      defineProperty(values, "name", { value: "values" });
    } catch (error) {
    }
  }
});

// node_modules/core-js/modules/web.dom-collections.iterator.js
var require_web_dom_collections_iterator = __commonJS({
  "node_modules/core-js/modules/web.dom-collections.iterator.js"() {
    "use strict";
    var globalThis2 = require_global_this();
    var DOMIterables = require_dom_iterables();
    var DOMTokenListPrototype = require_dom_token_list_prototype();
    var ArrayIteratorMethods = require_es_array_iterator();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var setToStringTag = require_set_to_string_tag();
    var wellKnownSymbol = require_well_known_symbol();
    var ITERATOR = wellKnownSymbol("iterator");
    var ArrayValues = ArrayIteratorMethods.values;
    var handlePrototype = function(CollectionPrototype, COLLECTION_NAME2) {
      if (CollectionPrototype) {
        if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
          createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
        } catch (error) {
          CollectionPrototype[ITERATOR] = ArrayValues;
        }
        setToStringTag(CollectionPrototype, COLLECTION_NAME2, true);
        if (DOMIterables[COLLECTION_NAME2]) for (var METHOD_NAME in ArrayIteratorMethods) {
          if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
            createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
          } catch (error) {
            CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
          }
        }
      }
    };
    for (COLLECTION_NAME in DOMIterables) {
      handlePrototype(globalThis2[COLLECTION_NAME] && globalThis2[COLLECTION_NAME].prototype, COLLECTION_NAME);
    }
    var COLLECTION_NAME;
    handlePrototype(DOMTokenListPrototype, "DOMTokenList");
  }
});

// node_modules/core-js/internals/inherit-if-required.js
var require_inherit_if_required = __commonJS({
  "node_modules/core-js/internals/inherit-if-required.js"(exports, module) {
    "use strict";
    var isCallable = require_is_callable();
    var isObject = require_is_object();
    var setPrototypeOf = require_object_set_prototype_of();
    module.exports = function($this, dummy, Wrapper) {
      var NewTarget, NewTargetPrototype;
      if (
        // it can work only with native `setPrototypeOf`
        setPrototypeOf && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
        isCallable(NewTarget = dummy.constructor) && NewTarget !== Wrapper && isObject(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype
      ) setPrototypeOf($this, NewTargetPrototype);
      return $this;
    };
  }
});

// node_modules/core-js/internals/this-number-value.js
var require_this_number_value = __commonJS({
  "node_modules/core-js/internals/this-number-value.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    module.exports = uncurryThis(1.1.valueOf);
  }
});

// node_modules/core-js/internals/whitespaces.js
var require_whitespaces = __commonJS({
  "node_modules/core-js/internals/whitespaces.js"(exports, module) {
    "use strict";
    module.exports = "	\n\v\f\r Â áââââââââââââ¯âã\u2028\u2029\uFEFF";
  }
});

// node_modules/core-js/internals/string-trim.js
var require_string_trim = __commonJS({
  "node_modules/core-js/internals/string-trim.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var requireObjectCoercible = require_require_object_coercible();
    var toString = require_to_string();
    var whitespaces = require_whitespaces();
    var replace = uncurryThis("".replace);
    var ltrim = RegExp("^[" + whitespaces + "]+");
    var rtrim = RegExp("(^|[^" + whitespaces + "])[" + whitespaces + "]+$");
    var createMethod = function(TYPE) {
      return function($this) {
        var string = toString(requireObjectCoercible($this));
        if (TYPE & 1) string = replace(string, ltrim, "");
        if (TYPE & 2) string = replace(string, rtrim, "$1");
        return string;
      };
    };
    module.exports = {
      // `String.prototype.{ trimLeft, trimStart }` methods
      // https://tc39.es/ecma262/#sec-string.prototype.trimstart
      start: createMethod(1),
      // `String.prototype.{ trimRight, trimEnd }` methods
      // https://tc39.es/ecma262/#sec-string.prototype.trimend
      end: createMethod(2),
      // `String.prototype.trim` method
      // https://tc39.es/ecma262/#sec-string.prototype.trim
      trim: createMethod(3)
    };
  }
});

// node_modules/core-js/modules/es.number.constructor.js
var require_es_number_constructor = __commonJS({
  "node_modules/core-js/modules/es.number.constructor.js"() {
    "use strict";
    var $ = require_export();
    var IS_PURE = require_is_pure();
    var DESCRIPTORS = require_descriptors();
    var globalThis2 = require_global_this();
    var path = require_path();
    var uncurryThis = require_function_uncurry_this();
    var isForced = require_is_forced();
    var hasOwn = require_has_own_property();
    var inheritIfRequired = require_inherit_if_required();
    var isPrototypeOf = require_object_is_prototype_of();
    var isSymbol = require_is_symbol();
    var toPrimitive = require_to_primitive();
    var fails = require_fails();
    var getOwnPropertyNames = require_object_get_own_property_names().f;
    var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
    var defineProperty = require_object_define_property().f;
    var thisNumberValue = require_this_number_value();
    var trim = require_string_trim().trim;
    var NUMBER = "Number";
    var NativeNumber = globalThis2[NUMBER];
    var PureNumberNamespace = path[NUMBER];
    var NumberPrototype = NativeNumber.prototype;
    var TypeError2 = globalThis2.TypeError;
    var stringSlice = uncurryThis("".slice);
    var charCodeAt = uncurryThis("".charCodeAt);
    var toNumeric = function(value) {
      var primValue = toPrimitive(value, "number");
      return typeof primValue == "bigint" ? primValue : toNumber(primValue);
    };
    var toNumber = function(argument) {
      var it = toPrimitive(argument, "number");
      var first, third, radix, maxCode, digits, length, index, code;
      if (isSymbol(it)) throw new TypeError2("Cannot convert a Symbol value to a number");
      if (typeof it == "string" && it.length > 2) {
        it = trim(it);
        first = charCodeAt(it, 0);
        if (first === 43 || first === 45) {
          third = charCodeAt(it, 2);
          if (third === 88 || third === 120) return NaN;
        } else if (first === 48) {
          switch (charCodeAt(it, 1)) {
            case 66:
            case 98:
              radix = 2;
              maxCode = 49;
              break;
            case 79:
            case 111:
              radix = 8;
              maxCode = 55;
              break;
            default:
              return +it;
          }
          digits = stringSlice(it, 2);
          length = digits.length;
          for (index = 0; index < length; index++) {
            code = charCodeAt(digits, index);
            if (code < 48 || code > maxCode) return NaN;
          }
          return parseInt(digits, radix);
        }
      }
      return +it;
    };
    var FORCED = isForced(NUMBER, !NativeNumber(" 0o1") || !NativeNumber("0b1") || NativeNumber("+0x1"));
    var calledWithNew = function(dummy) {
      return isPrototypeOf(NumberPrototype, dummy) && fails(function() {
        thisNumberValue(dummy);
      });
    };
    var NumberWrapper = function Number2(value) {
      var n = arguments.length < 1 ? 0 : NativeNumber(toNumeric(value));
      return calledWithNew(this) ? inheritIfRequired(Object(n), this, NumberWrapper) : n;
    };
    NumberWrapper.prototype = NumberPrototype;
    if (FORCED && !IS_PURE) NumberPrototype.constructor = NumberWrapper;
    $({ global: true, constructor: true, wrap: true, forced: FORCED }, {
      Number: NumberWrapper
    });
    var copyConstructorProperties = function(target, source) {
      for (var keys = DESCRIPTORS ? getOwnPropertyNames(source) : (
        // ES3:
        "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,fromString,range".split(",")
      ), j = 0, key; keys.length > j; j++) {
        if (hasOwn(source, key = keys[j]) && !hasOwn(target, key)) {
          defineProperty(target, key, getOwnPropertyDescriptor(source, key));
        }
      }
    };
    if (IS_PURE && PureNumberNamespace) copyConstructorProperties(path[NUMBER], PureNumberNamespace);
    if (FORCED || IS_PURE) copyConstructorProperties(path[NUMBER], NativeNumber);
  }
});

// node_modules/core-js/internals/regexp-flags.js
var require_regexp_flags = __commonJS({
  "node_modules/core-js/internals/regexp-flags.js"(exports, module) {
    "use strict";
    var anObject = require_an_object();
    module.exports = function() {
      var that = anObject(this);
      var result = "";
      if (that.hasIndices) result += "d";
      if (that.global) result += "g";
      if (that.ignoreCase) result += "i";
      if (that.multiline) result += "m";
      if (that.dotAll) result += "s";
      if (that.unicode) result += "u";
      if (that.unicodeSets) result += "v";
      if (that.sticky) result += "y";
      return result;
    };
  }
});

// node_modules/core-js/internals/regexp-sticky-helpers.js
var require_regexp_sticky_helpers = __commonJS({
  "node_modules/core-js/internals/regexp-sticky-helpers.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    var globalThis2 = require_global_this();
    var $RegExp = globalThis2.RegExp;
    var UNSUPPORTED_Y = fails(function() {
      var re = $RegExp("a", "y");
      re.lastIndex = 2;
      return re.exec("abcd") !== null;
    });
    var MISSED_STICKY = UNSUPPORTED_Y || fails(function() {
      return !$RegExp("a", "y").sticky;
    });
    var BROKEN_CARET = UNSUPPORTED_Y || fails(function() {
      var re = $RegExp("^r", "gy");
      re.lastIndex = 2;
      return re.exec("str") !== null;
    });
    module.exports = {
      BROKEN_CARET,
      MISSED_STICKY,
      UNSUPPORTED_Y
    };
  }
});

// node_modules/core-js/internals/regexp-unsupported-dot-all.js
var require_regexp_unsupported_dot_all = __commonJS({
  "node_modules/core-js/internals/regexp-unsupported-dot-all.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    var globalThis2 = require_global_this();
    var $RegExp = globalThis2.RegExp;
    module.exports = fails(function() {
      var re = $RegExp(".", "s");
      return !(re.dotAll && re.test("\n") && re.flags === "s");
    });
  }
});

// node_modules/core-js/internals/regexp-unsupported-ncg.js
var require_regexp_unsupported_ncg = __commonJS({
  "node_modules/core-js/internals/regexp-unsupported-ncg.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    var globalThis2 = require_global_this();
    var $RegExp = globalThis2.RegExp;
    module.exports = fails(function() {
      var re = $RegExp("(?<a>b)", "g");
      return re.exec("b").groups.a !== "b" || "b".replace(re, "$<a>c") !== "bc";
    });
  }
});

// node_modules/core-js/internals/regexp-exec.js
var require_regexp_exec = __commonJS({
  "node_modules/core-js/internals/regexp-exec.js"(exports, module) {
    "use strict";
    var call = require_function_call();
    var uncurryThis = require_function_uncurry_this();
    var toString = require_to_string();
    var regexpFlags = require_regexp_flags();
    var stickyHelpers = require_regexp_sticky_helpers();
    var shared = require_shared();
    var create = require_object_create();
    var getInternalState = require_internal_state().get;
    var UNSUPPORTED_DOT_ALL = require_regexp_unsupported_dot_all();
    var UNSUPPORTED_NCG = require_regexp_unsupported_ncg();
    var nativeReplace = shared("native-string-replace", String.prototype.replace);
    var nativeExec = RegExp.prototype.exec;
    var patchedExec = nativeExec;
    var charAt = uncurryThis("".charAt);
    var indexOf = uncurryThis("".indexOf);
    var replace = uncurryThis("".replace);
    var stringSlice = uncurryThis("".slice);
    var UPDATES_LAST_INDEX_WRONG = function() {
      var re1 = /a/;
      var re2 = /b*/g;
      call(nativeExec, re1, "a");
      call(nativeExec, re2, "a");
      return re1.lastIndex !== 0 || re2.lastIndex !== 0;
    }();
    var UNSUPPORTED_Y = stickyHelpers.BROKEN_CARET;
    var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
    var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;
    if (PATCH) {
      patchedExec = function exec(string) {
        var re = this;
        var state = getInternalState(re);
        var str = toString(string);
        var raw = state.raw;
        var result, reCopy, lastIndex, match, i, object, group;
        if (raw) {
          raw.lastIndex = re.lastIndex;
          result = call(patchedExec, raw, str);
          re.lastIndex = raw.lastIndex;
          return result;
        }
        var groups = state.groups;
        var sticky = UNSUPPORTED_Y && re.sticky;
        var flags = call(regexpFlags, re);
        var source = re.source;
        var charsAdded = 0;
        var strCopy = str;
        if (sticky) {
          flags = replace(flags, "y", "");
          if (indexOf(flags, "g") === -1) {
            flags += "g";
          }
          strCopy = stringSlice(str, re.lastIndex);
          if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt(str, re.lastIndex - 1) !== "\n")) {
            source = "(?: " + source + ")";
            strCopy = " " + strCopy;
            charsAdded++;
          }
          reCopy = new RegExp("^(?:" + source + ")", flags);
        }
        if (NPCG_INCLUDED) {
          reCopy = new RegExp("^" + source + "$(?!\\s)", flags);
        }
        if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;
        match = call(nativeExec, sticky ? reCopy : re, strCopy);
        if (sticky) {
          if (match) {
            match.input = stringSlice(match.input, charsAdded);
            match[0] = stringSlice(match[0], charsAdded);
            match.index = re.lastIndex;
            re.lastIndex += match[0].length;
          } else re.lastIndex = 0;
        } else if (UPDATES_LAST_INDEX_WRONG && match) {
          re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
        }
        if (NPCG_INCLUDED && match && match.length > 1) {
          call(nativeReplace, match[0], reCopy, function() {
            for (i = 1; i < arguments.length - 2; i++) {
              if (arguments[i] === void 0) match[i] = void 0;
            }
          });
        }
        if (match && groups) {
          match.groups = object = create(null);
          for (i = 0; i < groups.length; i++) {
            group = groups[i];
            object[group[0]] = match[group[1]];
          }
        }
        return match;
      };
    }
    module.exports = patchedExec;
  }
});

// node_modules/core-js/modules/es.regexp.exec.js
var require_es_regexp_exec = __commonJS({
  "node_modules/core-js/modules/es.regexp.exec.js"() {
    "use strict";
    var $ = require_export();
    var exec = require_regexp_exec();
    $({ target: "RegExp", proto: true, forced: /./.exec !== exec }, {
      exec
    });
  }
});

// node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js
var require_fix_regexp_well_known_symbol_logic = __commonJS({
  "node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js"(exports, module) {
    "use strict";
    require_es_regexp_exec();
    var call = require_function_call();
    var defineBuiltIn = require_define_built_in();
    var regexpExec = require_regexp_exec();
    var fails = require_fails();
    var wellKnownSymbol = require_well_known_symbol();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var SPECIES = wellKnownSymbol("species");
    var RegExpPrototype = RegExp.prototype;
    module.exports = function(KEY, exec, FORCED, SHAM) {
      var SYMBOL = wellKnownSymbol(KEY);
      var DELEGATES_TO_SYMBOL = !fails(function() {
        var O = {};
        O[SYMBOL] = function() {
          return 7;
        };
        return ""[KEY](O) !== 7;
      });
      var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function() {
        var execCalled = false;
        var re = /a/;
        if (KEY === "split") {
          re = {};
          re.constructor = {};
          re.constructor[SPECIES] = function() {
            return re;
          };
          re.flags = "";
          re[SYMBOL] = /./[SYMBOL];
        }
        re.exec = function() {
          execCalled = true;
          return null;
        };
        re[SYMBOL]("");
        return !execCalled;
      });
      if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || FORCED) {
        var nativeRegExpMethod = /./[SYMBOL];
        var methods = exec(SYMBOL, ""[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
          var $exec = regexp.exec;
          if ($exec === regexpExec || $exec === RegExpPrototype.exec) {
            if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
              return { done: true, value: call(nativeRegExpMethod, regexp, str, arg2) };
            }
            return { done: true, value: call(nativeMethod, str, regexp, arg2) };
          }
          return { done: false };
        });
        defineBuiltIn(String.prototype, KEY, methods[0]);
        defineBuiltIn(RegExpPrototype, SYMBOL, methods[1]);
      }
      if (SHAM) createNonEnumerableProperty(RegExpPrototype[SYMBOL], "sham", true);
    };
  }
});

// node_modules/core-js/internals/advance-string-index.js
var require_advance_string_index = __commonJS({
  "node_modules/core-js/internals/advance-string-index.js"(exports, module) {
    "use strict";
    var charAt = require_string_multibyte().charAt;
    module.exports = function(S, index, unicode) {
      return index + (unicode ? charAt(S, index).length : 1);
    };
  }
});

// node_modules/core-js/internals/get-substitution.js
var require_get_substitution = __commonJS({
  "node_modules/core-js/internals/get-substitution.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var toObject = require_to_object();
    var floor = Math.floor;
    var charAt = uncurryThis("".charAt);
    var replace = uncurryThis("".replace);
    var stringSlice = uncurryThis("".slice);
    var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
    var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;
    module.exports = function(matched, str, position, captures, namedCaptures, replacement) {
      var tailPos = position + matched.length;
      var m = captures.length;
      var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
      if (namedCaptures !== void 0) {
        namedCaptures = toObject(namedCaptures);
        symbols = SUBSTITUTION_SYMBOLS;
      }
      return replace(replacement, symbols, function(match, ch) {
        var capture;
        switch (charAt(ch, 0)) {
          case "$":
            return "$";
          case "&":
            return matched;
          case "`":
            return stringSlice(str, 0, position);
          case "'":
            return stringSlice(str, tailPos);
          case "<":
            capture = namedCaptures[stringSlice(ch, 1, -1)];
            break;
          default:
            var n = +ch;
            if (n === 0) return match;
            if (n > m) {
              var f = floor(n / 10);
              if (f === 0) return match;
              if (f <= m) return captures[f - 1] === void 0 ? charAt(ch, 1) : captures[f - 1] + charAt(ch, 1);
              return match;
            }
            capture = captures[n - 1];
        }
        return capture === void 0 ? "" : capture;
      });
    };
  }
});

// node_modules/core-js/internals/regexp-flags-detection.js
var require_regexp_flags_detection = __commonJS({
  "node_modules/core-js/internals/regexp-flags-detection.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var fails = require_fails();
    var RegExp2 = globalThis2.RegExp;
    var FLAGS_GETTER_IS_CORRECT = !fails(function() {
      var INDICES_SUPPORT = true;
      try {
        RegExp2(".", "d");
      } catch (error) {
        INDICES_SUPPORT = false;
      }
      var O = {};
      var calls = "";
      var expected = INDICES_SUPPORT ? "dgimsy" : "gimsy";
      var addGetter = function(key2, chr) {
        Object.defineProperty(O, key2, { get: function() {
          calls += chr;
          return true;
        } });
      };
      var pairs = {
        dotAll: "s",
        global: "g",
        ignoreCase: "i",
        multiline: "m",
        sticky: "y"
      };
      if (INDICES_SUPPORT) pairs.hasIndices = "d";
      for (var key in pairs) addGetter(key, pairs[key]);
      var result = Object.getOwnPropertyDescriptor(RegExp2.prototype, "flags").get.call(O);
      return result !== expected || calls !== expected;
    });
    module.exports = { correct: FLAGS_GETTER_IS_CORRECT };
  }
});

// node_modules/core-js/internals/regexp-get-flags.js
var require_regexp_get_flags = __commonJS({
  "node_modules/core-js/internals/regexp-get-flags.js"(exports, module) {
    "use strict";
    var call = require_function_call();
    var hasOwn = require_has_own_property();
    var isPrototypeOf = require_object_is_prototype_of();
    var regExpFlagsDetection = require_regexp_flags_detection();
    var regExpFlagsGetterImplementation = require_regexp_flags();
    var RegExpPrototype = RegExp.prototype;
    module.exports = regExpFlagsDetection.correct ? function(it) {
      return it.flags;
    } : function(it) {
      return !regExpFlagsDetection.correct && isPrototypeOf(RegExpPrototype, it) && !hasOwn(it, "flags") ? call(regExpFlagsGetterImplementation, it) : it.flags;
    };
  }
});

// node_modules/core-js/internals/regexp-exec-abstract.js
var require_regexp_exec_abstract = __commonJS({
  "node_modules/core-js/internals/regexp-exec-abstract.js"(exports, module) {
    "use strict";
    var call = require_function_call();
    var anObject = require_an_object();
    var isCallable = require_is_callable();
    var classof = require_classof_raw();
    var regexpExec = require_regexp_exec();
    var $TypeError = TypeError;
    module.exports = function(R, S) {
      var exec = R.exec;
      if (isCallable(exec)) {
        var result = call(exec, R, S);
        if (result !== null) anObject(result);
        return result;
      }
      if (classof(R) === "RegExp") return call(regexpExec, R, S);
      throw new $TypeError("RegExp#exec called on incompatible receiver");
    };
  }
});

// node_modules/core-js/modules/es.string.replace.js
var require_es_string_replace = __commonJS({
  "node_modules/core-js/modules/es.string.replace.js"() {
    "use strict";
    var apply = require_function_apply();
    var call = require_function_call();
    var uncurryThis = require_function_uncurry_this();
    var fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
    var fails = require_fails();
    var anObject = require_an_object();
    var isCallable = require_is_callable();
    var isObject = require_is_object();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var toLength = require_to_length();
    var toString = require_to_string();
    var requireObjectCoercible = require_require_object_coercible();
    var advanceStringIndex = require_advance_string_index();
    var getMethod = require_get_method();
    var getSubstitution = require_get_substitution();
    var getRegExpFlags = require_regexp_get_flags();
    var regExpExec = require_regexp_exec_abstract();
    var wellKnownSymbol = require_well_known_symbol();
    var REPLACE = wellKnownSymbol("replace");
    var max = Math.max;
    var min = Math.min;
    var concat = uncurryThis([].concat);
    var push = uncurryThis([].push);
    var stringIndexOf = uncurryThis("".indexOf);
    var stringSlice = uncurryThis("".slice);
    var maybeToString = function(it) {
      return it === void 0 ? it : String(it);
    };
    var REPLACE_KEEPS_$0 = function() {
      return "a".replace(/./, "$0") === "$0";
    }();
    var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function() {
      if (/./[REPLACE]) {
        return /./[REPLACE]("a", "$0") === "";
      }
      return false;
    }();
    var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function() {
      var re = /./;
      re.exec = function() {
        var result = [];
        result.groups = { a: "7" };
        return result;
      };
      return "".replace(re, "$<a>") !== "7";
    });
    fixRegExpWellKnownSymbolLogic("replace", function(_, nativeReplace, maybeCallNative) {
      var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? "$" : "$0";
      return [
        // `String.prototype.replace` method
        // https://tc39.es/ecma262/#sec-string.prototype.replace
        function replace(searchValue, replaceValue) {
          var O = requireObjectCoercible(this);
          var replacer = isObject(searchValue) ? getMethod(searchValue, REPLACE) : void 0;
          return replacer ? call(replacer, searchValue, O, replaceValue) : call(nativeReplace, toString(O), searchValue, replaceValue);
        },
        // `RegExp.prototype[@@replace]` method
        // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
        function(string, replaceValue) {
          var rx = anObject(this);
          var S = toString(string);
          if (typeof replaceValue == "string" && stringIndexOf(replaceValue, UNSAFE_SUBSTITUTE) === -1 && stringIndexOf(replaceValue, "$<") === -1) {
            var res = maybeCallNative(nativeReplace, rx, S, replaceValue);
            if (res.done) return res.value;
          }
          var functionalReplace = isCallable(replaceValue);
          if (!functionalReplace) replaceValue = toString(replaceValue);
          var flags = toString(getRegExpFlags(rx));
          var global2 = stringIndexOf(flags, "g") !== -1;
          var fullUnicode;
          if (global2) {
            fullUnicode = stringIndexOf(flags, "u") !== -1;
            rx.lastIndex = 0;
          }
          var results = [];
          var result;
          while (true) {
            result = regExpExec(rx, S);
            if (result === null) break;
            push(results, result);
            if (!global2) break;
            var matchStr = toString(result[0]);
            if (matchStr === "") rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
          }
          var accumulatedResult = "";
          var nextSourcePosition = 0;
          for (var i = 0; i < results.length; i++) {
            result = results[i];
            var matched = toString(result[0]);
            var position = max(min(toIntegerOrInfinity(result.index), S.length), 0);
            var captures = [];
            var replacement;
            for (var j = 1; j < result.length; j++) push(captures, maybeToString(result[j]));
            var namedCaptures = result.groups;
            if (functionalReplace) {
              var replacerArgs = concat([matched], captures, position, S);
              if (namedCaptures !== void 0) push(replacerArgs, namedCaptures);
              replacement = toString(apply(replaceValue, void 0, replacerArgs));
            } else {
              replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
            }
            if (position >= nextSourcePosition) {
              accumulatedResult += stringSlice(S, nextSourcePosition, position) + replacement;
              nextSourcePosition = position + matched.length;
            }
          }
          return accumulatedResult + stringSlice(S, nextSourcePosition);
        }
      ];
    }, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);
  }
});

// node_modules/core-js/modules/es.array.join.js
var require_es_array_join = __commonJS({
  "node_modules/core-js/modules/es.array.join.js"() {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this();
    var IndexedObject = require_indexed_object();
    var toIndexedObject = require_to_indexed_object();
    var arrayMethodIsStrict = require_array_method_is_strict();
    var nativeJoin = uncurryThis([].join);
    var ES3_STRINGS = IndexedObject !== Object;
    var FORCED = ES3_STRINGS || !arrayMethodIsStrict("join", ",");
    $({ target: "Array", proto: true, forced: FORCED }, {
      join: function join(separator) {
        return nativeJoin(toIndexedObject(this), separator === void 0 ? "," : separator);
      }
    });
  }
});

// node_modules/core-js/modules/es.function.name.js
var require_es_function_name = __commonJS({
  "node_modules/core-js/modules/es.function.name.js"() {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var FUNCTION_NAME_EXISTS = require_function_name().EXISTS;
    var uncurryThis = require_function_uncurry_this();
    var defineBuiltInAccessor = require_define_built_in_accessor();
    var FunctionPrototype = Function.prototype;
    var functionToString = uncurryThis(FunctionPrototype.toString);
    var nameRE = /function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/;
    var regExpExec = uncurryThis(nameRE.exec);
    var NAME = "name";
    if (DESCRIPTORS && !FUNCTION_NAME_EXISTS) {
      defineBuiltInAccessor(FunctionPrototype, NAME, {
        configurable: true,
        get: function() {
          try {
            return regExpExec(nameRE, functionToString(this))[1];
          } catch (error) {
            return "";
          }
        }
      });
    }
  }
});

// node_modules/@babel/runtime/helpers/arrayWithHoles.js
var require_arrayWithHoles = __commonJS({
  "node_modules/@babel/runtime/helpers/arrayWithHoles.js"(exports, module) {
    function _arrayWithHoles(r) {
      if (Array.isArray(r)) return r;
    }
    module.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/iterableToArrayLimit.js
var require_iterableToArrayLimit = __commonJS({
  "node_modules/@babel/runtime/helpers/iterableToArrayLimit.js"(exports, module) {
    function _iterableToArrayLimit(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e, n, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    module.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/arrayLikeToArray.js
var require_arrayLikeToArray = __commonJS({
  "node_modules/@babel/runtime/helpers/arrayLikeToArray.js"(exports, module) {
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js
var require_unsupportedIterableToArray = __commonJS({
  "node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js"(exports, module) {
    var arrayLikeToArray = require_arrayLikeToArray();
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? arrayLikeToArray(r, a) : void 0;
      }
    }
    module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/nonIterableRest.js
var require_nonIterableRest = __commonJS({
  "node_modules/@babel/runtime/helpers/nonIterableRest.js"(exports, module) {
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    module.exports = _nonIterableRest, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/slicedToArray.js
var require_slicedToArray = __commonJS({
  "node_modules/@babel/runtime/helpers/slicedToArray.js"(exports, module) {
    var arrayWithHoles = require_arrayWithHoles();
    var iterableToArrayLimit = require_iterableToArrayLimit();
    var unsupportedIterableToArray = require_unsupportedIterableToArray();
    var nonIterableRest = require_nonIterableRest();
    function _slicedToArray(r, e) {
      return arrayWithHoles(r) || iterableToArrayLimit(r, e) || unsupportedIterableToArray(r, e) || nonIterableRest();
    }
    module.exports = _slicedToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/core-js/modules/es.array.slice.js
var require_es_array_slice = __commonJS({
  "node_modules/core-js/modules/es.array.slice.js"() {
    "use strict";
    var $ = require_export();
    var isArray = require_is_array();
    var isConstructor = require_is_constructor();
    var isObject = require_is_object();
    var toAbsoluteIndex = require_to_absolute_index();
    var lengthOfArrayLike = require_length_of_array_like();
    var toIndexedObject = require_to_indexed_object();
    var createProperty = require_create_property();
    var wellKnownSymbol = require_well_known_symbol();
    var arrayMethodHasSpeciesSupport = require_array_method_has_species_support();
    var nativeSlice = require_array_slice();
    var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("slice");
    var SPECIES = wellKnownSymbol("species");
    var $Array = Array;
    var max = Math.max;
    $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
      slice: function slice(start, end2) {
        var O = toIndexedObject(this);
        var length = lengthOfArrayLike(O);
        var k = toAbsoluteIndex(start, length);
        var fin = toAbsoluteIndex(end2 === void 0 ? length : end2, length);
        var Constructor, result, n;
        if (isArray(O)) {
          Constructor = O.constructor;
          if (isConstructor(Constructor) && (Constructor === $Array || isArray(Constructor.prototype))) {
            Constructor = void 0;
          } else if (isObject(Constructor)) {
            Constructor = Constructor[SPECIES];
            if (Constructor === null) Constructor = void 0;
          }
          if (Constructor === $Array || Constructor === void 0) {
            return nativeSlice(O, k, fin);
          }
        }
        result = new (Constructor === void 0 ? $Array : Constructor)(max(fin - k, 0));
        for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
        result.length = n;
        return result;
      }
    });
  }
});

// node_modules/core-js/modules/es.regexp.test.js
var require_es_regexp_test = __commonJS({
  "node_modules/core-js/modules/es.regexp.test.js"() {
    "use strict";
    require_es_regexp_exec();
    var $ = require_export();
    var call = require_function_call();
    var isCallable = require_is_callable();
    var anObject = require_an_object();
    var toString = require_to_string();
    var DELEGATES_TO_EXEC = function() {
      var execCalled = false;
      var re = /[ac]/;
      re.exec = function() {
        execCalled = true;
        return /./.exec.apply(this, arguments);
      };
      return re.test("abc") === true && execCalled;
    }();
    var nativeTest = /./.test;
    $({ target: "RegExp", proto: true, forced: !DELEGATES_TO_EXEC }, {
      test: function(S) {
        var R = anObject(this);
        var string = toString(S);
        var exec = R.exec;
        if (!isCallable(exec)) return call(nativeTest, R, string);
        var result = call(exec, R, string);
        if (result === null) return false;
        anObject(result);
        return true;
      }
    });
  }
});

// node_modules/core-js/modules/es.symbol.description.js
var require_es_symbol_description = __commonJS({
  "node_modules/core-js/modules/es.symbol.description.js"() {
    "use strict";
    var $ = require_export();
    var DESCRIPTORS = require_descriptors();
    var globalThis2 = require_global_this();
    var uncurryThis = require_function_uncurry_this();
    var hasOwn = require_has_own_property();
    var isCallable = require_is_callable();
    var isPrototypeOf = require_object_is_prototype_of();
    var toString = require_to_string();
    var defineBuiltInAccessor = require_define_built_in_accessor();
    var copyConstructorProperties = require_copy_constructor_properties();
    var NativeSymbol = globalThis2.Symbol;
    var SymbolPrototype = NativeSymbol && NativeSymbol.prototype;
    if (DESCRIPTORS && isCallable(NativeSymbol) && (!("description" in SymbolPrototype) || // Safari 12 bug
    NativeSymbol().description !== void 0)) {
      EmptyStringDescriptionStore = {};
      SymbolWrapper = function Symbol2() {
        var description = arguments.length < 1 || arguments[0] === void 0 ? void 0 : toString(arguments[0]);
        var result = isPrototypeOf(SymbolPrototype, this) ? new NativeSymbol(description) : description === void 0 ? NativeSymbol() : NativeSymbol(description);
        if (description === "") EmptyStringDescriptionStore[result] = true;
        return result;
      };
      copyConstructorProperties(SymbolWrapper, NativeSymbol);
      SymbolWrapper.prototype = SymbolPrototype;
      SymbolPrototype.constructor = SymbolWrapper;
      NATIVE_SYMBOL = String(NativeSymbol("description detection")) === "Symbol(description detection)";
      thisSymbolValue = uncurryThis(SymbolPrototype.valueOf);
      symbolDescriptiveString = uncurryThis(SymbolPrototype.toString);
      regexp = /^Symbol\((.*)\)[^)]+$/;
      replace = uncurryThis("".replace);
      stringSlice = uncurryThis("".slice);
      defineBuiltInAccessor(SymbolPrototype, "description", {
        configurable: true,
        get: function description() {
          var symbol = thisSymbolValue(this);
          if (hasOwn(EmptyStringDescriptionStore, symbol)) return "";
          var string = symbolDescriptiveString(symbol);
          var desc = NATIVE_SYMBOL ? stringSlice(string, 7, -1) : replace(string, regexp, "$1");
          return desc === "" ? void 0 : desc;
        }
      });
      $({ global: true, constructor: true, forced: true }, {
        Symbol: SymbolWrapper
      });
    }
    var EmptyStringDescriptionStore;
    var SymbolWrapper;
    var NATIVE_SYMBOL;
    var thisSymbolValue;
    var symbolDescriptiveString;
    var regexp;
    var replace;
    var stringSlice;
  }
});

// node_modules/core-js/modules/es.symbol.iterator.js
var require_es_symbol_iterator = __commonJS({
  "node_modules/core-js/modules/es.symbol.iterator.js"() {
    "use strict";
    var defineWellKnownSymbol = require_well_known_symbol_define();
    defineWellKnownSymbol("iterator");
  }
});

// node_modules/@babel/runtime/helpers/arrayWithoutHoles.js
var require_arrayWithoutHoles = __commonJS({
  "node_modules/@babel/runtime/helpers/arrayWithoutHoles.js"(exports, module) {
    var arrayLikeToArray = require_arrayLikeToArray();
    function _arrayWithoutHoles(r) {
      if (Array.isArray(r)) return arrayLikeToArray(r);
    }
    module.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/iterableToArray.js
var require_iterableToArray = __commonJS({
  "node_modules/@babel/runtime/helpers/iterableToArray.js"(exports, module) {
    function _iterableToArray(r) {
      if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
    }
    module.exports = _iterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/nonIterableSpread.js
var require_nonIterableSpread = __commonJS({
  "node_modules/@babel/runtime/helpers/nonIterableSpread.js"(exports, module) {
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    module.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/toConsumableArray.js
var require_toConsumableArray = __commonJS({
  "node_modules/@babel/runtime/helpers/toConsumableArray.js"(exports, module) {
    var arrayWithoutHoles = require_arrayWithoutHoles();
    var iterableToArray = require_iterableToArray();
    var unsupportedIterableToArray = require_unsupportedIterableToArray();
    var nonIterableSpread = require_nonIterableSpread();
    function _toConsumableArray(r) {
      return arrayWithoutHoles(r) || iterableToArray(r) || unsupportedIterableToArray(r) || nonIterableSpread();
    }
    module.exports = _toConsumableArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/core-js/modules/es.array.includes.js
var require_es_array_includes = __commonJS({
  "node_modules/core-js/modules/es.array.includes.js"() {
    "use strict";
    var $ = require_export();
    var $includes = require_array_includes().includes;
    var fails = require_fails();
    var addToUnscopables = require_add_to_unscopables();
    var BROKEN_ON_SPARSE = fails(function() {
      return !Array(1).includes();
    });
    $({ target: "Array", proto: true, forced: BROKEN_ON_SPARSE }, {
      includes: function includes(el) {
        return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
    addToUnscopables("includes");
  }
});

// node_modules/core-js/internals/is-integral-number.js
var require_is_integral_number = __commonJS({
  "node_modules/core-js/internals/is-integral-number.js"(exports, module) {
    "use strict";
    var isObject = require_is_object();
    var floor = Math.floor;
    module.exports = Number.isInteger || function isInteger(it) {
      return !isObject(it) && isFinite(it) && floor(it) === it;
    };
  }
});

// node_modules/core-js/modules/es.number.is-integer.js
var require_es_number_is_integer = __commonJS({
  "node_modules/core-js/modules/es.number.is-integer.js"() {
    "use strict";
    var $ = require_export();
    var isIntegralNumber = require_is_integral_number();
    $({ target: "Number", stat: true }, {
      isInteger: isIntegralNumber
    });
  }
});

// node_modules/core-js/internals/object-to-array.js
var require_object_to_array = __commonJS({
  "node_modules/core-js/internals/object-to-array.js"(exports, module) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var fails = require_fails();
    var uncurryThis = require_function_uncurry_this();
    var objectGetPrototypeOf = require_object_get_prototype_of();
    var objectKeys = require_object_keys();
    var toIndexedObject = require_to_indexed_object();
    var $propertyIsEnumerable = require_object_property_is_enumerable().f;
    var propertyIsEnumerable = uncurryThis($propertyIsEnumerable);
    var push = uncurryThis([].push);
    var IE_BUG = DESCRIPTORS && fails(function() {
      var O = /* @__PURE__ */ Object.create(null);
      O[2] = 2;
      return !propertyIsEnumerable(O, 2);
    });
    var createMethod = function(TO_ENTRIES) {
      return function(it) {
        var O = toIndexedObject(it);
        var keys = objectKeys(O);
        var IE_WORKAROUND = IE_BUG && objectGetPrototypeOf(O) === null;
        var length = keys.length;
        var i = 0;
        var result = [];
        var key;
        while (length > i) {
          key = keys[i++];
          if (!DESCRIPTORS || (IE_WORKAROUND ? key in O : propertyIsEnumerable(O, key))) {
            push(result, TO_ENTRIES ? [key, O[key]] : O[key]);
          }
        }
        return result;
      };
    };
    module.exports = {
      // `Object.entries` method
      // https://tc39.es/ecma262/#sec-object.entries
      entries: createMethod(true),
      // `Object.values` method
      // https://tc39.es/ecma262/#sec-object.values
      values: createMethod(false)
    };
  }
});

// node_modules/core-js/modules/es.object.entries.js
var require_es_object_entries = __commonJS({
  "node_modules/core-js/modules/es.object.entries.js"() {
    "use strict";
    var $ = require_export();
    var $entries = require_object_to_array().entries;
    $({ target: "Object", stat: true }, {
      entries: function entries(O) {
        return $entries(O);
      }
    });
  }
});

// node_modules/@twilio/conversations/node_modules/@twilio/declarative-type-validator/builds/browser.js
var require_browser = __commonJS({
  "node_modules/@twilio/conversations/node_modules/@twilio/declarative-type-validator/builds/browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _typeof = require_typeof();
    require_es_function_name();
    var _slicedToArray = require_slicedToArray();
    require_es_array_iterator();
    require_es_object_to_string();
    require_web_dom_collections_iterator();
    require_es_array_concat();
    require_es_array_slice();
    require_es_array_from();
    require_es_string_iterator();
    require_es_regexp_exec();
    require_es_regexp_test();
    require_es_symbol();
    require_es_symbol_description();
    require_es_symbol_iterator();
    require_es_reflect_to_string_tag();
    require_es_reflect_construct();
    var _toConsumableArray = require_toConsumableArray();
    var _createClass = require_createClass();
    var _classCallCheck = require_classCallCheck();
    var _inherits = require_inherits();
    var _possibleConstructorReturn = require_possibleConstructorReturn();
    var _getPrototypeOf = require_getPrototypeOf();
    require_es_array_includes();
    require_es_promise();
    require_es_array_join();
    require_es_number_is_integer();
    require_es_number_constructor();
    require_es_object_entries();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var _typeof__default = _interopDefaultLegacy(_typeof);
    var _slicedToArray__default = _interopDefaultLegacy(_slicedToArray);
    var _toConsumableArray__default = _interopDefaultLegacy(_toConsumableArray);
    var _createClass__default = _interopDefaultLegacy(_createClass);
    var _classCallCheck__default = _interopDefaultLegacy(_classCallCheck);
    var _inherits__default = _interopDefaultLegacy(_inherits);
    var _possibleConstructorReturn__default = _interopDefaultLegacy(_possibleConstructorReturn);
    var _getPrototypeOf__default = _interopDefaultLegacy(_getPrototypeOf);
    var custom = function custom2() {
      for (var _len = arguments.length, checks = new Array(_len), _key = 0; _key < _len; _key++) {
        checks[_key] = arguments[_key];
      }
      return {
        checks
      };
    };
    var type = function type2() {
      for (var _len = arguments.length, checks = new Array(_len), _key = 0; _key < _len; _key++) {
        checks[_key] = arguments[_key];
      }
      return custom(function(value) {
        var isValid = false;
        var expectedTypes = [];
        for (var _i = 0, _checks = checks; _i < _checks.length; _i++) {
          var _type = _checks[_i];
          if (typeof _type === "string") {
            isValid = isValid || _typeof__default["default"](value) === _type;
            expectedTypes.push("of type ".concat(_type));
            continue;
          }
          isValid = isValid || value instanceof _type;
          expectedTypes.push("an instance of ".concat(_type.name));
        }
        return [isValid, expectedTypes];
      });
    };
    var literal = function literal2() {
      for (var _len = arguments.length, checks = new Array(_len), _key = 0; _key < _len; _key++) {
        checks[_key] = arguments[_key];
      }
      return custom(function(value) {
        var isValid = false;
        var expectedTypes = [];
        for (var _i = 0, _checks = checks; _i < _checks.length; _i++) {
          var type2 = _checks[_i];
          isValid = isValid || value === type2;
          expectedTypes.push(typeof type2 === "string" ? '"'.concat(type2, '"') : "".concat(type2));
        }
        return [isValid, expectedTypes];
      });
    };
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createForOfIteratorHelper$2(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      } };
    }
    function _unsupportedIterableToArray$2(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray$2(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen);
    }
    function _arrayLikeToArray$2(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var runtimeTypeValidation = function runtimeTypeValidation2(rules, values) {
      if (values.length > rules.length) {
        throw new Error("Expected at most ".concat(rules.length, " argument(s), but got ").concat(values.length));
      }
      while (values.length < rules.length) {
        values.push(void 0);
      }
      var _iterator = _createForOfIteratorHelper$2(values.entries()), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var _step$value = _slicedToArray__default["default"](_step.value, 2), index = _step$value[0], value = _step$value[1];
          var _validateValue = validateValue(rules[index], value), _validateValue2 = _slicedToArray__default["default"](_validateValue, 4), isValid = _validateValue2[0], received = _validateValue2[1], expected = _validateValue2[2], delimeter = _validateValue2[3];
          if (isValid) {
            continue;
          }
          var argumentIndex = index + 1;
          throw new Error("Argument ".concat(argumentIndex, " is expected to be ").concat(expected).concat(delimeter, " but got ").concat(received));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    };
    var stringifyReceivedType = function stringifyReceivedType2(value) {
      var _value$constructor;
      var receivedType;
      var types = ["undefined", "boolean", "number", "bigint", "string"];
      if (types.includes(_typeof__default["default"](value))) {
        receivedType = typeof value === "string" ? '"'.concat(value, '"') : "".concat(value);
      }
      if (_typeof__default["default"](value) === "object" && (value === null || value === void 0 ? void 0 : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name) !== "Object") {
        var _value$constructor2;
        receivedType = value === null ? "null" : "instance of ".concat(value === null || value === void 0 ? void 0 : (_value$constructor2 = value.constructor) === null || _value$constructor2 === void 0 ? void 0 : _value$constructor2.name);
      }
      if (!receivedType) {
        receivedType = _typeof__default["default"](value);
      }
      return receivedType;
    };
    var validateConstructorTypes = function validateConstructorTypes2() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var finalRuleSet = convertRuleArguments(args);
      return function(ctor) {
        return function(_ctor) {
          _inherits__default["default"](_class, _ctor);
          var _super = _createSuper(_class);
          function _class() {
            _classCallCheck__default["default"](this, _class);
            for (var _len2 = arguments.length, args2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args2[_key2] = arguments[_key2];
            }
            runtimeTypeValidation(finalRuleSet, args2);
            return _super.call.apply(_super, [this].concat(args2));
          }
          return _createClass__default["default"](_class);
        }(ctor);
      };
    };
    var validateTypes = function validateTypes2() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      var finalRuleSet = convertRuleArguments(args);
      return function(target, propertyKey, descriptor) {
        if (typeof descriptor.value !== "function") {
          throw new Error("The validateTypes decorator can only be applied to methods");
        }
        var originalMethod = descriptor.value;
        descriptor.value = function() {
          for (var _len4 = arguments.length, args2 = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args2[_key4] = arguments[_key4];
          }
          runtimeTypeValidation(finalRuleSet, args2);
          return originalMethod.apply(this, args2);
        };
      };
    };
    var validateTypesAsync = function validateTypesAsync2() {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }
      var finalRuleSet = convertRuleArguments(args);
      return function(target, propertyKey, descriptor) {
        if (typeof descriptor.value !== "function") {
          throw new Error("The validateTypesAsync decorator can only be applied to methods");
        }
        var originalMethod = descriptor.value;
        descriptor.value = function() {
          for (var _len6 = arguments.length, args2 = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
            args2[_key6] = arguments[_key6];
          }
          try {
            runtimeTypeValidation(finalRuleSet, args2);
          } catch (e) {
            return Promise.reject(e);
          }
          return originalMethod.apply(this, args2);
        };
      };
    };
    var convertRuleArguments = function convertRuleArguments2(args) {
      var finalRuleDefinitionSet = [];
      var _iterator2 = _createForOfIteratorHelper$2(args), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var arg = _step2.value;
          finalRuleDefinitionSet.push(convertRuleArgument(arg));
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return finalRuleDefinitionSet;
    };
    var convertRuleArgument = function convertRuleArgument2(arg) {
      var finalArgumentRuleDefinitions = [];
      var declaredRules = Array.isArray(arg) ? arg : [arg];
      var _iterator3 = _createForOfIteratorHelper$2(declaredRules), _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
          var rule = _step3.value;
          if (typeof rule === "string" || typeof rule === "function") {
            finalArgumentRuleDefinitions.push(type(rule));
            continue;
          }
          finalArgumentRuleDefinitions.push(rule);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      return finalArgumentRuleDefinitions;
    };
    var validateValue = function validateValue2(ruleDefinitions, value) {
      var expectedTypes = [];
      var customReceivedType;
      var isValid = false;
      var _iterator4 = _createForOfIteratorHelper$2(ruleDefinitions), _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
          var definition = _step4.value;
          var _iterator5 = _createForOfIteratorHelper$2(definition.checks), _step5;
          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
              var check = _step5.value;
              var _check = check(value), _check2 = _slicedToArray__default["default"](_check, 3), checkPassed = _check2[0], typeDescription = _check2[1], _receivedType = _check2[2];
              isValid = isValid || checkPassed;
              if (!customReceivedType && _receivedType) {
                customReceivedType = _receivedType;
              }
              if (typeDescription) {
                expectedTypes = typeof typeDescription === "string" ? [].concat(_toConsumableArray__default["default"](expectedTypes), [typeDescription]) : [].concat(_toConsumableArray__default["default"](expectedTypes), _toConsumableArray__default["default"](typeDescription));
              }
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
      if (isValid) {
        return [true];
      }
      var receivedType = customReceivedType || stringifyReceivedType(value);
      var lastIndex = expectedTypes.length - 1;
      var expectedTypesString = lastIndex > 0 ? "".concat(expectedTypes.slice(0, lastIndex).join(", "), " or ").concat(expectedTypes[lastIndex]) : expectedTypes.join(", ");
      return [false, receivedType, expectedTypesString, lastIndex > 1 ? ";" : ","];
    };
    function _createForOfIteratorHelper$1(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      } };
    }
    function _unsupportedIterableToArray$1(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
    }
    function _arrayLikeToArray$1(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var nonEmptyArray = function nonEmptyArray2(name, rules) {
      return custom(function(value) {
        if (!Array.isArray(value) || value.length < 1) {
          return [false, "a non-empty array of ".concat(name)];
        }
        var _iterator = _createForOfIteratorHelper$1(value.entries()), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var _step$value = _slicedToArray__default["default"](_step.value, 2), key = _step$value[0], valueOfKey = _step$value[1];
            var _validateValue = validateValue(convertRuleArgument(rules), valueOfKey), _validateValue2 = _slicedToArray__default["default"](_validateValue, 3), isValid = _validateValue2[0], received = _validateValue2[1], expected = _validateValue2[2];
            if (!isValid) {
              return [false, "a valid non-empty array of ".concat(name, " (index ").concat(key, " should be ").concat(expected, ")"), "malformed array of ".concat(name, " (index ").concat(key, " is ").concat(received, ")")];
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return [true];
      });
    };
    var nonEmptyString = custom(function(value) {
      return [typeof value === "string" && value.length > 0, "a non-empty string"];
    });
    var nonNegativeInteger = custom(function(value) {
      return [typeof value === "number" && Number.isInteger(value) && value >= 0, "a non-negative integer"];
    });
    var pureObject = custom(function(value) {
      return [_typeof__default["default"](value) === "object" && value !== null && !Array.isArray(value), "a pure object (non-null and non-array)"];
    });
    var objectSchema = function objectSchema2(name, schema) {
      return custom(function(object) {
        if (_typeof__default["default"](object) !== "object" || object === null || Array.isArray(object)) {
          return [false, "valid ".concat(name, " (should be a pure object)")];
        }
        for (var _i = 0, _Object$entries = Object.entries(schema); _i < _Object$entries.length; _i++) {
          var _Object$entries$_i = _slicedToArray__default["default"](_Object$entries[_i], 2), key = _Object$entries$_i[0], rules = _Object$entries$_i[1];
          var _validateValue = validateValue(convertRuleArgument(rules), object[key]), _validateValue2 = _slicedToArray__default["default"](_validateValue, 3), isValid = _validateValue2[0], received = _validateValue2[1], expected = _validateValue2[2];
          if (!isValid) {
            return [false, "valid ".concat(name, ' (key "').concat(key, '" should be ').concat(expected, ")"), "malformed ".concat(name, ' (key "').concat(key, '" is ').concat(received, ")")];
          }
        }
        return [true];
      });
    };
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var array = function array2(name, rules) {
      return custom(function(value) {
        if (!Array.isArray(value)) {
          return [false, "an array of ".concat(name)];
        }
        var _iterator = _createForOfIteratorHelper(value.entries()), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var _step$value = _slicedToArray__default["default"](_step.value, 2), key = _step$value[0], valueOfKey = _step$value[1];
            var _validateValue = validateValue(convertRuleArgument(rules), valueOfKey), _validateValue2 = _slicedToArray__default["default"](_validateValue, 3), isValid = _validateValue2[0], received = _validateValue2[1], expected = _validateValue2[2];
            if (!isValid) {
              return [false, "a valid array of ".concat(name, " (index ").concat(key, " should be ").concat(expected, ")"), "malformed array of ".concat(name, " (index ").concat(key, " is ").concat(received, ")")];
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return [true];
      });
    };
    exports.array = array;
    exports.custom = custom;
    exports.literal = literal;
    exports.nonEmptyArray = nonEmptyArray;
    exports.nonEmptyString = nonEmptyString;
    exports.nonNegativeInteger = nonNegativeInteger;
    exports.objectSchema = objectSchema;
    exports.pureObject = pureObject;
    exports.runtimeTypeValidation = runtimeTypeValidation;
    exports.stringifyReceivedType = stringifyReceivedType;
    exports.type = type;
    exports.validateConstructorTypes = validateConstructorTypes;
    exports.validateTypes = validateTypes;
    exports.validateTypesAsync = validateTypesAsync;
  }
});

// node_modules/@babel/runtime/helpers/superPropBase.js
var require_superPropBase = __commonJS({
  "node_modules/@babel/runtime/helpers/superPropBase.js"(exports, module) {
    var getPrototypeOf = require_getPrototypeOf();
    function _superPropBase(t, o) {
      for (; !{}.hasOwnProperty.call(t, o) && null !== (t = getPrototypeOf(t)); ) ;
      return t;
    }
    module.exports = _superPropBase, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/get.js
var require_get = __commonJS({
  "node_modules/@babel/runtime/helpers/get.js"(exports, module) {
    var superPropBase = require_superPropBase();
    function _get() {
      return module.exports = _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e, t, r) {
        var p = superPropBase(e, t);
        if (p) {
          var n = Object.getOwnPropertyDescriptor(p, t);
          return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;
        }
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _get.apply(null, arguments);
    }
    module.exports = _get, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@twilio/conversations/node_modules/@twilio/replay-event-emitter/builds/browser.js
var require_browser2 = __commonJS({
  "node_modules/@twilio/conversations/node_modules/@twilio/replay-event-emitter/builds/browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _toConsumableArray = require_toConsumableArray();
    var _classCallCheck = require_classCallCheck();
    var _createClass = require_createClass();
    var _assertThisInitialized = require_assertThisInitialized();
    var _get = require_get();
    var _inherits = require_inherits();
    var _possibleConstructorReturn = require_possibleConstructorReturn();
    var _getPrototypeOf = require_getPrototypeOf();
    var _defineProperty = require_defineProperty();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var _toConsumableArray__default = _interopDefaultLegacy(_toConsumableArray);
    var _classCallCheck__default = _interopDefaultLegacy(_classCallCheck);
    var _createClass__default = _interopDefaultLegacy(_createClass);
    var _assertThisInitialized__default = _interopDefaultLegacy(_assertThisInitialized);
    var _get__default = _interopDefaultLegacy(_get);
    var _inherits__default = _interopDefaultLegacy(_inherits);
    var _possibleConstructorReturn__default = _interopDefaultLegacy(_possibleConstructorReturn);
    var _getPrototypeOf__default = _interopDefaultLegacy(_getPrototypeOf);
    var _defineProperty__default = _interopDefaultLegacy(_defineProperty);
    var domain;
    function EventHandlers() {
    }
    EventHandlers.prototype = /* @__PURE__ */ Object.create(null);
    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.usingDomains = false;
    EventEmitter.prototype.domain = void 0;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._maxListeners = void 0;
    EventEmitter.defaultMaxListeners = 10;
    EventEmitter.init = function() {
      this.domain = null;
      if (EventEmitter.usingDomains) {
        if (domain.active) ;
      }
      if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
        this._events = new EventHandlers();
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || isNaN(n))
        throw new TypeError('"n" argument must be a positive number');
      this._maxListeners = n;
      return this;
    };
    function $getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return $getMaxListeners(this);
    };
    function emitNone(handler, isFn, self2) {
      if (isFn)
        handler.call(self2);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self2);
      }
    }
    function emitOne(handler, isFn, self2, arg1) {
      if (isFn)
        handler.call(self2, arg1);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self2, arg1);
      }
    }
    function emitTwo(handler, isFn, self2, arg1, arg2) {
      if (isFn)
        handler.call(self2, arg1, arg2);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self2, arg1, arg2);
      }
    }
    function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
      if (isFn)
        handler.call(self2, arg1, arg2, arg3);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self2, arg1, arg2, arg3);
      }
    }
    function emitMany(handler, isFn, self2, args) {
      if (isFn)
        handler.apply(self2, args);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].apply(self2, args);
      }
    }
    EventEmitter.prototype.emit = function emit(type) {
      var er, handler, len, args, i, events, domain2;
      var doError = type === "error";
      events = this._events;
      if (events)
        doError = doError && events.error == null;
      else if (!doError)
        return false;
      domain2 = this.domain;
      if (doError) {
        er = arguments[1];
        if (domain2) {
          if (!er)
            er = new Error('Uncaught, unspecified "error" event');
          er.domainEmitter = this;
          er.domain = domain2;
          er.domainThrown = false;
          domain2.emit("error", er);
        } else if (er instanceof Error) {
          throw er;
        } else {
          var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
          err.context = er;
          throw err;
        }
        return false;
      }
      handler = events[type];
      if (!handler)
        return false;
      var isFn = typeof handler === "function";
      len = arguments.length;
      switch (len) {
        case 1:
          emitNone(handler, isFn, this);
          break;
        case 2:
          emitOne(handler, isFn, this, arguments[1]);
          break;
        case 3:
          emitTwo(handler, isFn, this, arguments[1], arguments[2]);
          break;
        case 4:
          emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
          break;
        default:
          args = new Array(len - 1);
          for (i = 1; i < len; i++)
            args[i - 1] = arguments[i];
          emitMany(handler, isFn, this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      events = target._events;
      if (!events) {
        events = target._events = new EventHandlers();
        target._eventsCount = 0;
      } else {
        if (events.newListener) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (!existing) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else {
          if (prepend) {
            existing.unshift(listener);
          } else {
            existing.push(listener);
          }
        }
        if (!existing.warned) {
          m = $getMaxListeners(target);
          if (m && m > 0 && existing.length > m) {
            existing.warned = true;
            var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type + " listeners added. Use emitter.setMaxListeners() to increase limit");
            w.name = "MaxListenersExceededWarning";
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            emitWarning(w);
          }
        }
      }
      return target;
    }
    function emitWarning(e) {
      typeof console.warn === "function" ? console.warn(e) : console.log(e);
    }
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function _onceWrap(target, type, listener) {
      var fired = false;
      function g() {
        target.removeListener(type, g);
        if (!fired) {
          fired = true;
          listener.apply(target, arguments);
        }
      }
      g.listener = listener;
      return g;
    }
    EventEmitter.prototype.once = function once(type, listener) {
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      events = this._events;
      if (!events)
        return this;
      list = events[type];
      if (!list)
        return this;
      if (list === listener || list.listener && list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = new EventHandlers();
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length; i-- > 0; ) {
          if (list[i] === listener || list[i].listener && list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (list.length === 1) {
          list[0] = void 0;
          if (--this._eventsCount === 0) {
            this._events = new EventHandlers();
            return this;
          } else {
            delete events[type];
          }
        } else {
          spliceOne(list, position);
        }
        if (events.removeListener)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.off = function(type, listener) {
      return this.removeListener(type, listener);
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events;
      events = this._events;
      if (!events)
        return this;
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        for (var i = 0, key; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener") continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = new EventHandlers();
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners) {
        do {
          this.removeListener(type, listeners[listeners.length - 1]);
        } while (listeners[0]);
      }
      return this;
    };
    EventEmitter.prototype.listeners = function listeners(type) {
      var evlistener;
      var ret;
      var events = this._events;
      if (!events)
        ret = [];
      else {
        evlistener = events[type];
        if (!evlistener)
          ret = [];
        else if (typeof evlistener === "function")
          ret = [evlistener.listener || evlistener];
        else
          ret = unwrapListeners(evlistener);
      }
      return ret;
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
    };
    function spliceOne(list, index) {
      for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
        list[i] = list[k];
      list.pop();
    }
    function arrayClone(arr, i) {
      var copy = new Array(i);
      while (i--)
        copy[i] = arr[i];
      return copy;
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var ReplayEventEmitter = function(_EventEmitter) {
      _inherits__default["default"](ReplayEventEmitter2, _EventEmitter);
      var _super = _createSuper(ReplayEventEmitter2);
      function ReplayEventEmitter2() {
        var _this;
        _classCallCheck__default["default"](this, ReplayEventEmitter2);
        _this = _super.call(this);
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "eventHistory", /* @__PURE__ */ new Map());
        return _this;
      }
      _createClass__default["default"](ReplayEventEmitter2, [{
        key: "on",
        value: function on(event, listener) {
          return _get__default["default"](_getPrototypeOf__default["default"](ReplayEventEmitter2.prototype), "on", this).call(this, event, listener);
        }
      }, {
        key: "once",
        value: function once(event, listener) {
          return _get__default["default"](_getPrototypeOf__default["default"](ReplayEventEmitter2.prototype), "once", this).call(this, event, listener);
        }
      }, {
        key: "off",
        value: function off(event, listener) {
          return _get__default["default"](_getPrototypeOf__default["default"](ReplayEventEmitter2.prototype), "off", this).call(this, event, listener);
        }
      }, {
        key: "emit",
        value: function emit(event) {
          var _get2;
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          this.eventHistory.set(event, args);
          return (_get2 = _get__default["default"](_getPrototypeOf__default["default"](ReplayEventEmitter2.prototype), "emit", this)).call.apply(_get2, [this, event].concat(args));
        }
      }, {
        key: "addListener",
        value: function addListener(event, listener) {
          return _get__default["default"](_getPrototypeOf__default["default"](ReplayEventEmitter2.prototype), "addListener", this).call(this, event, listener);
        }
      }, {
        key: "removeListener",
        value: function removeListener(event, listener) {
          return _get__default["default"](_getPrototypeOf__default["default"](ReplayEventEmitter2.prototype), "removeListener", this).call(this, event, listener);
        }
      }, {
        key: "addListenerWithReplay",
        value: function addListenerWithReplay(event, listener) {
          var historyEntry = this.eventHistory.get(event);
          if (historyEntry !== void 0) {
            listener.apply(void 0, _toConsumableArray__default["default"](historyEntry));
          }
          return this.addListener(event, listener);
        }
      }, {
        key: "onWithReplay",
        value: function onWithReplay(event, listener) {
          return this.addListenerWithReplay(event, listener);
        }
      }, {
        key: "onceWithReplay",
        value: function onceWithReplay(event, listener) {
          var historyEntry = this.eventHistory.get(event);
          if (historyEntry !== void 0) {
            listener.apply(void 0, _toConsumableArray__default["default"](historyEntry));
            return this;
          }
          return _get__default["default"](_getPrototypeOf__default["default"](ReplayEventEmitter2.prototype), "once", this).call(this, event, listener);
        }
      }]);
      return ReplayEventEmitter2;
    }(EventEmitter);
    exports.ReplayEventEmitter = ReplayEventEmitter;
  }
});

// node_modules/lodash.isequal/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.isequal/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var asyncTag = "[object AsyncFunction]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var nullTag = "[object Null]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var proxyTag = "[object Proxy]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var undefinedTag = "[object Undefined]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var nativeObjectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView2 = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern2 = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern2.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = isEqual;
  }
});

// node_modules/core-js/internals/array-buffer-non-extensible.js
var require_array_buffer_non_extensible = __commonJS({
  "node_modules/core-js/internals/array-buffer-non-extensible.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    module.exports = fails(function() {
      if (typeof ArrayBuffer == "function") {
        var buffer = new ArrayBuffer(8);
        if (Object.isExtensible(buffer)) Object.defineProperty(buffer, "a", { value: 8 });
      }
    });
  }
});

// node_modules/core-js/internals/object-is-extensible.js
var require_object_is_extensible = __commonJS({
  "node_modules/core-js/internals/object-is-extensible.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    var isObject = require_is_object();
    var classof = require_classof_raw();
    var ARRAY_BUFFER_NON_EXTENSIBLE = require_array_buffer_non_extensible();
    var $isExtensible = Object.isExtensible;
    var FAILS_ON_PRIMITIVES = fails(function() {
      $isExtensible(1);
    });
    module.exports = FAILS_ON_PRIMITIVES || ARRAY_BUFFER_NON_EXTENSIBLE ? function isExtensible(it) {
      if (!isObject(it)) return false;
      if (ARRAY_BUFFER_NON_EXTENSIBLE && classof(it) === "ArrayBuffer") return false;
      return $isExtensible ? $isExtensible(it) : true;
    } : $isExtensible;
  }
});

// node_modules/core-js/internals/freezing.js
var require_freezing = __commonJS({
  "node_modules/core-js/internals/freezing.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    module.exports = !fails(function() {
      return Object.isExtensible(Object.preventExtensions({}));
    });
  }
});

// node_modules/core-js/internals/internal-metadata.js
var require_internal_metadata = __commonJS({
  "node_modules/core-js/internals/internal-metadata.js"(exports, module) {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this();
    var hiddenKeys = require_hidden_keys();
    var isObject = require_is_object();
    var hasOwn = require_has_own_property();
    var defineProperty = require_object_define_property().f;
    var getOwnPropertyNamesModule = require_object_get_own_property_names();
    var getOwnPropertyNamesExternalModule = require_object_get_own_property_names_external();
    var isExtensible = require_object_is_extensible();
    var uid = require_uid();
    var FREEZING = require_freezing();
    var REQUIRED = false;
    var METADATA = uid("meta");
    var id = 0;
    var setMetadata = function(it) {
      defineProperty(it, METADATA, { value: {
        objectID: "O" + id++,
        // object ID
        weakData: {}
        // weak collections IDs
      } });
    };
    var fastKey = function(it, create) {
      if (!isObject(it)) return typeof it == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
      if (!hasOwn(it, METADATA)) {
        if (!isExtensible(it)) return "F";
        if (!create) return "E";
        setMetadata(it);
      }
      return it[METADATA].objectID;
    };
    var getWeakData = function(it, create) {
      if (!hasOwn(it, METADATA)) {
        if (!isExtensible(it)) return true;
        if (!create) return false;
        setMetadata(it);
      }
      return it[METADATA].weakData;
    };
    var onFreeze = function(it) {
      if (FREEZING && REQUIRED && isExtensible(it) && !hasOwn(it, METADATA)) setMetadata(it);
      return it;
    };
    var enable = function() {
      meta.enable = function() {
      };
      REQUIRED = true;
      var getOwnPropertyNames = getOwnPropertyNamesModule.f;
      var splice = uncurryThis([].splice);
      var test = {};
      test[METADATA] = 1;
      if (getOwnPropertyNames(test).length) {
        getOwnPropertyNamesModule.f = function(it) {
          var result = getOwnPropertyNames(it);
          for (var i = 0, length = result.length; i < length; i++) {
            if (result[i] === METADATA) {
              splice(result, i, 1);
              break;
            }
          }
          return result;
        };
        $({ target: "Object", stat: true, forced: true }, {
          getOwnPropertyNames: getOwnPropertyNamesExternalModule.f
        });
      }
    };
    var meta = module.exports = {
      enable,
      fastKey,
      getWeakData,
      onFreeze
    };
    hiddenKeys[METADATA] = true;
  }
});

// node_modules/core-js/internals/collection.js
var require_collection = __commonJS({
  "node_modules/core-js/internals/collection.js"(exports, module) {
    "use strict";
    var $ = require_export();
    var globalThis2 = require_global_this();
    var uncurryThis = require_function_uncurry_this();
    var isForced = require_is_forced();
    var defineBuiltIn = require_define_built_in();
    var InternalMetadataModule = require_internal_metadata();
    var iterate = require_iterate();
    var anInstance = require_an_instance();
    var isCallable = require_is_callable();
    var isNullOrUndefined = require_is_null_or_undefined();
    var isObject = require_is_object();
    var fails = require_fails();
    var checkCorrectnessOfIteration = require_check_correctness_of_iteration();
    var setToStringTag = require_set_to_string_tag();
    var inheritIfRequired = require_inherit_if_required();
    module.exports = function(CONSTRUCTOR_NAME, wrapper, common) {
      var IS_MAP = CONSTRUCTOR_NAME.indexOf("Map") !== -1;
      var IS_WEAK = CONSTRUCTOR_NAME.indexOf("Weak") !== -1;
      var ADDER = IS_MAP ? "set" : "add";
      var NativeConstructor = globalThis2[CONSTRUCTOR_NAME];
      var NativePrototype = NativeConstructor && NativeConstructor.prototype;
      var Constructor = NativeConstructor;
      var exported = {};
      var fixMethod = function(KEY) {
        var uncurriedNativeMethod = uncurryThis(NativePrototype[KEY]);
        defineBuiltIn(
          NativePrototype,
          KEY,
          KEY === "add" ? function add(value) {
            uncurriedNativeMethod(this, value === 0 ? 0 : value);
            return this;
          } : KEY === "delete" ? function(key) {
            return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
          } : KEY === "get" ? function get(key) {
            return IS_WEAK && !isObject(key) ? void 0 : uncurriedNativeMethod(this, key === 0 ? 0 : key);
          } : KEY === "has" ? function has(key) {
            return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
          } : function set(key, value) {
            uncurriedNativeMethod(this, key === 0 ? 0 : key, value);
            return this;
          }
        );
      };
      var REPLACE = isForced(
        CONSTRUCTOR_NAME,
        !isCallable(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails(function() {
          new NativeConstructor().entries().next();
        }))
      );
      if (REPLACE) {
        Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
        InternalMetadataModule.enable();
      } else if (isForced(CONSTRUCTOR_NAME, true)) {
        var instance = new Constructor();
        var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) !== instance;
        var THROWS_ON_PRIMITIVES = fails(function() {
          instance.has(1);
        });
        var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function(iterable) {
          new NativeConstructor(iterable);
        });
        var BUGGY_ZERO = !IS_WEAK && fails(function() {
          var $instance = new NativeConstructor();
          var index = 5;
          while (index--) $instance[ADDER](index, index);
          return !$instance.has(-0);
        });
        if (!ACCEPT_ITERABLES) {
          Constructor = wrapper(function(dummy, iterable) {
            anInstance(dummy, NativePrototype);
            var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
            if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
            return that;
          });
          Constructor.prototype = NativePrototype;
          NativePrototype.constructor = Constructor;
        }
        if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
          fixMethod("delete");
          fixMethod("has");
          IS_MAP && fixMethod("get");
        }
        if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
        if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
      }
      exported[CONSTRUCTOR_NAME] = Constructor;
      $({ global: true, constructor: true, forced: Constructor !== NativeConstructor }, exported);
      setToStringTag(Constructor, CONSTRUCTOR_NAME);
      if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
      return Constructor;
    };
  }
});

// node_modules/core-js/internals/define-built-ins.js
var require_define_built_ins = __commonJS({
  "node_modules/core-js/internals/define-built-ins.js"(exports, module) {
    "use strict";
    var defineBuiltIn = require_define_built_in();
    module.exports = function(target, src, options) {
      for (var key in src) defineBuiltIn(target, key, src[key], options);
      return target;
    };
  }
});

// node_modules/core-js/internals/collection-strong.js
var require_collection_strong = __commonJS({
  "node_modules/core-js/internals/collection-strong.js"(exports, module) {
    "use strict";
    var create = require_object_create();
    var defineBuiltInAccessor = require_define_built_in_accessor();
    var defineBuiltIns = require_define_built_ins();
    var bind = require_function_bind_context();
    var anInstance = require_an_instance();
    var isNullOrUndefined = require_is_null_or_undefined();
    var iterate = require_iterate();
    var defineIterator = require_iterator_define();
    var createIterResultObject = require_create_iter_result_object();
    var setSpecies = require_set_species();
    var DESCRIPTORS = require_descriptors();
    var fastKey = require_internal_metadata().fastKey;
    var InternalStateModule = require_internal_state();
    var setInternalState = InternalStateModule.set;
    var internalStateGetterFor = InternalStateModule.getterFor;
    module.exports = {
      getConstructor: function(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
        var Constructor = wrapper(function(that, iterable) {
          anInstance(that, Prototype);
          setInternalState(that, {
            type: CONSTRUCTOR_NAME,
            index: create(null),
            first: null,
            last: null,
            size: 0
          });
          if (!DESCRIPTORS) that.size = 0;
          if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
        });
        var Prototype = Constructor.prototype;
        var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);
        var define2 = function(that, key, value) {
          var state = getInternalState(that);
          var entry = getEntry(that, key);
          var previous, index;
          if (entry) {
            entry.value = value;
          } else {
            state.last = entry = {
              index: index = fastKey(key, true),
              key,
              value,
              previous: previous = state.last,
              next: null,
              removed: false
            };
            if (!state.first) state.first = entry;
            if (previous) previous.next = entry;
            if (DESCRIPTORS) state.size++;
            else that.size++;
            if (index !== "F") state.index[index] = entry;
          }
          return that;
        };
        var getEntry = function(that, key) {
          var state = getInternalState(that);
          var index = fastKey(key);
          var entry;
          if (index !== "F") return state.index[index];
          for (entry = state.first; entry; entry = entry.next) {
            if (entry.key === key) return entry;
          }
        };
        defineBuiltIns(Prototype, {
          // `{ Map, Set }.prototype.clear()` methods
          // https://tc39.es/ecma262/#sec-map.prototype.clear
          // https://tc39.es/ecma262/#sec-set.prototype.clear
          clear: function clear() {
            var that = this;
            var state = getInternalState(that);
            var entry = state.first;
            while (entry) {
              entry.removed = true;
              if (entry.previous) entry.previous = entry.previous.next = null;
              entry = entry.next;
            }
            state.first = state.last = null;
            state.index = create(null);
            if (DESCRIPTORS) state.size = 0;
            else that.size = 0;
          },
          // `{ Map, Set }.prototype.delete(key)` methods
          // https://tc39.es/ecma262/#sec-map.prototype.delete
          // https://tc39.es/ecma262/#sec-set.prototype.delete
          "delete": function(key) {
            var that = this;
            var state = getInternalState(that);
            var entry = getEntry(that, key);
            if (entry) {
              var next = entry.next;
              var prev = entry.previous;
              delete state.index[entry.index];
              entry.removed = true;
              if (prev) prev.next = next;
              if (next) next.previous = prev;
              if (state.first === entry) state.first = next;
              if (state.last === entry) state.last = prev;
              if (DESCRIPTORS) state.size--;
              else that.size--;
            }
            return !!entry;
          },
          // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods
          // https://tc39.es/ecma262/#sec-map.prototype.foreach
          // https://tc39.es/ecma262/#sec-set.prototype.foreach
          forEach: function forEach(callbackfn) {
            var state = getInternalState(this);
            var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
            var entry;
            while (entry = entry ? entry.next : state.first) {
              boundFunction(entry.value, entry.key, this);
              while (entry && entry.removed) entry = entry.previous;
            }
          },
          // `{ Map, Set}.prototype.has(key)` methods
          // https://tc39.es/ecma262/#sec-map.prototype.has
          // https://tc39.es/ecma262/#sec-set.prototype.has
          has: function has(key) {
            return !!getEntry(this, key);
          }
        });
        defineBuiltIns(Prototype, IS_MAP ? {
          // `Map.prototype.get(key)` method
          // https://tc39.es/ecma262/#sec-map.prototype.get
          get: function get(key) {
            var entry = getEntry(this, key);
            return entry && entry.value;
          },
          // `Map.prototype.set(key, value)` method
          // https://tc39.es/ecma262/#sec-map.prototype.set
          set: function set(key, value) {
            return define2(this, key === 0 ? 0 : key, value);
          }
        } : {
          // `Set.prototype.add(value)` method
          // https://tc39.es/ecma262/#sec-set.prototype.add
          add: function add(value) {
            return define2(this, value = value === 0 ? 0 : value, value);
          }
        });
        if (DESCRIPTORS) defineBuiltInAccessor(Prototype, "size", {
          configurable: true,
          get: function() {
            return getInternalState(this).size;
          }
        });
        return Constructor;
      },
      setStrong: function(Constructor, CONSTRUCTOR_NAME, IS_MAP) {
        var ITERATOR_NAME = CONSTRUCTOR_NAME + " Iterator";
        var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
        var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
        defineIterator(Constructor, CONSTRUCTOR_NAME, function(iterated, kind) {
          setInternalState(this, {
            type: ITERATOR_NAME,
            target: iterated,
            state: getInternalCollectionState(iterated),
            kind,
            last: null
          });
        }, function() {
          var state = getInternalIteratorState(this);
          var kind = state.kind;
          var entry = state.last;
          while (entry && entry.removed) entry = entry.previous;
          if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
            state.target = null;
            return createIterResultObject(void 0, true);
          }
          if (kind === "keys") return createIterResultObject(entry.key, false);
          if (kind === "values") return createIterResultObject(entry.value, false);
          return createIterResultObject([entry.key, entry.value], false);
        }, IS_MAP ? "entries" : "values", !IS_MAP, true);
        setSpecies(CONSTRUCTOR_NAME);
      }
    };
  }
});

// node_modules/core-js/modules/es.map.constructor.js
var require_es_map_constructor = __commonJS({
  "node_modules/core-js/modules/es.map.constructor.js"() {
    "use strict";
    var collection = require_collection();
    var collectionStrong = require_collection_strong();
    collection("Map", function(init) {
      return function Map2() {
        return init(this, arguments.length ? arguments[0] : void 0);
      };
    }, collectionStrong);
  }
});

// node_modules/core-js/modules/es.map.js
var require_es_map = __commonJS({
  "node_modules/core-js/modules/es.map.js"() {
    "use strict";
    require_es_map_constructor();
  }
});

// node_modules/@twilio/operation-retrier/builds/browser.js
var require_browser3 = __commonJS({
  "node_modules/@twilio/operation-retrier/builds/browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    require_es_reflect_to_string_tag();
    require_es_reflect_construct();
    var _classCallCheck = require_classCallCheck();
    var _createClass = require_createClass();
    var _assertThisInitialized = require_assertThisInitialized();
    var _inherits = require_inherits();
    var _possibleConstructorReturn = require_possibleConstructorReturn();
    var _getPrototypeOf = require_getPrototypeOf();
    var _defineProperty = require_defineProperty();
    require_es_object_to_string();
    require_es_promise();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var _classCallCheck__default = _interopDefaultLegacy(_classCallCheck);
    var _createClass__default = _interopDefaultLegacy(_createClass);
    var _assertThisInitialized__default = _interopDefaultLegacy(_assertThisInitialized);
    var _inherits__default = _interopDefaultLegacy(_inherits);
    var _possibleConstructorReturn__default = _interopDefaultLegacy(_possibleConstructorReturn);
    var _getPrototypeOf__default = _interopDefaultLegacy(_getPrototypeOf);
    var _defineProperty__default = _interopDefaultLegacy(_defineProperty);
    var domain;
    function EventHandlers() {
    }
    EventHandlers.prototype = /* @__PURE__ */ Object.create(null);
    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.usingDomains = false;
    EventEmitter.prototype.domain = void 0;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._maxListeners = void 0;
    EventEmitter.defaultMaxListeners = 10;
    EventEmitter.init = function() {
      this.domain = null;
      if (EventEmitter.usingDomains) {
        if (domain.active) ;
      }
      if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
        this._events = new EventHandlers();
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || isNaN(n))
        throw new TypeError('"n" argument must be a positive number');
      this._maxListeners = n;
      return this;
    };
    function $getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return $getMaxListeners(this);
    };
    function emitNone(handler, isFn, self2) {
      if (isFn)
        handler.call(self2);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self2);
      }
    }
    function emitOne(handler, isFn, self2, arg1) {
      if (isFn)
        handler.call(self2, arg1);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self2, arg1);
      }
    }
    function emitTwo(handler, isFn, self2, arg1, arg2) {
      if (isFn)
        handler.call(self2, arg1, arg2);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self2, arg1, arg2);
      }
    }
    function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
      if (isFn)
        handler.call(self2, arg1, arg2, arg3);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self2, arg1, arg2, arg3);
      }
    }
    function emitMany(handler, isFn, self2, args) {
      if (isFn)
        handler.apply(self2, args);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].apply(self2, args);
      }
    }
    EventEmitter.prototype.emit = function emit(type) {
      var er, handler, len, args, i, events, domain2;
      var doError = type === "error";
      events = this._events;
      if (events)
        doError = doError && events.error == null;
      else if (!doError)
        return false;
      domain2 = this.domain;
      if (doError) {
        er = arguments[1];
        if (domain2) {
          if (!er)
            er = new Error('Uncaught, unspecified "error" event');
          er.domainEmitter = this;
          er.domain = domain2;
          er.domainThrown = false;
          domain2.emit("error", er);
        } else if (er instanceof Error) {
          throw er;
        } else {
          var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
          err.context = er;
          throw err;
        }
        return false;
      }
      handler = events[type];
      if (!handler)
        return false;
      var isFn = typeof handler === "function";
      len = arguments.length;
      switch (len) {
        case 1:
          emitNone(handler, isFn, this);
          break;
        case 2:
          emitOne(handler, isFn, this, arguments[1]);
          break;
        case 3:
          emitTwo(handler, isFn, this, arguments[1], arguments[2]);
          break;
        case 4:
          emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
          break;
        default:
          args = new Array(len - 1);
          for (i = 1; i < len; i++)
            args[i - 1] = arguments[i];
          emitMany(handler, isFn, this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      events = target._events;
      if (!events) {
        events = target._events = new EventHandlers();
        target._eventsCount = 0;
      } else {
        if (events.newListener) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (!existing) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else {
          if (prepend) {
            existing.unshift(listener);
          } else {
            existing.push(listener);
          }
        }
        if (!existing.warned) {
          m = $getMaxListeners(target);
          if (m && m > 0 && existing.length > m) {
            existing.warned = true;
            var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type + " listeners added. Use emitter.setMaxListeners() to increase limit");
            w.name = "MaxListenersExceededWarning";
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            emitWarning(w);
          }
        }
      }
      return target;
    }
    function emitWarning(e) {
      typeof console.warn === "function" ? console.warn(e) : console.log(e);
    }
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function _onceWrap(target, type, listener) {
      var fired = false;
      function g() {
        target.removeListener(type, g);
        if (!fired) {
          fired = true;
          listener.apply(target, arguments);
        }
      }
      g.listener = listener;
      return g;
    }
    EventEmitter.prototype.once = function once(type, listener) {
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      events = this._events;
      if (!events)
        return this;
      list = events[type];
      if (!list)
        return this;
      if (list === listener || list.listener && list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = new EventHandlers();
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length; i-- > 0; ) {
          if (list[i] === listener || list[i].listener && list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (list.length === 1) {
          list[0] = void 0;
          if (--this._eventsCount === 0) {
            this._events = new EventHandlers();
            return this;
          } else {
            delete events[type];
          }
        } else {
          spliceOne(list, position);
        }
        if (events.removeListener)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.off = function(type, listener) {
      return this.removeListener(type, listener);
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events;
      events = this._events;
      if (!events)
        return this;
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        for (var i = 0, key; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener") continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = new EventHandlers();
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners) {
        do {
          this.removeListener(type, listeners[listeners.length - 1]);
        } while (listeners[0]);
      }
      return this;
    };
    EventEmitter.prototype.listeners = function listeners(type) {
      var evlistener;
      var ret;
      var events = this._events;
      if (!events)
        ret = [];
      else {
        evlistener = events[type];
        if (!evlistener)
          ret = [];
        else if (typeof evlistener === "function")
          ret = [evlistener.listener || evlistener];
        else
          ret = unwrapListeners(evlistener);
      }
      return ret;
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
    };
    function spliceOne(list, index) {
      for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
        list[i] = list[k];
      list.pop();
    }
    function arrayClone(arr, i) {
      var copy = new Array(i);
      while (i--)
        copy[i] = arr[i];
      return copy;
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function _createSuper$1(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$1() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var Retrier = function(_EventEmitter) {
      _inherits__default["default"](Retrier2, _EventEmitter);
      var _super = _createSuper$1(Retrier2);
      function Retrier2(options) {
        var _this;
        _classCallCheck__default["default"](this, Retrier2);
        _this = _super.call(this);
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "timeout", null);
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "startTimestamp", -1);
        _this.minDelay = options.min;
        _this.maxDelay = options.max;
        _this.initialDelay = options.initial || 0;
        _this.maxAttemptsCount = options.maxAttemptsCount || 0;
        _this.maxAttemptsTime = options.maxAttemptsTime || 0;
        _this.randomness = options.randomness || 0;
        _this.inProgress = false;
        _this.attemptNum = 0;
        _this.prevDelay = 0;
        _this.currDelay = 0;
        return _this;
      }
      _createClass__default["default"](Retrier2, [{
        key: "attempt",
        value: function attempt() {
          if (this.timeout) {
            clearTimeout(this.timeout);
            this.timeout = null;
          }
          this.attemptNum++;
          this.emit("attempt", this);
        }
      }, {
        key: "nextDelay",
        value: function nextDelay(delayOverride) {
          if (typeof delayOverride === "number") {
            this.prevDelay = 0;
            this.currDelay = delayOverride;
            return delayOverride;
          }
          if (this.attemptNum == 0) {
            return this.initialDelay;
          }
          if (this.attemptNum == 1) {
            this.currDelay = this.minDelay;
            return this.currDelay;
          }
          this.prevDelay = this.currDelay;
          var delay = this.currDelay + this.prevDelay;
          if (this.maxDelay && delay > this.maxDelay) {
            this.currDelay = this.maxDelay;
            delay = this.maxDelay;
          }
          this.currDelay = delay;
          return delay;
        }
      }, {
        key: "randomize",
        value: function randomize(delay) {
          var area = delay * this.randomness;
          var corr = Math.round(Math.random() * area * 2 - area);
          return Math.max(0, delay + corr);
        }
      }, {
        key: "scheduleAttempt",
        value: function scheduleAttempt(delayOverride) {
          var _this2 = this;
          if (this.maxAttemptsCount && this.attemptNum >= this.maxAttemptsCount) {
            this.cleanup();
            this.emit("failed", new Error("Maximum attempt count limit reached"));
            return;
          }
          var delay = this.nextDelay(delayOverride);
          delay = this.randomize(delay);
          if (this.maxAttemptsTime && this.startTimestamp + this.maxAttemptsTime < Date.now() + delay) {
            this.cleanup();
            this.emit("failed", new Error("Maximum attempt time limit reached"));
            return;
          }
          this.timeout = setTimeout(function() {
            return _this2.attempt();
          }, delay);
        }
      }, {
        key: "cleanup",
        value: function cleanup() {
          if (this.timeout) {
            clearTimeout(this.timeout);
            this.timeout = null;
          }
          this.inProgress = false;
          this.attemptNum = 0;
          this.prevDelay = 0;
          this.currDelay = 0;
        }
      }, {
        key: "start",
        value: function start() {
          if (this.inProgress) {
            throw new Error("Retrier is already in progress");
          }
          this.inProgress = true;
          this.startTimestamp = Date.now();
          this.scheduleAttempt(this.initialDelay);
        }
      }, {
        key: "cancel",
        value: function cancel() {
          if (this.timeout) {
            clearTimeout(this.timeout);
            this.timeout = null;
            this.inProgress = false;
            this.emit("cancelled");
          }
        }
        // @todo Must be a T here, so the entire Retrier must be typed on this value type.
        // eslint-disable-next-line
      }, {
        key: "succeeded",
        value: function succeeded(arg) {
          this.emit("succeeded", arg);
        }
      }, {
        key: "failed",
        value: function failed(err, nextAttemptDelayOverride) {
          if (this.timeout) {
            throw new Error("Retrier attempt is already in progress");
          }
          this.scheduleAttempt(nextAttemptDelayOverride);
        }
      }]);
      return Retrier2;
    }(EventEmitter);
    var AsyncRetrier = function(_EventEmitter2) {
      _inherits__default["default"](AsyncRetrier2, _EventEmitter2);
      var _super2 = _createSuper$1(AsyncRetrier2);
      function AsyncRetrier2(options) {
        var _this3;
        _classCallCheck__default["default"](this, AsyncRetrier2);
        _this3 = _super2.call(this);
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this3), "resolve", function() {
          return void 0;
        });
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this3), "reject", function() {
          return void 0;
        });
        _this3.retrier = new Retrier(options);
        return _this3;
      }
      _createClass__default["default"](AsyncRetrier2, [{
        key: "run",
        value: function run(handler) {
          var _this4 = this;
          this.retrier.on("attempt", function() {
            handler().then(function(v) {
              return _this4.retrier.succeeded(v);
            }).catch(function(e) {
              return _this4.retrier.failed(e);
            });
          });
          this.retrier.on("succeeded", function(arg) {
            return _this4.resolve(arg);
          });
          this.retrier.on("cancelled", function() {
            return _this4.reject(new Error("Cancelled"));
          });
          this.retrier.on("failed", function(err) {
            return _this4.reject(err);
          });
          return new Promise(function(resolve, reject) {
            _this4.resolve = resolve;
            _this4.reject = reject;
            _this4.retrier.start();
          });
        }
      }, {
        key: "cancel",
        value: function cancel() {
          this.retrier.cancel();
        }
      }]);
      return AsyncRetrier2;
    }(EventEmitter);
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function isDef(value) {
      return value !== void 0 && value !== null;
    }
    var Backoff = function(_EventEmitter) {
      _inherits__default["default"](Backoff2, _EventEmitter);
      var _super = _createSuper(Backoff2);
      function Backoff2(options) {
        var _this;
        _classCallCheck__default["default"](this, Backoff2);
        _this = _super.call(this);
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "backoffDelay", 0);
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "nextBackoffDelay", 0);
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "backoffNumber", 0);
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "timeoutID", null);
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "maxNumberOfRetry", -1);
        options = options || {};
        var _options = options, initialDelay = _options.initialDelay, maxDelay = _options.maxDelay, randomisationFactor = _options.randomisationFactor, factor = _options.factor;
        if (isDef(initialDelay) && initialDelay < 1) {
          throw new Error("The initial timeout must be equal to or greater than 1.");
        }
        if (isDef(maxDelay) && maxDelay <= 1) {
          throw new Error("The maximal timeout must be greater than 1.");
        }
        if (isDef(randomisationFactor) && (randomisationFactor < 0 || randomisationFactor > 1)) {
          throw new Error("The randomisation factor must be between 0 and 1.");
        }
        if (isDef(factor) && factor <= 1) {
          throw new Error("Exponential factor should be greater than 1.");
        }
        _this.initialDelay = initialDelay || 100;
        _this.maxDelay = maxDelay || 1e4;
        if (_this.maxDelay <= _this.initialDelay) {
          throw new Error("The maximal backoff delay must be greater than the initial backoff delay.");
        }
        _this.randomisationFactor = randomisationFactor || 0;
        _this.factor = factor || 2;
        _this.reset();
        return _this;
      }
      _createClass__default["default"](Backoff2, [{
        key: "backoff",
        value: function backoff(err) {
          if (this.timeoutID == null) {
            if (this.backoffNumber === this.maxNumberOfRetry) {
              this.emit("fail", err);
              this.reset();
            } else {
              this.backoffDelay = this.next();
              this.timeoutID = setTimeout(this.onBackoff.bind(this), this.backoffDelay);
              this.emit("backoff", this.backoffNumber, this.backoffDelay, err);
            }
          }
        }
      }, {
        key: "reset",
        value: function reset() {
          this.backoffDelay = 0;
          this.nextBackoffDelay = this.initialDelay;
          this.backoffNumber = 0;
          if (this.timeoutID) {
            clearTimeout(this.timeoutID);
          }
          this.timeoutID = null;
        }
      }, {
        key: "failAfter",
        value: function failAfter(maxNumberOfRetry) {
          if (maxNumberOfRetry <= 0) {
            throw new Error("Expected a maximum number of retry greater than 0 but got ".concat(maxNumberOfRetry));
          }
          this.maxNumberOfRetry = maxNumberOfRetry;
        }
      }, {
        key: "next",
        value: function next() {
          this.backoffDelay = Math.min(this.nextBackoffDelay, this.maxDelay);
          this.nextBackoffDelay = this.backoffDelay * this.factor;
          var randomisationMultiple = 1 + Math.random() * this.randomisationFactor;
          return Math.min(this.maxDelay, Math.round(this.backoffDelay * randomisationMultiple));
        }
      }, {
        key: "onBackoff",
        value: function onBackoff() {
          this.timeoutID = null;
          this.emit("ready", this.backoffNumber, this.backoffDelay);
          this.backoffNumber++;
        }
      }], [{
        key: "exponential",
        value: function exponential(options) {
          return new Backoff2(options);
        }
      }]);
      return Backoff2;
    }(EventEmitter);
    exports.AsyncRetrier = AsyncRetrier;
    exports.Backoff = Backoff;
    exports.Retrier = Retrier;
  }
});

// node_modules/core-js/modules/es.regexp.to-string.js
var require_es_regexp_to_string = __commonJS({
  "node_modules/core-js/modules/es.regexp.to-string.js"() {
    "use strict";
    var PROPER_FUNCTION_NAME = require_function_name().PROPER;
    var defineBuiltIn = require_define_built_in();
    var anObject = require_an_object();
    var $toString = require_to_string();
    var fails = require_fails();
    var getRegExpFlags = require_regexp_get_flags();
    var TO_STRING = "toString";
    var RegExpPrototype = RegExp.prototype;
    var nativeToString = RegExpPrototype[TO_STRING];
    var NOT_GENERIC = fails(function() {
      return nativeToString.call({ source: "a", flags: "b" }) !== "/a/b";
    });
    var INCORRECT_NAME = PROPER_FUNCTION_NAME && nativeToString.name !== TO_STRING;
    if (NOT_GENERIC || INCORRECT_NAME) {
      defineBuiltIn(RegExpPrototype, TO_STRING, function toString() {
        var R = anObject(this);
        var pattern2 = $toString(R.source);
        var flags = $toString(getRegExpFlags(R));
        return "/" + pattern2 + "/" + flags;
      }, { unsafe: true });
    }
  }
});

// node_modules/@twilio/declarative-type-validator/builds/browser.js
var require_browser4 = __commonJS({
  "node_modules/@twilio/declarative-type-validator/builds/browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    require_es_array_slice();
    require_es_object_to_string();
    require_es_array_from();
    require_es_string_iterator();
    require_es_symbol();
    require_es_symbol_description();
    require_es_symbol_iterator();
    require_es_array_iterator();
    require_web_dom_collections_iterator();
    var _typeof = require_typeof();
    require_es_function_name();
    require_es_number_is_integer();
    require_es_number_constructor();
    var _slicedToArray = require_slicedToArray();
    require_es_object_entries();
    require_es_array_concat();
    require_es_reflect_construct();
    var _toConsumableArray = require_toConsumableArray();
    var _classCallCheck = require_classCallCheck();
    var _inherits = require_inherits();
    var _possibleConstructorReturn = require_possibleConstructorReturn();
    var _getPrototypeOf = require_getPrototypeOf();
    require_es_array_includes();
    require_es_promise();
    require_es_array_join();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var _typeof__default = _interopDefaultLegacy(_typeof);
    var _slicedToArray__default = _interopDefaultLegacy(_slicedToArray);
    var _toConsumableArray__default = _interopDefaultLegacy(_toConsumableArray);
    var _classCallCheck__default = _interopDefaultLegacy(_classCallCheck);
    var _inherits__default = _interopDefaultLegacy(_inherits);
    var _possibleConstructorReturn__default = _interopDefaultLegacy(_possibleConstructorReturn);
    var _getPrototypeOf__default = _interopDefaultLegacy(_getPrototypeOf);
    var custom = function custom2() {
      for (var _len = arguments.length, checks = new Array(_len), _key = 0; _key < _len; _key++) {
        checks[_key] = arguments[_key];
      }
      return {
        checks
      };
    };
    function _createForOfIteratorHelper$3(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      } };
    }
    function _unsupportedIterableToArray$3(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray$3(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen);
    }
    function _arrayLikeToArray$3(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var type = function type2() {
      for (var _len = arguments.length, checks = new Array(_len), _key = 0; _key < _len; _key++) {
        checks[_key] = arguments[_key];
      }
      return custom(function(value) {
        var isValid = false;
        var expectedTypes = [];
        var _iterator = _createForOfIteratorHelper$3(checks), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var _type = _step.value;
            if (typeof _type === "string") {
              isValid = isValid || _typeof__default["default"](value) === _type;
              expectedTypes.push("of type ".concat(_type));
              continue;
            }
            isValid = isValid || value instanceof _type;
            expectedTypes.push("an instance of ".concat(_type.name));
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return [isValid, expectedTypes];
      });
    };
    function _createForOfIteratorHelper$2(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      } };
    }
    function _unsupportedIterableToArray$2(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray$2(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen);
    }
    function _arrayLikeToArray$2(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var literal = function literal2() {
      for (var _len = arguments.length, checks = new Array(_len), _key = 0; _key < _len; _key++) {
        checks[_key] = arguments[_key];
      }
      return custom(function(value) {
        var isValid = false;
        var expectedTypes = [];
        var _iterator = _createForOfIteratorHelper$2(checks), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var type2 = _step.value;
            isValid = isValid || value === type2;
            expectedTypes.push(typeof type2 === "string" ? '"'.concat(type2, '"') : "".concat(type2));
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return [isValid, expectedTypes];
      });
    };
    var nonEmptyString = custom(function(value) {
      return [typeof value === "string" && value.length > 0, "a non-empty string"];
    });
    var nonNegativeInteger = custom(function(value) {
      return [typeof value === "number" && Number.isInteger(value) && value >= 0, "a non-negative integer"];
    });
    var pureObject = custom(function(value) {
      return [_typeof__default["default"](value) === "object" && value !== null && !Array.isArray(value), "a pure object (non-null and non-array)"];
    });
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createForOfIteratorHelper$1(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      } };
    }
    function _unsupportedIterableToArray$1(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
    }
    function _arrayLikeToArray$1(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var runtimeTypeValidation = function runtimeTypeValidation2(rules, values) {
      if (values.length > rules.length) {
        throw new Error("Expected at most ".concat(rules.length, " argument(s), but got ").concat(values.length));
      }
      while (values.length < rules.length) {
        values.push(void 0);
      }
      var _iterator = _createForOfIteratorHelper$1(values.entries()), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var _step$value = _slicedToArray__default["default"](_step.value, 2), index = _step$value[0], value = _step$value[1];
          var _validateValue = validateValue(rules[index], value), _validateValue2 = _slicedToArray__default["default"](_validateValue, 4), isValid = _validateValue2[0], received = _validateValue2[1], expected = _validateValue2[2], delimeter = _validateValue2[3];
          if (isValid) {
            continue;
          }
          var argumentIndex = index + 1;
          throw new Error("Argument ".concat(argumentIndex, " is expected to be ").concat(expected).concat(delimeter, " but got ").concat(received));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    };
    var stringifyReceivedType = function stringifyReceivedType2(value) {
      var _value$constructor;
      var receivedType;
      var types = ["undefined", "boolean", "number", "bigint", "string"];
      if (types.includes(_typeof__default["default"](value))) {
        receivedType = typeof value === "string" ? '"'.concat(value, '"') : "".concat(value);
      }
      if (_typeof__default["default"](value) === "object" && (value === null || value === void 0 ? void 0 : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name) !== "Object") {
        var _value$constructor2;
        receivedType = value === null ? "null" : "instance of ".concat(value === null || value === void 0 ? void 0 : (_value$constructor2 = value.constructor) === null || _value$constructor2 === void 0 ? void 0 : _value$constructor2.name);
      }
      if (!receivedType) {
        receivedType = _typeof__default["default"](value);
      }
      return receivedType;
    };
    var validateConstructorTypes = function validateConstructorTypes2() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var finalRuleSet = convertRuleArguments(args);
      return function(ctor) {
        return function(_ctor) {
          _inherits__default["default"](_class, _ctor);
          var _super = _createSuper(_class);
          function _class() {
            _classCallCheck__default["default"](this, _class);
            for (var _len2 = arguments.length, args2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args2[_key2] = arguments[_key2];
            }
            runtimeTypeValidation(finalRuleSet, args2);
            return _super.call.apply(_super, [this].concat(args2));
          }
          return _class;
        }(ctor);
      };
    };
    var validateTypes = function validateTypes2() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      var finalRuleSet = convertRuleArguments(args);
      return function(target, propertyKey, descriptor) {
        if (typeof descriptor.value !== "function") {
          throw new Error("The validateTypes decorator can only be applied to methods");
        }
        var originalMethod = descriptor.value;
        descriptor.value = function() {
          for (var _len4 = arguments.length, args2 = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args2[_key4] = arguments[_key4];
          }
          runtimeTypeValidation(finalRuleSet, args2);
          return originalMethod.apply(this, args2);
        };
      };
    };
    var validateTypesAsync = function validateTypesAsync2() {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }
      var finalRuleSet = convertRuleArguments(args);
      return function(target, propertyKey, descriptor) {
        if (typeof descriptor.value !== "function") {
          throw new Error("The validateTypesAsync decorator can only be applied to methods");
        }
        var originalMethod = descriptor.value;
        descriptor.value = function() {
          for (var _len6 = arguments.length, args2 = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
            args2[_key6] = arguments[_key6];
          }
          try {
            runtimeTypeValidation(finalRuleSet, args2);
          } catch (e) {
            return Promise.reject(e);
          }
          return originalMethod.apply(this, args2);
        };
      };
    };
    var convertRuleArguments = function convertRuleArguments2(args) {
      var finalRuleDefinitionSet = [];
      var _iterator2 = _createForOfIteratorHelper$1(args), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var arg = _step2.value;
          finalRuleDefinitionSet.push(convertRuleArgument(arg));
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return finalRuleDefinitionSet;
    };
    var convertRuleArgument = function convertRuleArgument2(arg) {
      var finalArgumentRuleDefinitions = [];
      var declaredRules = Array.isArray(arg) ? arg : [arg];
      var _iterator3 = _createForOfIteratorHelper$1(declaredRules), _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
          var rule = _step3.value;
          if (typeof rule === "string" || typeof rule === "function") {
            finalArgumentRuleDefinitions.push(type(rule));
            continue;
          }
          finalArgumentRuleDefinitions.push(rule);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      return finalArgumentRuleDefinitions;
    };
    var validateValue = function validateValue2(ruleDefinitions, value) {
      var expectedTypes = [];
      var customReceivedType;
      var isValid = false;
      var _iterator4 = _createForOfIteratorHelper$1(ruleDefinitions), _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
          var definition = _step4.value;
          var _iterator5 = _createForOfIteratorHelper$1(definition.checks), _step5;
          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
              var check = _step5.value;
              var _check = check(value), _check2 = _slicedToArray__default["default"](_check, 3), checkPassed = _check2[0], typeDescription = _check2[1], _receivedType = _check2[2];
              isValid = isValid || checkPassed;
              if (!customReceivedType && _receivedType) {
                customReceivedType = _receivedType;
              }
              if (typeDescription) {
                expectedTypes = typeof typeDescription === "string" ? [].concat(_toConsumableArray__default["default"](expectedTypes), [typeDescription]) : [].concat(_toConsumableArray__default["default"](expectedTypes), _toConsumableArray__default["default"](typeDescription));
              }
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
      if (isValid) {
        return [true];
      }
      var receivedType = customReceivedType || stringifyReceivedType(value);
      var lastIndex = expectedTypes.length - 1;
      var expectedTypesString = lastIndex > 0 ? "".concat(expectedTypes.slice(0, lastIndex).join(", "), " or ").concat(expectedTypes[lastIndex]) : expectedTypes.join(", ");
      return [false, receivedType, expectedTypesString, lastIndex > 1 ? ";" : ","];
    };
    var objectSchema = function objectSchema2(name, schema) {
      return custom(function(object) {
        if (_typeof__default["default"](object) !== "object" || object === null || Array.isArray(object)) {
          return [false, "valid ".concat(name, " (should be a pure object)")];
        }
        for (var _i = 0, _Object$entries = Object.entries(schema); _i < _Object$entries.length; _i++) {
          var _Object$entries$_i = _slicedToArray__default["default"](_Object$entries[_i], 2), key = _Object$entries$_i[0], rules = _Object$entries$_i[1];
          var _validateValue = validateValue(convertRuleArgument(rules), object[key]), _validateValue2 = _slicedToArray__default["default"](_validateValue, 3), isValid = _validateValue2[0], received = _validateValue2[1], expected = _validateValue2[2];
          if (!isValid) {
            return [false, "valid ".concat(name, ' (key "').concat(key, '" should be ').concat(expected, ")"), "malformed ".concat(name, ' (key "').concat(key, '" is ').concat(received, ")")];
          }
        }
        return [true];
      });
    };
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var array = function array2(name, rules) {
      return custom(function(value) {
        if (!Array.isArray(value)) {
          return [false, "an array of ".concat(name)];
        }
        var _iterator = _createForOfIteratorHelper(value.entries()), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var _step$value = _slicedToArray__default["default"](_step.value, 2), key = _step$value[0], valueOfKey = _step$value[1];
            var _validateValue = validateValue(convertRuleArgument(rules), valueOfKey), _validateValue2 = _slicedToArray__default["default"](_validateValue, 3), isValid = _validateValue2[0], received = _validateValue2[1], expected = _validateValue2[2];
            if (!isValid) {
              return [false, "a valid array of ".concat(name, " (index ").concat(key, " should be ").concat(expected, ")"), "malformed array of ".concat(name, " (index ").concat(key, " is ").concat(received, ")")];
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return [true];
      });
    };
    exports.array = array;
    exports.custom = custom;
    exports.literal = literal;
    exports.nonEmptyString = nonEmptyString;
    exports.nonNegativeInteger = nonNegativeInteger;
    exports.objectSchema = objectSchema;
    exports.pureObject = pureObject;
    exports.runtimeTypeValidation = runtimeTypeValidation;
    exports.stringifyReceivedType = stringifyReceivedType;
    exports.type = type;
    exports.validateConstructorTypes = validateConstructorTypes;
    exports.validateTypes = validateTypes;
    exports.validateTypesAsync = validateTypesAsync;
  }
});

// node_modules/core-js/modules/es.set.constructor.js
var require_es_set_constructor = __commonJS({
  "node_modules/core-js/modules/es.set.constructor.js"() {
    "use strict";
    var collection = require_collection();
    var collectionStrong = require_collection_strong();
    collection("Set", function(init) {
      return function Set2() {
        return init(this, arguments.length ? arguments[0] : void 0);
      };
    }, collectionStrong);
  }
});

// node_modules/core-js/modules/es.set.js
var require_es_set = __commonJS({
  "node_modules/core-js/modules/es.set.js"() {
    "use strict";
    require_es_set_constructor();
  }
});

// node_modules/javascript-state-machine/lib/state-machine.js
var require_state_machine = __commonJS({
  "node_modules/javascript-state-machine/lib/state-machine.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define("StateMachine", [], factory);
      else if (typeof exports === "object")
        exports["StateMachine"] = factory();
      else
        root["StateMachine"] = factory();
    })(exports, function() {
      return (
        /******/
        function(modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) {
              return installedModules[moduleId].exports;
            }
            var module2 = installedModules[moduleId] = {
              /******/
              i: moduleId,
              /******/
              l: false,
              /******/
              exports: {}
              /******/
            };
            modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
            module2.l = true;
            return module2.exports;
          }
          __webpack_require__.m = modules;
          __webpack_require__.c = installedModules;
          __webpack_require__.i = function(value) {
            return value;
          };
          __webpack_require__.d = function(exports2, name, getter) {
            if (!__webpack_require__.o(exports2, name)) {
              Object.defineProperty(exports2, name, {
                /******/
                configurable: false,
                /******/
                enumerable: true,
                /******/
                get: getter
                /******/
              });
            }
          };
          __webpack_require__.n = function(module2) {
            var getter = module2 && module2.__esModule ? (
              /******/
              function getDefault() {
                return module2["default"];
              }
            ) : (
              /******/
              function getModuleExports() {
                return module2;
              }
            );
            __webpack_require__.d(getter, "a", getter);
            return getter;
          };
          __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          __webpack_require__.p = "";
          return __webpack_require__(__webpack_require__.s = 5);
        }([
          /* 0 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            module2.exports = function(target, sources) {
              var n, source, key;
              for (n = 1; n < arguments.length; n++) {
                source = arguments[n];
                for (key in source) {
                  if (source.hasOwnProperty(key))
                    target[key] = source[key];
                }
              }
              return target;
            };
          },
          /* 1 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var mixin = __webpack_require__(0);
            module2.exports = {
              build: function(target, config) {
                var n, max, plugin, plugins = config.plugins;
                for (n = 0, max = plugins.length; n < max; n++) {
                  plugin = plugins[n];
                  if (plugin.methods)
                    mixin(target, plugin.methods);
                  if (plugin.properties)
                    Object.defineProperties(target, plugin.properties);
                }
              },
              hook: function(fsm, name, additional) {
                var n, max, method, plugin, plugins = fsm.config.plugins, args = [fsm.context];
                if (additional)
                  args = args.concat(additional);
                for (n = 0, max = plugins.length; n < max; n++) {
                  plugin = plugins[n];
                  method = plugins[n][name];
                  if (method)
                    method.apply(plugin, args);
                }
              }
            };
          },
          /* 2 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            function camelize(label) {
              if (label.length === 0)
                return label;
              var n, result, word, words = label.split(/[_-]/);
              if (words.length === 1 && words[0][0].toLowerCase() === words[0][0])
                return label;
              result = words[0].toLowerCase();
              for (n = 1; n < words.length; n++) {
                result = result + words[n].charAt(0).toUpperCase() + words[n].substring(1).toLowerCase();
              }
              return result;
            }
            camelize.prepended = function(prepend, label) {
              label = camelize(label);
              return prepend + label[0].toUpperCase() + label.substring(1);
            };
            module2.exports = camelize;
          },
          /* 3 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var mixin = __webpack_require__(0), camelize = __webpack_require__(2);
            function Config(options, StateMachine) {
              options = options || {};
              this.options = options;
              this.defaults = StateMachine.defaults;
              this.states = [];
              this.transitions = [];
              this.map = {};
              this.lifecycle = this.configureLifecycle();
              this.init = this.configureInitTransition(options.init);
              this.data = this.configureData(options.data);
              this.methods = this.configureMethods(options.methods);
              this.map[this.defaults.wildcard] = {};
              this.configureTransitions(options.transitions || []);
              this.plugins = this.configurePlugins(options.plugins, StateMachine.plugin);
            }
            mixin(Config.prototype, {
              addState: function(name) {
                if (!this.map[name]) {
                  this.states.push(name);
                  this.addStateLifecycleNames(name);
                  this.map[name] = {};
                }
              },
              addStateLifecycleNames: function(name) {
                this.lifecycle.onEnter[name] = camelize.prepended("onEnter", name);
                this.lifecycle.onLeave[name] = camelize.prepended("onLeave", name);
                this.lifecycle.on[name] = camelize.prepended("on", name);
              },
              addTransition: function(name) {
                if (this.transitions.indexOf(name) < 0) {
                  this.transitions.push(name);
                  this.addTransitionLifecycleNames(name);
                }
              },
              addTransitionLifecycleNames: function(name) {
                this.lifecycle.onBefore[name] = camelize.prepended("onBefore", name);
                this.lifecycle.onAfter[name] = camelize.prepended("onAfter", name);
                this.lifecycle.on[name] = camelize.prepended("on", name);
              },
              mapTransition: function(transition) {
                var name = transition.name, from = transition.from, to = transition.to;
                this.addState(from);
                if (typeof to !== "function")
                  this.addState(to);
                this.addTransition(name);
                this.map[from][name] = transition;
                return transition;
              },
              configureLifecycle: function() {
                return {
                  onBefore: { transition: "onBeforeTransition" },
                  onAfter: { transition: "onAfterTransition" },
                  onEnter: { state: "onEnterState" },
                  onLeave: { state: "onLeaveState" },
                  on: { transition: "onTransition" }
                };
              },
              configureInitTransition: function(init) {
                if (typeof init === "string") {
                  return this.mapTransition(mixin({}, this.defaults.init, { to: init, active: true }));
                } else if (typeof init === "object") {
                  return this.mapTransition(mixin({}, this.defaults.init, init, { active: true }));
                } else {
                  this.addState(this.defaults.init.from);
                  return this.defaults.init;
                }
              },
              configureData: function(data) {
                if (typeof data === "function")
                  return data;
                else if (typeof data === "object")
                  return function() {
                    return data;
                  };
                else
                  return function() {
                    return {};
                  };
              },
              configureMethods: function(methods) {
                return methods || {};
              },
              configurePlugins: function(plugins, builtin) {
                plugins = plugins || [];
                var n, max, plugin;
                for (n = 0, max = plugins.length; n < max; n++) {
                  plugin = plugins[n];
                  if (typeof plugin === "function")
                    plugins[n] = plugin = plugin();
                  if (plugin.configure)
                    plugin.configure(this);
                }
                return plugins;
              },
              configureTransitions: function(transitions) {
                var i, n, transition, from, to, wildcard = this.defaults.wildcard;
                for (n = 0; n < transitions.length; n++) {
                  transition = transitions[n];
                  from = Array.isArray(transition.from) ? transition.from : [transition.from || wildcard];
                  to = transition.to || wildcard;
                  for (i = 0; i < from.length; i++) {
                    this.mapTransition({ name: transition.name, from: from[i], to });
                  }
                }
              },
              transitionFor: function(state, transition) {
                var wildcard = this.defaults.wildcard;
                return this.map[state][transition] || this.map[wildcard][transition];
              },
              transitionsFor: function(state) {
                var wildcard = this.defaults.wildcard;
                return Object.keys(this.map[state]).concat(Object.keys(this.map[wildcard]));
              },
              allStates: function() {
                return this.states;
              },
              allTransitions: function() {
                return this.transitions;
              }
            });
            module2.exports = Config;
          },
          /* 4 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var mixin = __webpack_require__(0), Exception = __webpack_require__(6), plugin = __webpack_require__(1), UNOBSERVED = [null, []];
            function JSM(context, config) {
              this.context = context;
              this.config = config;
              this.state = config.init.from;
              this.observers = [context];
            }
            mixin(JSM.prototype, {
              init: function(args) {
                mixin(this.context, this.config.data.apply(this.context, args));
                plugin.hook(this, "init");
                if (this.config.init.active)
                  return this.fire(this.config.init.name, []);
              },
              is: function(state) {
                return Array.isArray(state) ? state.indexOf(this.state) >= 0 : this.state === state;
              },
              isPending: function() {
                return this.pending;
              },
              can: function(transition) {
                return !this.isPending() && !!this.seek(transition);
              },
              cannot: function(transition) {
                return !this.can(transition);
              },
              allStates: function() {
                return this.config.allStates();
              },
              allTransitions: function() {
                return this.config.allTransitions();
              },
              transitions: function() {
                return this.config.transitionsFor(this.state);
              },
              seek: function(transition, args) {
                var wildcard = this.config.defaults.wildcard, entry = this.config.transitionFor(this.state, transition), to = entry && entry.to;
                if (typeof to === "function")
                  return to.apply(this.context, args);
                else if (to === wildcard)
                  return this.state;
                else
                  return to;
              },
              fire: function(transition, args) {
                return this.transit(transition, this.state, this.seek(transition, args), args);
              },
              transit: function(transition, from, to, args) {
                var lifecycle = this.config.lifecycle, changed = this.config.options.observeUnchangedState || from !== to;
                if (!to)
                  return this.context.onInvalidTransition(transition, from, to);
                if (this.isPending())
                  return this.context.onPendingTransition(transition, from, to);
                this.config.addState(to);
                this.beginTransit();
                args.unshift({
                  // this context will be passed to each lifecycle event observer
                  transition,
                  from,
                  to,
                  fsm: this.context
                });
                return this.observeEvents([
                  this.observersForEvent(lifecycle.onBefore.transition),
                  this.observersForEvent(lifecycle.onBefore[transition]),
                  changed ? this.observersForEvent(lifecycle.onLeave.state) : UNOBSERVED,
                  changed ? this.observersForEvent(lifecycle.onLeave[from]) : UNOBSERVED,
                  this.observersForEvent(lifecycle.on.transition),
                  changed ? ["doTransit", [this]] : UNOBSERVED,
                  changed ? this.observersForEvent(lifecycle.onEnter.state) : UNOBSERVED,
                  changed ? this.observersForEvent(lifecycle.onEnter[to]) : UNOBSERVED,
                  changed ? this.observersForEvent(lifecycle.on[to]) : UNOBSERVED,
                  this.observersForEvent(lifecycle.onAfter.transition),
                  this.observersForEvent(lifecycle.onAfter[transition]),
                  this.observersForEvent(lifecycle.on[transition])
                ], args);
              },
              beginTransit: function() {
                this.pending = true;
              },
              endTransit: function(result) {
                this.pending = false;
                return result;
              },
              failTransit: function(result) {
                this.pending = false;
                throw result;
              },
              doTransit: function(lifecycle) {
                this.state = lifecycle.to;
              },
              observe: function(args) {
                if (args.length === 2) {
                  var observer = {};
                  observer[args[0]] = args[1];
                  this.observers.push(observer);
                } else {
                  this.observers.push(args[0]);
                }
              },
              observersForEvent: function(event) {
                var n = 0, max = this.observers.length, observer, result = [];
                for (; n < max; n++) {
                  observer = this.observers[n];
                  if (observer[event])
                    result.push(observer);
                }
                return [event, result, true];
              },
              observeEvents: function(events, args, previousEvent, previousResult) {
                if (events.length === 0) {
                  return this.endTransit(previousResult === void 0 ? true : previousResult);
                }
                var event = events[0][0], observers = events[0][1], pluggable = events[0][2];
                args[0].event = event;
                if (event && pluggable && event !== previousEvent)
                  plugin.hook(this, "lifecycle", args);
                if (observers.length === 0) {
                  events.shift();
                  return this.observeEvents(events, args, event, previousResult);
                } else {
                  var observer = observers.shift(), result = observer[event].apply(observer, args);
                  if (result && typeof result.then === "function") {
                    return result.then(this.observeEvents.bind(this, events, args, event)).catch(this.failTransit.bind(this));
                  } else if (result === false) {
                    return this.endTransit(false);
                  } else {
                    return this.observeEvents(events, args, event, result);
                  }
                }
              },
              onInvalidTransition: function(transition, from, to) {
                throw new Exception("transition is invalid in current state", transition, from, to, this.state);
              },
              onPendingTransition: function(transition, from, to) {
                throw new Exception("transition is invalid while previous transition is still in progress", transition, from, to, this.state);
              }
            });
            module2.exports = JSM;
          },
          /* 5 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var mixin = __webpack_require__(0), camelize = __webpack_require__(2), plugin = __webpack_require__(1), Config = __webpack_require__(3), JSM = __webpack_require__(4);
            var PublicMethods = {
              is: function(state) {
                return this._fsm.is(state);
              },
              can: function(transition) {
                return this._fsm.can(transition);
              },
              cannot: function(transition) {
                return this._fsm.cannot(transition);
              },
              observe: function() {
                return this._fsm.observe(arguments);
              },
              transitions: function() {
                return this._fsm.transitions();
              },
              allTransitions: function() {
                return this._fsm.allTransitions();
              },
              allStates: function() {
                return this._fsm.allStates();
              },
              onInvalidTransition: function(t, from, to) {
                return this._fsm.onInvalidTransition(t, from, to);
              },
              onPendingTransition: function(t, from, to) {
                return this._fsm.onPendingTransition(t, from, to);
              }
            };
            var PublicProperties = {
              state: {
                configurable: false,
                enumerable: true,
                get: function() {
                  return this._fsm.state;
                },
                set: function(state) {
                  throw Error("use transitions to change state");
                }
              }
            };
            function StateMachine(options) {
              return apply(this || {}, options);
            }
            function factory() {
              var cstor, options;
              if (typeof arguments[0] === "function") {
                cstor = arguments[0];
                options = arguments[1] || {};
              } else {
                cstor = function() {
                  this._fsm.apply(this, arguments);
                };
                options = arguments[0] || {};
              }
              var config = new Config(options, StateMachine);
              build(cstor.prototype, config);
              cstor.prototype._fsm.config = config;
              return cstor;
            }
            function apply(instance, options) {
              var config = new Config(options, StateMachine);
              build(instance, config);
              instance._fsm();
              return instance;
            }
            function build(target, config) {
              if (typeof target !== "object" || Array.isArray(target))
                throw Error("StateMachine can only be applied to objects");
              plugin.build(target, config);
              Object.defineProperties(target, PublicProperties);
              mixin(target, PublicMethods);
              mixin(target, config.methods);
              config.allTransitions().forEach(function(transition) {
                target[camelize(transition)] = function() {
                  return this._fsm.fire(transition, [].slice.call(arguments));
                };
              });
              target._fsm = function() {
                this._fsm = new JSM(this, config);
                this._fsm.init(arguments);
              };
            }
            StateMachine.version = "3.0.1";
            StateMachine.factory = factory;
            StateMachine.apply = apply;
            StateMachine.defaults = {
              wildcard: "*",
              init: {
                name: "init",
                from: "none"
              }
            };
            module2.exports = StateMachine;
          },
          /* 6 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            module2.exports = function(message, transition, from, to, current) {
              this.message = message;
              this.transition = transition;
              this.from = from;
              this.to = to;
              this.current = current;
            };
          }
          /******/
        ])
      );
    });
  }
});

// node_modules/twilsock/node_modules/uuid/lib/rng-browser.js
var require_rng_browser = __commonJS({
  "node_modules/twilsock/node_modules/uuid/lib/rng-browser.js"(exports, module) {
    var getRandomValues = typeof crypto != "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != "undefined" && typeof window.msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (getRandomValues) {
      rnds8 = new Uint8Array(16);
      module.exports = function whatwgRNG() {
        getRandomValues(rnds8);
        return rnds8;
      };
    } else {
      rnds = new Array(16);
      module.exports = function mathRNG() {
        for (var i = 0, r; i < 16; i++) {
          if ((i & 3) === 0) r = Math.random() * 4294967296;
          rnds[i] = r >>> ((i & 3) << 3) & 255;
        }
        return rnds;
      };
    }
    var rnds8;
    var rnds;
  }
});

// node_modules/twilsock/node_modules/uuid/lib/bytesToUuid.js
var require_bytesToUuid = __commonJS({
  "node_modules/twilsock/node_modules/uuid/lib/bytesToUuid.js"(exports, module) {
    var byteToHex = [];
    for (i = 0; i < 256; ++i) {
      byteToHex[i] = (i + 256).toString(16).substr(1);
    }
    var i;
    function bytesToUuid(buf, offset) {
      var i2 = offset || 0;
      var bth = byteToHex;
      return [
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]]
      ].join("");
    }
    module.exports = bytesToUuid;
  }
});

// node_modules/twilsock/node_modules/uuid/v1.js
var require_v1 = __commonJS({
  "node_modules/twilsock/node_modules/uuid/v1.js"(exports, module) {
    var rng = require_rng_browser();
    var bytesToUuid = require_bytesToUuid();
    var _nodeId;
    var _clockseq;
    var _lastMSecs = 0;
    var _lastNSecs = 0;
    function v1(options, buf, offset) {
      var i = buf && offset || 0;
      var b = buf || [];
      options = options || {};
      var node = options.node || _nodeId;
      var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
      if (node == null || clockseq == null) {
        var seedBytes = rng();
        if (node == null) {
          node = _nodeId = [
            seedBytes[0] | 1,
            seedBytes[1],
            seedBytes[2],
            seedBytes[3],
            seedBytes[4],
            seedBytes[5]
          ];
        }
        if (clockseq == null) {
          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
        }
      }
      var msecs = options.msecs !== void 0 ? options.msecs : (/* @__PURE__ */ new Date()).getTime();
      var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
      var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
      if (dt < 0 && options.clockseq === void 0) {
        clockseq = clockseq + 1 & 16383;
      }
      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
        nsecs = 0;
      }
      if (nsecs >= 1e4) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;
      msecs += 122192928e5;
      var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      b[i++] = tl >>> 24 & 255;
      b[i++] = tl >>> 16 & 255;
      b[i++] = tl >>> 8 & 255;
      b[i++] = tl & 255;
      var tmh = msecs / 4294967296 * 1e4 & 268435455;
      b[i++] = tmh >>> 8 & 255;
      b[i++] = tmh & 255;
      b[i++] = tmh >>> 24 & 15 | 16;
      b[i++] = tmh >>> 16 & 255;
      b[i++] = clockseq >>> 8 | 128;
      b[i++] = clockseq & 255;
      for (var n = 0; n < 6; ++n) {
        b[i + n] = node[n];
      }
      return buf ? buf : bytesToUuid(b);
    }
    module.exports = v1;
  }
});

// node_modules/twilsock/node_modules/uuid/v4.js
var require_v4 = __commonJS({
  "node_modules/twilsock/node_modules/uuid/v4.js"(exports, module) {
    var rng = require_rng_browser();
    var bytesToUuid = require_bytesToUuid();
    function v4(options, buf, offset) {
      var i = buf && offset || 0;
      if (typeof options == "string") {
        buf = options === "binary" ? new Array(16) : null;
        options = null;
      }
      options = options || {};
      var rnds = options.random || (options.rng || rng)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        for (var ii = 0; ii < 16; ++ii) {
          buf[i + ii] = rnds[ii];
        }
      }
      return buf || bytesToUuid(rnds);
    }
    module.exports = v4;
  }
});

// node_modules/twilsock/node_modules/uuid/index.js
var require_uuid = __commonJS({
  "node_modules/twilsock/node_modules/uuid/index.js"(exports, module) {
    var v1 = require_v1();
    var v4 = require_v4();
    var uuid = v4;
    uuid.v1 = v1;
    uuid.v4 = v4;
    module.exports = uuid;
  }
});

// node_modules/core-js/internals/array-buffer-basic-detection.js
var require_array_buffer_basic_detection = __commonJS({
  "node_modules/core-js/internals/array-buffer-basic-detection.js"(exports, module) {
    "use strict";
    module.exports = typeof ArrayBuffer != "undefined" && typeof DataView != "undefined";
  }
});

// node_modules/core-js/internals/array-buffer-view-core.js
var require_array_buffer_view_core = __commonJS({
  "node_modules/core-js/internals/array-buffer-view-core.js"(exports, module) {
    "use strict";
    var NATIVE_ARRAY_BUFFER = require_array_buffer_basic_detection();
    var DESCRIPTORS = require_descriptors();
    var globalThis2 = require_global_this();
    var isCallable = require_is_callable();
    var isObject = require_is_object();
    var hasOwn = require_has_own_property();
    var classof = require_classof();
    var tryToString = require_try_to_string();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var defineBuiltIn = require_define_built_in();
    var defineBuiltInAccessor = require_define_built_in_accessor();
    var isPrototypeOf = require_object_is_prototype_of();
    var getPrototypeOf = require_object_get_prototype_of();
    var setPrototypeOf = require_object_set_prototype_of();
    var wellKnownSymbol = require_well_known_symbol();
    var uid = require_uid();
    var InternalStateModule = require_internal_state();
    var enforceInternalState = InternalStateModule.enforce;
    var getInternalState = InternalStateModule.get;
    var Int8Array2 = globalThis2.Int8Array;
    var Int8ArrayPrototype = Int8Array2 && Int8Array2.prototype;
    var Uint8ClampedArray2 = globalThis2.Uint8ClampedArray;
    var Uint8ClampedArrayPrototype = Uint8ClampedArray2 && Uint8ClampedArray2.prototype;
    var TypedArray = Int8Array2 && getPrototypeOf(Int8Array2);
    var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
    var ObjectPrototype = Object.prototype;
    var TypeError2 = globalThis2.TypeError;
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var TYPED_ARRAY_TAG = uid("TYPED_ARRAY_TAG");
    var TYPED_ARRAY_CONSTRUCTOR = "TypedArrayConstructor";
    var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(globalThis2.opera) !== "Opera";
    var TYPED_ARRAY_TAG_REQUIRED = false;
    var NAME;
    var Constructor;
    var Prototype;
    var TypedArrayConstructorsList = {
      Int8Array: 1,
      Uint8Array: 1,
      Uint8ClampedArray: 1,
      Int16Array: 2,
      Uint16Array: 2,
      Int32Array: 4,
      Uint32Array: 4,
      Float32Array: 4,
      Float64Array: 8
    };
    var BigIntArrayConstructorsList = {
      BigInt64Array: 8,
      BigUint64Array: 8
    };
    var isView = function isView2(it) {
      if (!isObject(it)) return false;
      var klass = classof(it);
      return klass === "DataView" || hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);
    };
    var getTypedArrayConstructor = function(it) {
      var proto = getPrototypeOf(it);
      if (!isObject(proto)) return;
      var state = getInternalState(proto);
      return state && hasOwn(state, TYPED_ARRAY_CONSTRUCTOR) ? state[TYPED_ARRAY_CONSTRUCTOR] : getTypedArrayConstructor(proto);
    };
    var isTypedArray = function(it) {
      if (!isObject(it)) return false;
      var klass = classof(it);
      return hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);
    };
    var aTypedArray = function(it) {
      if (isTypedArray(it)) return it;
      throw new TypeError2("Target is not a typed array");
    };
    var aTypedArrayConstructor = function(C) {
      if (isCallable(C) && (!setPrototypeOf || isPrototypeOf(TypedArray, C))) return C;
      throw new TypeError2(tryToString(C) + " is not a typed array constructor");
    };
    var exportTypedArrayMethod = function(KEY, property, forced, options) {
      if (!DESCRIPTORS) return;
      if (forced) for (var ARRAY in TypedArrayConstructorsList) {
        var TypedArrayConstructor = globalThis2[ARRAY];
        if (TypedArrayConstructor && hasOwn(TypedArrayConstructor.prototype, KEY)) try {
          delete TypedArrayConstructor.prototype[KEY];
        } catch (error) {
          try {
            TypedArrayConstructor.prototype[KEY] = property;
          } catch (error2) {
          }
        }
      }
      if (!TypedArrayPrototype[KEY] || forced) {
        defineBuiltIn(TypedArrayPrototype, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property, options);
      }
    };
    var exportTypedArrayStaticMethod = function(KEY, property, forced) {
      var ARRAY, TypedArrayConstructor;
      if (!DESCRIPTORS) return;
      if (setPrototypeOf) {
        if (forced) for (ARRAY in TypedArrayConstructorsList) {
          TypedArrayConstructor = globalThis2[ARRAY];
          if (TypedArrayConstructor && hasOwn(TypedArrayConstructor, KEY)) try {
            delete TypedArrayConstructor[KEY];
          } catch (error) {
          }
        }
        if (!TypedArray[KEY] || forced) {
          try {
            return defineBuiltIn(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && TypedArray[KEY] || property);
          } catch (error) {
          }
        } else return;
      }
      for (ARRAY in TypedArrayConstructorsList) {
        TypedArrayConstructor = globalThis2[ARRAY];
        if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
          defineBuiltIn(TypedArrayConstructor, KEY, property);
        }
      }
    };
    for (NAME in TypedArrayConstructorsList) {
      Constructor = globalThis2[NAME];
      Prototype = Constructor && Constructor.prototype;
      if (Prototype) enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
      else NATIVE_ARRAY_BUFFER_VIEWS = false;
    }
    for (NAME in BigIntArrayConstructorsList) {
      Constructor = globalThis2[NAME];
      Prototype = Constructor && Constructor.prototype;
      if (Prototype) enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
    }
    if (!NATIVE_ARRAY_BUFFER_VIEWS || !isCallable(TypedArray) || TypedArray === Function.prototype) {
      TypedArray = function TypedArray2() {
        throw new TypeError2("Incorrect invocation");
      };
      if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
        if (globalThis2[NAME]) setPrototypeOf(globalThis2[NAME], TypedArray);
      }
    }
    if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
      TypedArrayPrototype = TypedArray.prototype;
      if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
        if (globalThis2[NAME]) setPrototypeOf(globalThis2[NAME].prototype, TypedArrayPrototype);
      }
    }
    if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
      setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
    }
    if (DESCRIPTORS && !hasOwn(TypedArrayPrototype, TO_STRING_TAG)) {
      TYPED_ARRAY_TAG_REQUIRED = true;
      defineBuiltInAccessor(TypedArrayPrototype, TO_STRING_TAG, {
        configurable: true,
        get: function() {
          return isObject(this) ? this[TYPED_ARRAY_TAG] : void 0;
        }
      });
      for (NAME in TypedArrayConstructorsList) if (globalThis2[NAME]) {
        createNonEnumerableProperty(globalThis2[NAME], TYPED_ARRAY_TAG, NAME);
      }
    }
    module.exports = {
      NATIVE_ARRAY_BUFFER_VIEWS,
      TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG,
      aTypedArray,
      aTypedArrayConstructor,
      exportTypedArrayMethod,
      exportTypedArrayStaticMethod,
      getTypedArrayConstructor,
      isView,
      isTypedArray,
      TypedArray,
      TypedArrayPrototype
    };
  }
});

// node_modules/core-js/internals/typed-array-constructors-require-wrappers.js
var require_typed_array_constructors_require_wrappers = __commonJS({
  "node_modules/core-js/internals/typed-array-constructors-require-wrappers.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var fails = require_fails();
    var checkCorrectnessOfIteration = require_check_correctness_of_iteration();
    var NATIVE_ARRAY_BUFFER_VIEWS = require_array_buffer_view_core().NATIVE_ARRAY_BUFFER_VIEWS;
    var ArrayBuffer2 = globalThis2.ArrayBuffer;
    var Int8Array2 = globalThis2.Int8Array;
    module.exports = !NATIVE_ARRAY_BUFFER_VIEWS || !fails(function() {
      Int8Array2(1);
    }) || !fails(function() {
      new Int8Array2(-1);
    }) || !checkCorrectnessOfIteration(function(iterable) {
      new Int8Array2();
      new Int8Array2(null);
      new Int8Array2(1.5);
      new Int8Array2(iterable);
    }, true) || fails(function() {
      return new Int8Array2(new ArrayBuffer2(2), 1, void 0).length !== 1;
    });
  }
});

// node_modules/core-js/internals/to-index.js
var require_to_index = __commonJS({
  "node_modules/core-js/internals/to-index.js"(exports, module) {
    "use strict";
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var toLength = require_to_length();
    var $RangeError = RangeError;
    module.exports = function(it) {
      if (it === void 0) return 0;
      var number = toIntegerOrInfinity(it);
      var length = toLength(number);
      if (number !== length) throw new $RangeError("Wrong length or index");
      return length;
    };
  }
});

// node_modules/core-js/internals/math-sign.js
var require_math_sign = __commonJS({
  "node_modules/core-js/internals/math-sign.js"(exports, module) {
    "use strict";
    module.exports = Math.sign || function sign(x) {
      var n = +x;
      return n === 0 || n !== n ? n : n < 0 ? -1 : 1;
    };
  }
});

// node_modules/core-js/internals/math-round-ties-to-even.js
var require_math_round_ties_to_even = __commonJS({
  "node_modules/core-js/internals/math-round-ties-to-even.js"(exports, module) {
    "use strict";
    var EPSILON = 2220446049250313e-31;
    var INVERSE_EPSILON = 1 / EPSILON;
    module.exports = function(n) {
      return n + INVERSE_EPSILON - INVERSE_EPSILON;
    };
  }
});

// node_modules/core-js/internals/math-float-round.js
var require_math_float_round = __commonJS({
  "node_modules/core-js/internals/math-float-round.js"(exports, module) {
    "use strict";
    var sign = require_math_sign();
    var roundTiesToEven = require_math_round_ties_to_even();
    var abs = Math.abs;
    var EPSILON = 2220446049250313e-31;
    module.exports = function(x, FLOAT_EPSILON, FLOAT_MAX_VALUE, FLOAT_MIN_VALUE) {
      var n = +x;
      var absolute = abs(n);
      var s = sign(n);
      if (absolute < FLOAT_MIN_VALUE) return s * roundTiesToEven(absolute / FLOAT_MIN_VALUE / FLOAT_EPSILON) * FLOAT_MIN_VALUE * FLOAT_EPSILON;
      var a = (1 + FLOAT_EPSILON / EPSILON) * absolute;
      var result = a - (a - absolute);
      if (result > FLOAT_MAX_VALUE || result !== result) return s * Infinity;
      return s * result;
    };
  }
});

// node_modules/core-js/internals/math-fround.js
var require_math_fround = __commonJS({
  "node_modules/core-js/internals/math-fround.js"(exports, module) {
    "use strict";
    var floatRound = require_math_float_round();
    var FLOAT32_EPSILON = 11920928955078125e-23;
    var FLOAT32_MAX_VALUE = 34028234663852886e22;
    var FLOAT32_MIN_VALUE = 11754943508222875e-54;
    module.exports = Math.fround || function fround(x) {
      return floatRound(x, FLOAT32_EPSILON, FLOAT32_MAX_VALUE, FLOAT32_MIN_VALUE);
    };
  }
});

// node_modules/core-js/internals/ieee754.js
var require_ieee754 = __commonJS({
  "node_modules/core-js/internals/ieee754.js"(exports, module) {
    "use strict";
    var $Array = Array;
    var abs = Math.abs;
    var pow = Math.pow;
    var floor = Math.floor;
    var log = Math.log;
    var LN2 = Math.LN2;
    var pack = function(number, mantissaLength, bytes) {
      var buffer = $Array(bytes);
      var exponentLength = bytes * 8 - mantissaLength - 1;
      var eMax = (1 << exponentLength) - 1;
      var eBias = eMax >> 1;
      var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
      var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
      var index = 0;
      var exponent, mantissa, c;
      number = abs(number);
      if (number !== number || number === Infinity) {
        mantissa = number !== number ? 1 : 0;
        exponent = eMax;
      } else {
        exponent = floor(log(number) / LN2);
        c = pow(2, -exponent);
        if (number * c < 1) {
          exponent--;
          c *= 2;
        }
        if (exponent + eBias >= 1) {
          number += rt / c;
        } else {
          number += rt * pow(2, 1 - eBias);
        }
        if (number * c >= 2) {
          exponent++;
          c /= 2;
        }
        if (exponent + eBias >= eMax) {
          mantissa = 0;
          exponent = eMax;
        } else if (exponent + eBias >= 1) {
          mantissa = (number * c - 1) * pow(2, mantissaLength);
          exponent += eBias;
        } else {
          mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
          exponent = 0;
        }
      }
      while (mantissaLength >= 8) {
        buffer[index++] = mantissa & 255;
        mantissa /= 256;
        mantissaLength -= 8;
      }
      exponent = exponent << mantissaLength | mantissa;
      exponentLength += mantissaLength;
      while (exponentLength > 0) {
        buffer[index++] = exponent & 255;
        exponent /= 256;
        exponentLength -= 8;
      }
      buffer[index - 1] |= sign * 128;
      return buffer;
    };
    var unpack = function(buffer, mantissaLength) {
      var bytes = buffer.length;
      var exponentLength = bytes * 8 - mantissaLength - 1;
      var eMax = (1 << exponentLength) - 1;
      var eBias = eMax >> 1;
      var nBits = exponentLength - 7;
      var index = bytes - 1;
      var sign = buffer[index--];
      var exponent = sign & 127;
      var mantissa;
      sign >>= 7;
      while (nBits > 0) {
        exponent = exponent * 256 + buffer[index--];
        nBits -= 8;
      }
      mantissa = exponent & (1 << -nBits) - 1;
      exponent >>= -nBits;
      nBits += mantissaLength;
      while (nBits > 0) {
        mantissa = mantissa * 256 + buffer[index--];
        nBits -= 8;
      }
      if (exponent === 0) {
        exponent = 1 - eBias;
      } else if (exponent === eMax) {
        return mantissa ? NaN : sign ? -Infinity : Infinity;
      } else {
        mantissa += pow(2, mantissaLength);
        exponent -= eBias;
      }
      return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
    };
    module.exports = {
      pack,
      unpack
    };
  }
});

// node_modules/core-js/internals/array-fill.js
var require_array_fill = __commonJS({
  "node_modules/core-js/internals/array-fill.js"(exports, module) {
    "use strict";
    var toObject = require_to_object();
    var toAbsoluteIndex = require_to_absolute_index();
    var lengthOfArrayLike = require_length_of_array_like();
    module.exports = function fill(value) {
      var O = toObject(this);
      var length = lengthOfArrayLike(O);
      var argumentsLength = arguments.length;
      var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : void 0, length);
      var end2 = argumentsLength > 2 ? arguments[2] : void 0;
      var endPos = end2 === void 0 ? length : toAbsoluteIndex(end2, length);
      while (endPos > index) O[index++] = value;
      return O;
    };
  }
});

// node_modules/core-js/internals/array-buffer.js
var require_array_buffer = __commonJS({
  "node_modules/core-js/internals/array-buffer.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var uncurryThis = require_function_uncurry_this();
    var DESCRIPTORS = require_descriptors();
    var NATIVE_ARRAY_BUFFER = require_array_buffer_basic_detection();
    var FunctionName = require_function_name();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var defineBuiltInAccessor = require_define_built_in_accessor();
    var defineBuiltIns = require_define_built_ins();
    var fails = require_fails();
    var anInstance = require_an_instance();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var toLength = require_to_length();
    var toIndex = require_to_index();
    var fround = require_math_fround();
    var IEEE754 = require_ieee754();
    var getPrototypeOf = require_object_get_prototype_of();
    var setPrototypeOf = require_object_set_prototype_of();
    var arrayFill = require_array_fill();
    var arraySlice = require_array_slice();
    var inheritIfRequired = require_inherit_if_required();
    var copyConstructorProperties = require_copy_constructor_properties();
    var setToStringTag = require_set_to_string_tag();
    var InternalStateModule = require_internal_state();
    var PROPER_FUNCTION_NAME = FunctionName.PROPER;
    var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
    var ARRAY_BUFFER = "ArrayBuffer";
    var DATA_VIEW = "DataView";
    var PROTOTYPE = "prototype";
    var WRONG_LENGTH = "Wrong length";
    var WRONG_INDEX = "Wrong index";
    var getInternalArrayBufferState = InternalStateModule.getterFor(ARRAY_BUFFER);
    var getInternalDataViewState = InternalStateModule.getterFor(DATA_VIEW);
    var setInternalState = InternalStateModule.set;
    var NativeArrayBuffer = globalThis2[ARRAY_BUFFER];
    var $ArrayBuffer = NativeArrayBuffer;
    var ArrayBufferPrototype = $ArrayBuffer && $ArrayBuffer[PROTOTYPE];
    var $DataView = globalThis2[DATA_VIEW];
    var DataViewPrototype = $DataView && $DataView[PROTOTYPE];
    var ObjectPrototype = Object.prototype;
    var Array2 = globalThis2.Array;
    var RangeError2 = globalThis2.RangeError;
    var fill = uncurryThis(arrayFill);
    var reverse = uncurryThis([].reverse);
    var packIEEE754 = IEEE754.pack;
    var unpackIEEE754 = IEEE754.unpack;
    var packInt8 = function(number) {
      return [number & 255];
    };
    var packInt16 = function(number) {
      return [number & 255, number >> 8 & 255];
    };
    var packInt32 = function(number) {
      return [number & 255, number >> 8 & 255, number >> 16 & 255, number >> 24 & 255];
    };
    var unpackInt32 = function(buffer) {
      return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
    };
    var packFloat32 = function(number) {
      return packIEEE754(fround(number), 23, 4);
    };
    var packFloat64 = function(number) {
      return packIEEE754(number, 52, 8);
    };
    var addGetter = function(Constructor, key, getInternalState) {
      defineBuiltInAccessor(Constructor[PROTOTYPE], key, {
        configurable: true,
        get: function() {
          return getInternalState(this)[key];
        }
      });
    };
    var get = function(view, count, index, isLittleEndian) {
      var store = getInternalDataViewState(view);
      var intIndex = toIndex(index);
      var boolIsLittleEndian = !!isLittleEndian;
      if (intIndex + count > store.byteLength) throw new RangeError2(WRONG_INDEX);
      var bytes = store.bytes;
      var start = intIndex + store.byteOffset;
      var pack = arraySlice(bytes, start, start + count);
      return boolIsLittleEndian ? pack : reverse(pack);
    };
    var set = function(view, count, index, conversion, value, isLittleEndian) {
      var store = getInternalDataViewState(view);
      var intIndex = toIndex(index);
      var pack = conversion(+value);
      var boolIsLittleEndian = !!isLittleEndian;
      if (intIndex + count > store.byteLength) throw new RangeError2(WRONG_INDEX);
      var bytes = store.bytes;
      var start = intIndex + store.byteOffset;
      for (var i = 0; i < count; i++) bytes[start + i] = pack[boolIsLittleEndian ? i : count - i - 1];
    };
    if (!NATIVE_ARRAY_BUFFER) {
      $ArrayBuffer = function ArrayBuffer2(length) {
        anInstance(this, ArrayBufferPrototype);
        var byteLength = toIndex(length);
        setInternalState(this, {
          type: ARRAY_BUFFER,
          bytes: fill(Array2(byteLength), 0),
          byteLength
        });
        if (!DESCRIPTORS) {
          this.byteLength = byteLength;
          this.detached = false;
        }
      };
      ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE];
      $DataView = function DataView2(buffer, byteOffset, byteLength) {
        anInstance(this, DataViewPrototype);
        anInstance(buffer, ArrayBufferPrototype);
        var bufferState = getInternalArrayBufferState(buffer);
        var bufferLength = bufferState.byteLength;
        var offset = toIntegerOrInfinity(byteOffset);
        if (offset < 0 || offset > bufferLength) throw new RangeError2("Wrong offset");
        byteLength = byteLength === void 0 ? bufferLength - offset : toLength(byteLength);
        if (offset + byteLength > bufferLength) throw new RangeError2(WRONG_LENGTH);
        setInternalState(this, {
          type: DATA_VIEW,
          buffer,
          byteLength,
          byteOffset: offset,
          bytes: bufferState.bytes
        });
        if (!DESCRIPTORS) {
          this.buffer = buffer;
          this.byteLength = byteLength;
          this.byteOffset = offset;
        }
      };
      DataViewPrototype = $DataView[PROTOTYPE];
      if (DESCRIPTORS) {
        addGetter($ArrayBuffer, "byteLength", getInternalArrayBufferState);
        addGetter($DataView, "buffer", getInternalDataViewState);
        addGetter($DataView, "byteLength", getInternalDataViewState);
        addGetter($DataView, "byteOffset", getInternalDataViewState);
      }
      defineBuiltIns(DataViewPrototype, {
        getInt8: function getInt8(byteOffset) {
          return get(this, 1, byteOffset)[0] << 24 >> 24;
        },
        getUint8: function getUint8(byteOffset) {
          return get(this, 1, byteOffset)[0];
        },
        getInt16: function getInt16(byteOffset) {
          var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : false);
          return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
        },
        getUint16: function getUint16(byteOffset) {
          var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : false);
          return bytes[1] << 8 | bytes[0];
        },
        getInt32: function getInt32(byteOffset) {
          return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : false));
        },
        getUint32: function getUint32(byteOffset) {
          return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : false)) >>> 0;
        },
        getFloat32: function getFloat32(byteOffset) {
          return unpackIEEE754(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : false), 23);
        },
        getFloat64: function getFloat64(byteOffset) {
          return unpackIEEE754(get(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : false), 52);
        },
        setInt8: function setInt8(byteOffset, value) {
          set(this, 1, byteOffset, packInt8, value);
        },
        setUint8: function setUint8(byteOffset, value) {
          set(this, 1, byteOffset, packInt8, value);
        },
        setInt16: function setInt16(byteOffset, value) {
          set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : false);
        },
        setUint16: function setUint16(byteOffset, value) {
          set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : false);
        },
        setInt32: function setInt32(byteOffset, value) {
          set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : false);
        },
        setUint32: function setUint32(byteOffset, value) {
          set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : false);
        },
        setFloat32: function setFloat32(byteOffset, value) {
          set(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : false);
        },
        setFloat64: function setFloat64(byteOffset, value) {
          set(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : false);
        }
      });
    } else {
      INCORRECT_ARRAY_BUFFER_NAME = PROPER_FUNCTION_NAME && NativeArrayBuffer.name !== ARRAY_BUFFER;
      if (!fails(function() {
        NativeArrayBuffer(1);
      }) || !fails(function() {
        new NativeArrayBuffer(-1);
      }) || fails(function() {
        new NativeArrayBuffer();
        new NativeArrayBuffer(1.5);
        new NativeArrayBuffer(NaN);
        return NativeArrayBuffer.length !== 1 || INCORRECT_ARRAY_BUFFER_NAME && !CONFIGURABLE_FUNCTION_NAME;
      })) {
        $ArrayBuffer = function ArrayBuffer2(length) {
          anInstance(this, ArrayBufferPrototype);
          return inheritIfRequired(new NativeArrayBuffer(toIndex(length)), this, $ArrayBuffer);
        };
        $ArrayBuffer[PROTOTYPE] = ArrayBufferPrototype;
        ArrayBufferPrototype.constructor = $ArrayBuffer;
        copyConstructorProperties($ArrayBuffer, NativeArrayBuffer);
      } else if (INCORRECT_ARRAY_BUFFER_NAME && CONFIGURABLE_FUNCTION_NAME) {
        createNonEnumerableProperty(NativeArrayBuffer, "name", ARRAY_BUFFER);
      }
      if (setPrototypeOf && getPrototypeOf(DataViewPrototype) !== ObjectPrototype) {
        setPrototypeOf(DataViewPrototype, ObjectPrototype);
      }
      testView = new $DataView(new $ArrayBuffer(2));
      $setInt8 = uncurryThis(DataViewPrototype.setInt8);
      testView.setInt8(0, 2147483648);
      testView.setInt8(1, 2147483649);
      if (testView.getInt8(0) || !testView.getInt8(1)) defineBuiltIns(DataViewPrototype, {
        setInt8: function setInt8(byteOffset, value) {
          $setInt8(this, byteOffset, value << 24 >> 24);
        },
        setUint8: function setUint8(byteOffset, value) {
          $setInt8(this, byteOffset, value << 24 >> 24);
        }
      }, { unsafe: true });
    }
    var INCORRECT_ARRAY_BUFFER_NAME;
    var testView;
    var $setInt8;
    setToStringTag($ArrayBuffer, ARRAY_BUFFER);
    setToStringTag($DataView, DATA_VIEW);
    module.exports = {
      ArrayBuffer: $ArrayBuffer,
      DataView: $DataView
    };
  }
});

// node_modules/core-js/internals/to-positive-integer.js
var require_to_positive_integer = __commonJS({
  "node_modules/core-js/internals/to-positive-integer.js"(exports, module) {
    "use strict";
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var $RangeError = RangeError;
    module.exports = function(it) {
      var result = toIntegerOrInfinity(it);
      if (result < 0) throw new $RangeError("The argument can't be less than 0");
      return result;
    };
  }
});

// node_modules/core-js/internals/to-offset.js
var require_to_offset = __commonJS({
  "node_modules/core-js/internals/to-offset.js"(exports, module) {
    "use strict";
    var toPositiveInteger = require_to_positive_integer();
    var $RangeError = RangeError;
    module.exports = function(it, BYTES) {
      var offset = toPositiveInteger(it);
      if (offset % BYTES) throw new $RangeError("Wrong offset");
      return offset;
    };
  }
});

// node_modules/core-js/internals/to-uint8-clamped.js
var require_to_uint8_clamped = __commonJS({
  "node_modules/core-js/internals/to-uint8-clamped.js"(exports, module) {
    "use strict";
    var round = Math.round;
    module.exports = function(it) {
      var value = round(it);
      return value < 0 ? 0 : value > 255 ? 255 : value & 255;
    };
  }
});

// node_modules/core-js/internals/is-big-int-array.js
var require_is_big_int_array = __commonJS({
  "node_modules/core-js/internals/is-big-int-array.js"(exports, module) {
    "use strict";
    var classof = require_classof();
    module.exports = function(it) {
      var klass = classof(it);
      return klass === "BigInt64Array" || klass === "BigUint64Array";
    };
  }
});

// node_modules/core-js/internals/to-big-int.js
var require_to_big_int = __commonJS({
  "node_modules/core-js/internals/to-big-int.js"(exports, module) {
    "use strict";
    var toPrimitive = require_to_primitive();
    var $TypeError = TypeError;
    module.exports = function(argument) {
      var prim = toPrimitive(argument, "number");
      if (typeof prim == "number") throw new $TypeError("Can't convert number to bigint");
      return BigInt(prim);
    };
  }
});

// node_modules/core-js/internals/typed-array-from.js
var require_typed_array_from = __commonJS({
  "node_modules/core-js/internals/typed-array-from.js"(exports, module) {
    "use strict";
    var bind = require_function_bind_context();
    var call = require_function_call();
    var aConstructor = require_a_constructor();
    var toObject = require_to_object();
    var lengthOfArrayLike = require_length_of_array_like();
    var getIterator = require_get_iterator();
    var getIteratorMethod = require_get_iterator_method();
    var isArrayIteratorMethod = require_is_array_iterator_method();
    var isBigIntArray = require_is_big_int_array();
    var aTypedArrayConstructor = require_array_buffer_view_core().aTypedArrayConstructor;
    var toBigInt = require_to_big_int();
    module.exports = function from(source) {
      var C = aConstructor(this);
      var O = toObject(source);
      var argumentsLength = arguments.length;
      var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
      var mapping = mapfn !== void 0;
      var iteratorMethod = getIteratorMethod(O);
      var i, length, result, thisIsBigIntArray, value, step, iterator, next;
      if (iteratorMethod && !isArrayIteratorMethod(iteratorMethod)) {
        iterator = getIterator(O, iteratorMethod);
        next = iterator.next;
        O = [];
        while (!(step = call(next, iterator)).done) {
          O.push(step.value);
        }
      }
      if (mapping && argumentsLength > 2) {
        mapfn = bind(mapfn, arguments[2]);
      }
      length = lengthOfArrayLike(O);
      result = new (aTypedArrayConstructor(C))(length);
      thisIsBigIntArray = isBigIntArray(result);
      for (i = 0; length > i; i++) {
        value = mapping ? mapfn(O[i], i) : O[i];
        result[i] = thisIsBigIntArray ? toBigInt(value) : +value;
      }
      return result;
    };
  }
});

// node_modules/core-js/internals/array-from-constructor-and-list.js
var require_array_from_constructor_and_list = __commonJS({
  "node_modules/core-js/internals/array-from-constructor-and-list.js"(exports, module) {
    "use strict";
    var lengthOfArrayLike = require_length_of_array_like();
    module.exports = function(Constructor, list, $length) {
      var index = 0;
      var length = arguments.length > 2 ? $length : lengthOfArrayLike(list);
      var result = new Constructor(length);
      while (length > index) result[index] = list[index++];
      return result;
    };
  }
});

// node_modules/core-js/internals/typed-array-constructor.js
var require_typed_array_constructor = __commonJS({
  "node_modules/core-js/internals/typed-array-constructor.js"(exports, module) {
    "use strict";
    var $ = require_export();
    var globalThis2 = require_global_this();
    var call = require_function_call();
    var DESCRIPTORS = require_descriptors();
    var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = require_typed_array_constructors_require_wrappers();
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var ArrayBufferModule = require_array_buffer();
    var anInstance = require_an_instance();
    var createPropertyDescriptor = require_create_property_descriptor();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var isIntegralNumber = require_is_integral_number();
    var toLength = require_to_length();
    var toIndex = require_to_index();
    var toOffset = require_to_offset();
    var toUint8Clamped = require_to_uint8_clamped();
    var toPropertyKey = require_to_property_key();
    var hasOwn = require_has_own_property();
    var classof = require_classof();
    var isObject = require_is_object();
    var isSymbol = require_is_symbol();
    var create = require_object_create();
    var isPrototypeOf = require_object_is_prototype_of();
    var setPrototypeOf = require_object_set_prototype_of();
    var getOwnPropertyNames = require_object_get_own_property_names().f;
    var typedArrayFrom = require_typed_array_from();
    var forEach = require_array_iteration().forEach;
    var setSpecies = require_set_species();
    var defineBuiltInAccessor = require_define_built_in_accessor();
    var definePropertyModule = require_object_define_property();
    var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
    var arrayFromConstructorAndList = require_array_from_constructor_and_list();
    var InternalStateModule = require_internal_state();
    var inheritIfRequired = require_inherit_if_required();
    var getInternalState = InternalStateModule.get;
    var setInternalState = InternalStateModule.set;
    var enforceInternalState = InternalStateModule.enforce;
    var nativeDefineProperty = definePropertyModule.f;
    var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
    var RangeError2 = globalThis2.RangeError;
    var ArrayBuffer2 = ArrayBufferModule.ArrayBuffer;
    var ArrayBufferPrototype = ArrayBuffer2.prototype;
    var DataView2 = ArrayBufferModule.DataView;
    var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
    var TYPED_ARRAY_TAG = ArrayBufferViewCore.TYPED_ARRAY_TAG;
    var TypedArray = ArrayBufferViewCore.TypedArray;
    var TypedArrayPrototype = ArrayBufferViewCore.TypedArrayPrototype;
    var isTypedArray = ArrayBufferViewCore.isTypedArray;
    var BYTES_PER_ELEMENT = "BYTES_PER_ELEMENT";
    var WRONG_LENGTH = "Wrong length";
    var addGetter = function(it, key) {
      defineBuiltInAccessor(it, key, {
        configurable: true,
        get: function() {
          return getInternalState(this)[key];
        }
      });
    };
    var isArrayBuffer = function(it) {
      var klass;
      return isPrototypeOf(ArrayBufferPrototype, it) || (klass = classof(it)) === "ArrayBuffer" || klass === "SharedArrayBuffer";
    };
    var isTypedArrayIndex = function(target, key) {
      return isTypedArray(target) && !isSymbol(key) && key in target && isIntegralNumber(+key) && key >= 0;
    };
    var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
      key = toPropertyKey(key);
      return isTypedArrayIndex(target, key) ? createPropertyDescriptor(2, target[key]) : nativeGetOwnPropertyDescriptor(target, key);
    };
    var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
      key = toPropertyKey(key);
      if (isTypedArrayIndex(target, key) && isObject(descriptor) && hasOwn(descriptor, "value") && !hasOwn(descriptor, "get") && !hasOwn(descriptor, "set") && !descriptor.configurable && (!hasOwn(descriptor, "writable") || descriptor.writable) && (!hasOwn(descriptor, "enumerable") || descriptor.enumerable)) {
        target[key] = descriptor.value;
        return target;
      }
      return nativeDefineProperty(target, key, descriptor);
    };
    if (DESCRIPTORS) {
      if (!NATIVE_ARRAY_BUFFER_VIEWS) {
        getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;
        definePropertyModule.f = wrappedDefineProperty;
        addGetter(TypedArrayPrototype, "buffer");
        addGetter(TypedArrayPrototype, "byteOffset");
        addGetter(TypedArrayPrototype, "byteLength");
        addGetter(TypedArrayPrototype, "length");
      }
      $({ target: "Object", stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {
        getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
        defineProperty: wrappedDefineProperty
      });
      module.exports = function(TYPE, wrapper, CLAMPED) {
        var BYTES = TYPE.match(/\d+/)[0] / 8;
        var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? "Clamped" : "") + "Array";
        var GETTER = "get" + TYPE;
        var SETTER = "set" + TYPE;
        var NativeTypedArrayConstructor = globalThis2[CONSTRUCTOR_NAME];
        var TypedArrayConstructor = NativeTypedArrayConstructor;
        var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
        var exported = {};
        var getter = function(that, index) {
          var data = getInternalState(that);
          return data.view[GETTER](index * BYTES + data.byteOffset, true);
        };
        var setter = function(that, index, value) {
          var data = getInternalState(that);
          data.view[SETTER](index * BYTES + data.byteOffset, CLAMPED ? toUint8Clamped(value) : value, true);
        };
        var addElement = function(that, index) {
          nativeDefineProperty(that, index, {
            get: function() {
              return getter(this, index);
            },
            set: function(value) {
              return setter(this, index, value);
            },
            enumerable: true
          });
        };
        if (!NATIVE_ARRAY_BUFFER_VIEWS) {
          TypedArrayConstructor = wrapper(function(that, data, offset, $length) {
            anInstance(that, TypedArrayConstructorPrototype);
            var index = 0;
            var byteOffset = 0;
            var buffer, byteLength, length;
            if (!isObject(data)) {
              length = toIndex(data);
              byteLength = length * BYTES;
              buffer = new ArrayBuffer2(byteLength);
            } else if (isArrayBuffer(data)) {
              buffer = data;
              byteOffset = toOffset(offset, BYTES);
              var $len = data.byteLength;
              if ($length === void 0) {
                if ($len % BYTES) throw new RangeError2(WRONG_LENGTH);
                byteLength = $len - byteOffset;
                if (byteLength < 0) throw new RangeError2(WRONG_LENGTH);
              } else {
                byteLength = toLength($length) * BYTES;
                if (byteLength + byteOffset > $len) throw new RangeError2(WRONG_LENGTH);
              }
              length = byteLength / BYTES;
            } else if (isTypedArray(data)) {
              return arrayFromConstructorAndList(TypedArrayConstructor, data);
            } else {
              return call(typedArrayFrom, TypedArrayConstructor, data);
            }
            setInternalState(that, {
              buffer,
              byteOffset,
              byteLength,
              length,
              view: new DataView2(buffer)
            });
            while (index < length) addElement(that, index++);
          });
          if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
          TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create(TypedArrayPrototype);
        } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {
          TypedArrayConstructor = wrapper(function(dummy, data, typedArrayOffset, $length) {
            anInstance(dummy, TypedArrayConstructorPrototype);
            return inheritIfRequired(function() {
              if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));
              if (isArrayBuffer(data)) return $length !== void 0 ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length) : typedArrayOffset !== void 0 ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES)) : new NativeTypedArrayConstructor(data);
              if (isTypedArray(data)) return arrayFromConstructorAndList(TypedArrayConstructor, data);
              return call(typedArrayFrom, TypedArrayConstructor, data);
            }(), dummy, TypedArrayConstructor);
          });
          if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
          forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function(key) {
            if (!(key in TypedArrayConstructor)) {
              createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
            }
          });
          TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
        }
        if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
          createNonEnumerableProperty(TypedArrayConstructorPrototype, "constructor", TypedArrayConstructor);
        }
        enforceInternalState(TypedArrayConstructorPrototype).TypedArrayConstructor = TypedArrayConstructor;
        if (TYPED_ARRAY_TAG) {
          createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
        }
        var FORCED = TypedArrayConstructor !== NativeTypedArrayConstructor;
        exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;
        $({ global: true, constructor: true, forced: FORCED, sham: !NATIVE_ARRAY_BUFFER_VIEWS }, exported);
        if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
          createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
        }
        if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
          createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
        }
        setSpecies(CONSTRUCTOR_NAME);
      };
    } else module.exports = function() {
    };
  }
});

// node_modules/core-js/modules/es.typed-array.uint8-array.js
var require_es_typed_array_uint8_array = __commonJS({
  "node_modules/core-js/modules/es.typed-array.uint8-array.js"() {
    "use strict";
    var createTypedArrayConstructor = require_typed_array_constructor();
    createTypedArrayConstructor("Uint8", function(init) {
      return function Uint8Array2(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
      };
    });
  }
});

// node_modules/core-js/internals/delete-property-or-throw.js
var require_delete_property_or_throw = __commonJS({
  "node_modules/core-js/internals/delete-property-or-throw.js"(exports, module) {
    "use strict";
    var tryToString = require_try_to_string();
    var $TypeError = TypeError;
    module.exports = function(O, P) {
      if (!delete O[P]) throw new $TypeError("Cannot delete property " + tryToString(P) + " of " + tryToString(O));
    };
  }
});

// node_modules/core-js/internals/array-copy-within.js
var require_array_copy_within = __commonJS({
  "node_modules/core-js/internals/array-copy-within.js"(exports, module) {
    "use strict";
    var toObject = require_to_object();
    var toAbsoluteIndex = require_to_absolute_index();
    var lengthOfArrayLike = require_length_of_array_like();
    var deletePropertyOrThrow = require_delete_property_or_throw();
    var min = Math.min;
    module.exports = [].copyWithin || function copyWithin(target, start) {
      var O = toObject(this);
      var len = lengthOfArrayLike(O);
      var to = toAbsoluteIndex(target, len);
      var from = toAbsoluteIndex(start, len);
      var end2 = arguments.length > 2 ? arguments[2] : void 0;
      var count = min((end2 === void 0 ? len : toAbsoluteIndex(end2, len)) - from, len - to);
      var inc = 1;
      if (from < to && to < from + count) {
        inc = -1;
        from += count - 1;
        to += count - 1;
      }
      while (count-- > 0) {
        if (from in O) O[to] = O[from];
        else deletePropertyOrThrow(O, to);
        to += inc;
        from += inc;
      }
      return O;
    };
  }
});

// node_modules/core-js/modules/es.typed-array.copy-within.js
var require_es_typed_array_copy_within = __commonJS({
  "node_modules/core-js/modules/es.typed-array.copy-within.js"() {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var $ArrayCopyWithin = require_array_copy_within();
    var u$ArrayCopyWithin = uncurryThis($ArrayCopyWithin);
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod("copyWithin", function copyWithin(target, start) {
      return u$ArrayCopyWithin(aTypedArray(this), target, start, arguments.length > 2 ? arguments[2] : void 0);
    });
  }
});

// node_modules/core-js/modules/es.typed-array.every.js
var require_es_typed_array_every = __commonJS({
  "node_modules/core-js/modules/es.typed-array.every.js"() {
    "use strict";
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var $every = require_array_iteration().every;
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod("every", function every(callbackfn) {
      return $every(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    });
  }
});

// node_modules/core-js/modules/es.typed-array.fill.js
var require_es_typed_array_fill = __commonJS({
  "node_modules/core-js/modules/es.typed-array.fill.js"() {
    "use strict";
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var $fill = require_array_fill();
    var toBigInt = require_to_big_int();
    var classof = require_classof();
    var call = require_function_call();
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    var slice = uncurryThis("".slice);
    var CONVERSION_BUG = fails(function() {
      var count = 0;
      new Int8Array(2).fill({ valueOf: function() {
        return count++;
      } });
      return count !== 1;
    });
    exportTypedArrayMethod("fill", function fill(value) {
      var length = arguments.length;
      aTypedArray(this);
      var actualValue = slice(classof(this), 0, 3) === "Big" ? toBigInt(value) : +value;
      return call($fill, this, actualValue, length > 1 ? arguments[1] : void 0, length > 2 ? arguments[2] : void 0);
    }, CONVERSION_BUG);
  }
});

// node_modules/core-js/internals/typed-array-from-same-type-and-list.js
var require_typed_array_from_same_type_and_list = __commonJS({
  "node_modules/core-js/internals/typed-array-from-same-type-and-list.js"(exports, module) {
    "use strict";
    var arrayFromConstructorAndList = require_array_from_constructor_and_list();
    var getTypedArrayConstructor = require_array_buffer_view_core().getTypedArrayConstructor;
    module.exports = function(instance, list) {
      return arrayFromConstructorAndList(getTypedArrayConstructor(instance), list);
    };
  }
});

// node_modules/core-js/modules/es.typed-array.filter.js
var require_es_typed_array_filter = __commonJS({
  "node_modules/core-js/modules/es.typed-array.filter.js"() {
    "use strict";
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var $filter = require_array_iteration().filter;
    var fromSameTypeAndList = require_typed_array_from_same_type_and_list();
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod("filter", function filter(callbackfn) {
      var list = $filter(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      return fromSameTypeAndList(this, list);
    });
  }
});

// node_modules/core-js/modules/es.typed-array.find.js
var require_es_typed_array_find = __commonJS({
  "node_modules/core-js/modules/es.typed-array.find.js"() {
    "use strict";
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var $find = require_array_iteration().find;
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod("find", function find(predicate) {
      return $find(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : void 0);
    });
  }
});

// node_modules/core-js/modules/es.typed-array.find-index.js
var require_es_typed_array_find_index = __commonJS({
  "node_modules/core-js/modules/es.typed-array.find-index.js"() {
    "use strict";
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var $findIndex = require_array_iteration().findIndex;
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod("findIndex", function findIndex(predicate) {
      return $findIndex(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : void 0);
    });
  }
});

// node_modules/core-js/modules/es.typed-array.for-each.js
var require_es_typed_array_for_each = __commonJS({
  "node_modules/core-js/modules/es.typed-array.for-each.js"() {
    "use strict";
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var $forEach = require_array_iteration().forEach;
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod("forEach", function forEach(callbackfn) {
      $forEach(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    });
  }
});

// node_modules/core-js/modules/es.typed-array.includes.js
var require_es_typed_array_includes = __commonJS({
  "node_modules/core-js/modules/es.typed-array.includes.js"() {
    "use strict";
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var $includes = require_array_includes().includes;
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod("includes", function includes(searchElement) {
      return $includes(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : void 0);
    });
  }
});

// node_modules/core-js/modules/es.typed-array.index-of.js
var require_es_typed_array_index_of = __commonJS({
  "node_modules/core-js/modules/es.typed-array.index-of.js"() {
    "use strict";
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var $indexOf = require_array_includes().indexOf;
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod("indexOf", function indexOf(searchElement) {
      return $indexOf(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : void 0);
    });
  }
});

// node_modules/core-js/modules/es.typed-array.iterator.js
var require_es_typed_array_iterator = __commonJS({
  "node_modules/core-js/modules/es.typed-array.iterator.js"() {
    "use strict";
    var globalThis2 = require_global_this();
    var fails = require_fails();
    var uncurryThis = require_function_uncurry_this();
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var ArrayIterators = require_es_array_iterator();
    var wellKnownSymbol = require_well_known_symbol();
    var ITERATOR = wellKnownSymbol("iterator");
    var Uint8Array2 = globalThis2.Uint8Array;
    var arrayValues = uncurryThis(ArrayIterators.values);
    var arrayKeys = uncurryThis(ArrayIterators.keys);
    var arrayEntries = uncurryThis(ArrayIterators.entries);
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    var TypedArrayPrototype = Uint8Array2 && Uint8Array2.prototype;
    var GENERIC = !fails(function() {
      TypedArrayPrototype[ITERATOR].call([1]);
    });
    var ITERATOR_IS_VALUES = !!TypedArrayPrototype && TypedArrayPrototype.values && TypedArrayPrototype[ITERATOR] === TypedArrayPrototype.values && TypedArrayPrototype.values.name === "values";
    var typedArrayValues = function values() {
      return arrayValues(aTypedArray(this));
    };
    exportTypedArrayMethod("entries", function entries() {
      return arrayEntries(aTypedArray(this));
    }, GENERIC);
    exportTypedArrayMethod("keys", function keys() {
      return arrayKeys(aTypedArray(this));
    }, GENERIC);
    exportTypedArrayMethod("values", typedArrayValues, GENERIC || !ITERATOR_IS_VALUES, { name: "values" });
    exportTypedArrayMethod(ITERATOR, typedArrayValues, GENERIC || !ITERATOR_IS_VALUES, { name: "values" });
  }
});

// node_modules/core-js/modules/es.typed-array.join.js
var require_es_typed_array_join = __commonJS({
  "node_modules/core-js/modules/es.typed-array.join.js"() {
    "use strict";
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var uncurryThis = require_function_uncurry_this();
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    var $join = uncurryThis([].join);
    exportTypedArrayMethod("join", function join(separator) {
      return $join(aTypedArray(this), separator);
    });
  }
});

// node_modules/core-js/internals/array-last-index-of.js
var require_array_last_index_of = __commonJS({
  "node_modules/core-js/internals/array-last-index-of.js"(exports, module) {
    "use strict";
    var apply = require_function_apply();
    var toIndexedObject = require_to_indexed_object();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var lengthOfArrayLike = require_length_of_array_like();
    var arrayMethodIsStrict = require_array_method_is_strict();
    var min = Math.min;
    var $lastIndexOf = [].lastIndexOf;
    var NEGATIVE_ZERO = !!$lastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
    var STRICT_METHOD = arrayMethodIsStrict("lastIndexOf");
    var FORCED = NEGATIVE_ZERO || !STRICT_METHOD;
    module.exports = FORCED ? function lastIndexOf(searchElement) {
      if (NEGATIVE_ZERO) return apply($lastIndexOf, this, arguments) || 0;
      var O = toIndexedObject(this);
      var length = lengthOfArrayLike(O);
      if (length === 0) return -1;
      var index = length - 1;
      if (arguments.length > 1) index = min(index, toIntegerOrInfinity(arguments[1]));
      if (index < 0) index = length + index;
      for (; index >= 0; index--) if (index in O && O[index] === searchElement) return index || 0;
      return -1;
    } : $lastIndexOf;
  }
});

// node_modules/core-js/modules/es.typed-array.last-index-of.js
var require_es_typed_array_last_index_of = __commonJS({
  "node_modules/core-js/modules/es.typed-array.last-index-of.js"() {
    "use strict";
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var apply = require_function_apply();
    var $lastIndexOf = require_array_last_index_of();
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod("lastIndexOf", function lastIndexOf(searchElement) {
      var length = arguments.length;
      return apply($lastIndexOf, aTypedArray(this), length > 1 ? [searchElement, arguments[1]] : [searchElement]);
    });
  }
});

// node_modules/core-js/modules/es.typed-array.map.js
var require_es_typed_array_map = __commonJS({
  "node_modules/core-js/modules/es.typed-array.map.js"() {
    "use strict";
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var $map = require_array_iteration().map;
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod("map", function map(mapfn) {
      return $map(aTypedArray(this), mapfn, arguments.length > 1 ? arguments[1] : void 0, function(O, length) {
        return new (getTypedArrayConstructor(O))(length);
      });
    });
  }
});

// node_modules/core-js/internals/array-reduce.js
var require_array_reduce = __commonJS({
  "node_modules/core-js/internals/array-reduce.js"(exports, module) {
    "use strict";
    var aCallable = require_a_callable();
    var toObject = require_to_object();
    var IndexedObject = require_indexed_object();
    var lengthOfArrayLike = require_length_of_array_like();
    var $TypeError = TypeError;
    var REDUCE_EMPTY = "Reduce of empty array with no initial value";
    var createMethod = function(IS_RIGHT) {
      return function(that, callbackfn, argumentsLength, memo) {
        var O = toObject(that);
        var self2 = IndexedObject(O);
        var length = lengthOfArrayLike(O);
        aCallable(callbackfn);
        if (length === 0 && argumentsLength < 2) throw new $TypeError(REDUCE_EMPTY);
        var index = IS_RIGHT ? length - 1 : 0;
        var i = IS_RIGHT ? -1 : 1;
        if (argumentsLength < 2) while (true) {
          if (index in self2) {
            memo = self2[index];
            index += i;
            break;
          }
          index += i;
          if (IS_RIGHT ? index < 0 : length <= index) {
            throw new $TypeError(REDUCE_EMPTY);
          }
        }
        for (; IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self2) {
          memo = callbackfn(memo, self2[index], index, O);
        }
        return memo;
      };
    };
    module.exports = {
      // `Array.prototype.reduce` method
      // https://tc39.es/ecma262/#sec-array.prototype.reduce
      left: createMethod(false),
      // `Array.prototype.reduceRight` method
      // https://tc39.es/ecma262/#sec-array.prototype.reduceright
      right: createMethod(true)
    };
  }
});

// node_modules/core-js/modules/es.typed-array.reduce.js
var require_es_typed_array_reduce = __commonJS({
  "node_modules/core-js/modules/es.typed-array.reduce.js"() {
    "use strict";
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var $reduce = require_array_reduce().left;
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod("reduce", function reduce(callbackfn) {
      var length = arguments.length;
      return $reduce(aTypedArray(this), callbackfn, length, length > 1 ? arguments[1] : void 0);
    });
  }
});

// node_modules/core-js/modules/es.typed-array.reduce-right.js
var require_es_typed_array_reduce_right = __commonJS({
  "node_modules/core-js/modules/es.typed-array.reduce-right.js"() {
    "use strict";
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var $reduceRight = require_array_reduce().right;
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod("reduceRight", function reduceRight(callbackfn) {
      var length = arguments.length;
      return $reduceRight(aTypedArray(this), callbackfn, length, length > 1 ? arguments[1] : void 0);
    });
  }
});

// node_modules/core-js/modules/es.typed-array.reverse.js
var require_es_typed_array_reverse = __commonJS({
  "node_modules/core-js/modules/es.typed-array.reverse.js"() {
    "use strict";
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    var floor = Math.floor;
    exportTypedArrayMethod("reverse", function reverse() {
      var that = this;
      var length = aTypedArray(that).length;
      var middle = floor(length / 2);
      var index = 0;
      var value;
      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      }
      return that;
    });
  }
});

// node_modules/core-js/modules/es.typed-array.set.js
var require_es_typed_array_set = __commonJS({
  "node_modules/core-js/modules/es.typed-array.set.js"() {
    "use strict";
    var globalThis2 = require_global_this();
    var call = require_function_call();
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var lengthOfArrayLike = require_length_of_array_like();
    var toOffset = require_to_offset();
    var toIndexedObject = require_to_object();
    var fails = require_fails();
    var RangeError2 = globalThis2.RangeError;
    var Int8Array2 = globalThis2.Int8Array;
    var Int8ArrayPrototype = Int8Array2 && Int8Array2.prototype;
    var $set = Int8ArrayPrototype && Int8ArrayPrototype.set;
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    var WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS = !fails(function() {
      var array = new Uint8ClampedArray(2);
      call($set, array, { length: 1, 0: 3 }, 1);
      return array[1] !== 3;
    });
    var TO_OBJECT_BUG = WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS && ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS && fails(function() {
      var array = new Int8Array2(2);
      array.set(1);
      array.set("2", 1);
      return array[0] !== 0 || array[1] !== 2;
    });
    exportTypedArrayMethod("set", function set(arrayLike) {
      aTypedArray(this);
      var offset = toOffset(arguments.length > 1 ? arguments[1] : void 0, 1);
      var src = toIndexedObject(arrayLike);
      if (WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS) return call($set, this, src, offset);
      var length = this.length;
      var len = lengthOfArrayLike(src);
      var index = 0;
      if (len + offset > length) throw new RangeError2("Wrong length");
      while (index < len) this[offset + index] = src[index++];
    }, !WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS || TO_OBJECT_BUG);
  }
});

// node_modules/core-js/modules/es.typed-array.slice.js
var require_es_typed_array_slice = __commonJS({
  "node_modules/core-js/modules/es.typed-array.slice.js"() {
    "use strict";
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var fails = require_fails();
    var arraySlice = require_array_slice();
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    var FORCED = fails(function() {
      new Int8Array(1).slice();
    });
    exportTypedArrayMethod("slice", function slice(start, end2) {
      var list = arraySlice(aTypedArray(this), start, end2);
      var C = getTypedArrayConstructor(this);
      var index = 0;
      var length = list.length;
      var result = new C(length);
      while (length > index) result[index] = list[index++];
      return result;
    }, FORCED);
  }
});

// node_modules/core-js/modules/es.typed-array.some.js
var require_es_typed_array_some = __commonJS({
  "node_modules/core-js/modules/es.typed-array.some.js"() {
    "use strict";
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var $some = require_array_iteration().some;
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod("some", function some(callbackfn) {
      return $some(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    });
  }
});

// node_modules/core-js/internals/array-sort.js
var require_array_sort = __commonJS({
  "node_modules/core-js/internals/array-sort.js"(exports, module) {
    "use strict";
    var arraySlice = require_array_slice();
    var floor = Math.floor;
    var sort = function(array, comparefn) {
      var length = array.length;
      if (length < 8) {
        var i = 1;
        var element, j;
        while (i < length) {
          j = i;
          element = array[i];
          while (j && comparefn(array[j - 1], element) > 0) {
            array[j] = array[--j];
          }
          if (j !== i++) array[j] = element;
        }
      } else {
        var middle = floor(length / 2);
        var left = sort(arraySlice(array, 0, middle), comparefn);
        var right = sort(arraySlice(array, middle), comparefn);
        var llength = left.length;
        var rlength = right.length;
        var lindex = 0;
        var rindex = 0;
        while (lindex < llength || rindex < rlength) {
          array[lindex + rindex] = lindex < llength && rindex < rlength ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++] : lindex < llength ? left[lindex++] : right[rindex++];
        }
      }
      return array;
    };
    module.exports = sort;
  }
});

// node_modules/core-js/internals/environment-ff-version.js
var require_environment_ff_version = __commonJS({
  "node_modules/core-js/internals/environment-ff-version.js"(exports, module) {
    "use strict";
    var userAgent = require_environment_user_agent();
    var firefox = userAgent.match(/firefox\/(\d+)/i);
    module.exports = !!firefox && +firefox[1];
  }
});

// node_modules/core-js/internals/environment-is-ie-or-edge.js
var require_environment_is_ie_or_edge = __commonJS({
  "node_modules/core-js/internals/environment-is-ie-or-edge.js"(exports, module) {
    "use strict";
    var UA = require_environment_user_agent();
    module.exports = /MSIE|Trident/.test(UA);
  }
});

// node_modules/core-js/internals/environment-webkit-version.js
var require_environment_webkit_version = __commonJS({
  "node_modules/core-js/internals/environment-webkit-version.js"(exports, module) {
    "use strict";
    var userAgent = require_environment_user_agent();
    var webkit = userAgent.match(/AppleWebKit\/(\d+)\./);
    module.exports = !!webkit && +webkit[1];
  }
});

// node_modules/core-js/modules/es.typed-array.sort.js
var require_es_typed_array_sort = __commonJS({
  "node_modules/core-js/modules/es.typed-array.sort.js"() {
    "use strict";
    var globalThis2 = require_global_this();
    var uncurryThis = require_function_uncurry_this_clause();
    var fails = require_fails();
    var aCallable = require_a_callable();
    var internalSort = require_array_sort();
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var FF = require_environment_ff_version();
    var IE_OR_EDGE = require_environment_is_ie_or_edge();
    var V8 = require_environment_v8_version();
    var WEBKIT = require_environment_webkit_version();
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    var Uint16Array = globalThis2.Uint16Array;
    var nativeSort = Uint16Array && uncurryThis(Uint16Array.prototype.sort);
    var ACCEPT_INCORRECT_ARGUMENTS = !!nativeSort && !(fails(function() {
      nativeSort(new Uint16Array(2), null);
    }) && fails(function() {
      nativeSort(new Uint16Array(2), {});
    }));
    var STABLE_SORT = !!nativeSort && !fails(function() {
      if (V8) return V8 < 74;
      if (FF) return FF < 67;
      if (IE_OR_EDGE) return true;
      if (WEBKIT) return WEBKIT < 602;
      var array = new Uint16Array(516);
      var expected = Array(516);
      var index, mod;
      for (index = 0; index < 516; index++) {
        mod = index % 4;
        array[index] = 515 - index;
        expected[index] = index - 2 * mod + 3;
      }
      nativeSort(array, function(a, b) {
        return (a / 4 | 0) - (b / 4 | 0);
      });
      for (index = 0; index < 516; index++) {
        if (array[index] !== expected[index]) return true;
      }
    });
    var getSortCompare = function(comparefn) {
      return function(x, y) {
        if (comparefn !== void 0) return +comparefn(x, y) || 0;
        if (y !== y) return -1;
        if (x !== x) return 1;
        if (x === 0 && y === 0) return 1 / x > 0 && 1 / y < 0 ? 1 : -1;
        return x > y;
      };
    };
    exportTypedArrayMethod("sort", function sort(comparefn) {
      if (comparefn !== void 0) aCallable(comparefn);
      if (STABLE_SORT) return nativeSort(this, comparefn);
      return internalSort(aTypedArray(this), getSortCompare(comparefn));
    }, !STABLE_SORT || ACCEPT_INCORRECT_ARGUMENTS);
  }
});

// node_modules/core-js/modules/es.typed-array.subarray.js
var require_es_typed_array_subarray = __commonJS({
  "node_modules/core-js/modules/es.typed-array.subarray.js"() {
    "use strict";
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var toLength = require_to_length();
    var toAbsoluteIndex = require_to_absolute_index();
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod("subarray", function subarray(begin, end2) {
      var O = aTypedArray(this);
      var length = O.length;
      var beginIndex = toAbsoluteIndex(begin, length);
      var C = getTypedArrayConstructor(O);
      return new C(
        O.buffer,
        O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT,
        toLength((end2 === void 0 ? length : toAbsoluteIndex(end2, length)) - beginIndex)
      );
    });
  }
});

// node_modules/core-js/modules/es.typed-array.to-locale-string.js
var require_es_typed_array_to_locale_string = __commonJS({
  "node_modules/core-js/modules/es.typed-array.to-locale-string.js"() {
    "use strict";
    var globalThis2 = require_global_this();
    var apply = require_function_apply();
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var fails = require_fails();
    var arraySlice = require_array_slice();
    var Int8Array2 = globalThis2.Int8Array;
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    var $toLocaleString = [].toLocaleString;
    var TO_LOCALE_STRING_BUG = !!Int8Array2 && fails(function() {
      $toLocaleString.call(new Int8Array2(1));
    });
    var FORCED = fails(function() {
      return [1, 2].toLocaleString() !== new Int8Array2([1, 2]).toLocaleString();
    }) || !fails(function() {
      Int8Array2.prototype.toLocaleString.call([1, 2]);
    });
    exportTypedArrayMethod("toLocaleString", function toLocaleString() {
      return apply(
        $toLocaleString,
        TO_LOCALE_STRING_BUG ? arraySlice(aTypedArray(this)) : aTypedArray(this),
        arraySlice(arguments)
      );
    }, FORCED);
  }
});

// node_modules/core-js/modules/es.typed-array.to-string.js
var require_es_typed_array_to_string = __commonJS({
  "node_modules/core-js/modules/es.typed-array.to-string.js"() {
    "use strict";
    var exportTypedArrayMethod = require_array_buffer_view_core().exportTypedArrayMethod;
    var fails = require_fails();
    var globalThis2 = require_global_this();
    var uncurryThis = require_function_uncurry_this();
    var Uint8Array2 = globalThis2.Uint8Array;
    var Uint8ArrayPrototype = Uint8Array2 && Uint8Array2.prototype || {};
    var arrayToString = [].toString;
    var join = uncurryThis([].join);
    if (fails(function() {
      arrayToString.call({});
    })) {
      arrayToString = function toString() {
        return join(this);
      };
    }
    var IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString !== arrayToString;
    exportTypedArrayMethod("toString", arrayToString, IS_NOT_ARRAY_METHOD);
  }
});

// node_modules/core-js/modules/es.string.split.js
var require_es_string_split = __commonJS({
  "node_modules/core-js/modules/es.string.split.js"() {
    "use strict";
    var call = require_function_call();
    var uncurryThis = require_function_uncurry_this();
    var fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
    var anObject = require_an_object();
    var isObject = require_is_object();
    var requireObjectCoercible = require_require_object_coercible();
    var speciesConstructor = require_species_constructor();
    var advanceStringIndex = require_advance_string_index();
    var toLength = require_to_length();
    var toString = require_to_string();
    var getMethod = require_get_method();
    var regExpExec = require_regexp_exec_abstract();
    var stickyHelpers = require_regexp_sticky_helpers();
    var fails = require_fails();
    var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
    var MAX_UINT32 = 4294967295;
    var min = Math.min;
    var push = uncurryThis([].push);
    var stringSlice = uncurryThis("".slice);
    var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function() {
      var re = /(?:)/;
      var originalExec = re.exec;
      re.exec = function() {
        return originalExec.apply(this, arguments);
      };
      var result = "ab".split(re);
      return result.length !== 2 || result[0] !== "a" || result[1] !== "b";
    });
    var BUGGY = "abbc".split(/(b)*/)[1] === "c" || // eslint-disable-next-line regexp/no-empty-group -- required for testing
    "test".split(/(?:)/, -1).length !== 4 || "ab".split(/(?:ab)*/).length !== 2 || ".".split(/(.?)(.?)/).length !== 4 || // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing
    ".".split(/()()/).length > 1 || "".split(/.?/).length;
    fixRegExpWellKnownSymbolLogic("split", function(SPLIT, nativeSplit, maybeCallNative) {
      var internalSplit = "0".split(void 0, 0).length ? function(separator, limit) {
        return separator === void 0 && limit === 0 ? [] : call(nativeSplit, this, separator, limit);
      } : nativeSplit;
      return [
        // `String.prototype.split` method
        // https://tc39.es/ecma262/#sec-string.prototype.split
        function split(separator, limit) {
          var O = requireObjectCoercible(this);
          var splitter = isObject(separator) ? getMethod(separator, SPLIT) : void 0;
          return splitter ? call(splitter, separator, O, limit) : call(internalSplit, toString(O), separator, limit);
        },
        // `RegExp.prototype[@@split]` method
        // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
        //
        // NOTE: This cannot be properly polyfilled in engines that don't support
        // the 'y' flag.
        function(string, limit) {
          var rx = anObject(this);
          var S = toString(string);
          if (!BUGGY) {
            var res = maybeCallNative(internalSplit, rx, S, limit, internalSplit !== nativeSplit);
            if (res.done) return res.value;
          }
          var C = speciesConstructor(rx, RegExp);
          var unicodeMatching = rx.unicode;
          var flags = (rx.ignoreCase ? "i" : "") + (rx.multiline ? "m" : "") + (rx.unicode ? "u" : "") + (UNSUPPORTED_Y ? "g" : "y");
          var splitter = new C(UNSUPPORTED_Y ? "^(?:" + rx.source + ")" : rx, flags);
          var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
          if (lim === 0) return [];
          if (S.length === 0) return regExpExec(splitter, S) === null ? [S] : [];
          var p = 0;
          var q = 0;
          var A = [];
          while (q < S.length) {
            splitter.lastIndex = UNSUPPORTED_Y ? 0 : q;
            var z = regExpExec(splitter, UNSUPPORTED_Y ? stringSlice(S, q) : S);
            var e;
            if (z === null || (e = min(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q : 0)), S.length)) === p) {
              q = advanceStringIndex(S, q, unicodeMatching);
            } else {
              push(A, stringSlice(S, p, q));
              if (A.length === lim) return A;
              for (var i = 1; i <= z.length - 1; i++) {
                push(A, z[i]);
                if (A.length === lim) return A;
              }
              q = p = e;
            }
          }
          push(A, stringSlice(S, p));
          return A;
        }
      ];
    }, BUGGY || !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);
  }
});

// node_modules/@babel/runtime/helpers/isNativeFunction.js
var require_isNativeFunction = __commonJS({
  "node_modules/@babel/runtime/helpers/isNativeFunction.js"(exports, module) {
    function _isNativeFunction(t) {
      try {
        return -1 !== Function.toString.call(t).indexOf("[native code]");
      } catch (n) {
        return "function" == typeof t;
      }
    }
    module.exports = _isNativeFunction, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js
var require_isNativeReflectConstruct = __commonJS({
  "node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js"(exports, module) {
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (module.exports = _isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports)();
    }
    module.exports = _isNativeReflectConstruct, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/construct.js
var require_construct = __commonJS({
  "node_modules/@babel/runtime/helpers/construct.js"(exports, module) {
    var isNativeReflectConstruct = require_isNativeReflectConstruct();
    var setPrototypeOf = require_setPrototypeOf();
    function _construct(t, e, r) {
      if (isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
      var o = [null];
      o.push.apply(o, e);
      var p = new (t.bind.apply(t, o))();
      return r && setPrototypeOf(p, r.prototype), p;
    }
    module.exports = _construct, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/wrapNativeSuper.js
var require_wrapNativeSuper = __commonJS({
  "node_modules/@babel/runtime/helpers/wrapNativeSuper.js"(exports, module) {
    var getPrototypeOf = require_getPrototypeOf();
    var setPrototypeOf = require_setPrototypeOf();
    var isNativeFunction = require_isNativeFunction();
    var construct = require_construct();
    function _wrapNativeSuper(t) {
      var r = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
      return module.exports = _wrapNativeSuper = function _wrapNativeSuper2(t2) {
        if (null === t2 || !isNativeFunction(t2)) return t2;
        if ("function" != typeof t2) throw new TypeError("Super expression must either be null or a function");
        if (void 0 !== r) {
          if (r.has(t2)) return r.get(t2);
          r.set(t2, Wrapper);
        }
        function Wrapper() {
          return construct(t2, arguments, getPrototypeOf(this).constructor);
        }
        return Wrapper.prototype = Object.create(t2.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        }), setPrototypeOf(Wrapper, t2);
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _wrapNativeSuper(t);
    }
    module.exports = _wrapNativeSuper, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/platform/platform.js
var require_platform = __commonJS({
  "node_modules/platform/platform.js"(exports, module) {
    (function() {
      "use strict";
      var objectTypes = {
        "function": true,
        "object": true
      };
      var root = objectTypes[typeof window] && window || this;
      var oldRoot = root;
      var freeExports = objectTypes[typeof exports] && exports;
      var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
      var freeGlobal = freeExports && freeModule && typeof global == "object" && global;
      if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
        root = freeGlobal;
      }
      var maxSafeInteger = Math.pow(2, 53) - 1;
      var reOpera = /\bOpera/;
      var thisBinding = this;
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var toString = objectProto.toString;
      function capitalize(string) {
        string = String(string);
        return string.charAt(0).toUpperCase() + string.slice(1);
      }
      function cleanupOS(os, pattern2, label) {
        var data = {
          "10.0": "10",
          "6.4": "10 Technical Preview",
          "6.3": "8.1",
          "6.2": "8",
          "6.1": "Server 2008 R2 / 7",
          "6.0": "Server 2008 / Vista",
          "5.2": "Server 2003 / XP 64-bit",
          "5.1": "XP",
          "5.01": "2000 SP1",
          "5.0": "2000",
          "4.0": "NT",
          "4.90": "ME"
        };
        if (pattern2 && label && /^Win/i.test(os) && !/^Windows Phone /i.test(os) && (data = data[/[\d.]+$/.exec(os)])) {
          os = "Windows " + data;
        }
        os = String(os);
        if (pattern2 && label) {
          os = os.replace(RegExp(pattern2, "i"), label);
        }
        os = format(
          os.replace(/ ce$/i, " CE").replace(/\bhpw/i, "web").replace(/\bMacintosh\b/, "Mac OS").replace(/_PowerPC\b/i, " OS").replace(/\b(OS X) [^ \d]+/i, "$1").replace(/\bMac (OS X)\b/, "$1").replace(/\/(\d)/, " $1").replace(/_/g, ".").replace(/(?: BePC|[ .]*fc[ \d.]+)$/i, "").replace(/\bx86\.64\b/gi, "x86_64").replace(/\b(Windows Phone) OS\b/, "$1").replace(/\b(Chrome OS \w+) [\d.]+\b/, "$1").split(" on ")[0]
        );
        return os;
      }
      function each(object, callback) {
        var index = -1, length = object ? object.length : 0;
        if (typeof length == "number" && length > -1 && length <= maxSafeInteger) {
          while (++index < length) {
            callback(object[index], index, object);
          }
        } else {
          forOwn(object, callback);
        }
      }
      function format(string) {
        string = trim(string);
        return /^(?:webOS|i(?:OS|P))/.test(string) ? string : capitalize(string);
      }
      function forOwn(object, callback) {
        for (var key in object) {
          if (hasOwnProperty.call(object, key)) {
            callback(object[key], key, object);
          }
        }
      }
      function getClassOf(value) {
        return value == null ? capitalize(value) : toString.call(value).slice(8, -1);
      }
      function isHostType(object, property) {
        var type = object != null ? typeof object[property] : "number";
        return !/^(?:boolean|number|string|undefined)$/.test(type) && (type == "object" ? !!object[property] : true);
      }
      function qualify(string) {
        return String(string).replace(/([ -])(?!$)/g, "$1?");
      }
      function reduce(array, callback) {
        var accumulator = null;
        each(array, function(value, index) {
          accumulator = callback(accumulator, value, index, array);
        });
        return accumulator;
      }
      function trim(string) {
        return String(string).replace(/^ +| +$/g, "");
      }
      function parse2(ua) {
        var context = root;
        var isCustomContext = ua && typeof ua == "object" && getClassOf(ua) != "String";
        if (isCustomContext) {
          context = ua;
          ua = null;
        }
        var nav = context.navigator || {};
        var userAgent = nav.userAgent || "";
        ua || (ua = userAgent);
        var isModuleScope = isCustomContext || thisBinding == oldRoot;
        var likeChrome = isCustomContext ? !!nav.likeChrome : /\bChrome\b/.test(ua) && !/internal|\n/i.test(toString.toString());
        var objectClass = "Object", airRuntimeClass = isCustomContext ? objectClass : "ScriptBridgingProxyObject", enviroClass = isCustomContext ? objectClass : "Environment", javaClass = isCustomContext && context.java ? "JavaPackage" : getClassOf(context.java), phantomClass = isCustomContext ? objectClass : "RuntimeObject";
        var java = /\bJava/.test(javaClass) && context.java;
        var rhino = java && getClassOf(context.environment) == enviroClass;
        var alpha = java ? "a" : "Î±";
        var beta = java ? "b" : "Î²";
        var doc = context.document || {};
        var opera = context.operamini || context.opera;
        var operaClass = reOpera.test(operaClass = isCustomContext && opera ? opera["[[Class]]"] : getClassOf(opera)) ? operaClass : opera = null;
        var data;
        var arch = ua;
        var description = [];
        var prerelease = null;
        var useFeatures = ua == userAgent;
        var version = useFeatures && opera && typeof opera.version == "function" && opera.version();
        var isSpecialCasedOS;
        var layout = getLayout([
          { "label": "EdgeHTML", "pattern": "Edge" },
          "Trident",
          { "label": "WebKit", "pattern": "AppleWebKit" },
          "iCab",
          "Presto",
          "NetFront",
          "Tasman",
          "KHTML",
          "Gecko"
        ]);
        var name = getName([
          "Adobe AIR",
          "Arora",
          "Avant Browser",
          "Breach",
          "Camino",
          "Electron",
          "Epiphany",
          "Fennec",
          "Flock",
          "Galeon",
          "GreenBrowser",
          "iCab",
          "Iceweasel",
          "K-Meleon",
          "Konqueror",
          "Lunascape",
          "Maxthon",
          { "label": "Microsoft Edge", "pattern": "(?:Edge|Edg|EdgA|EdgiOS)" },
          "Midori",
          "Nook Browser",
          "PaleMoon",
          "PhantomJS",
          "Raven",
          "Rekonq",
          "RockMelt",
          { "label": "Samsung Internet", "pattern": "SamsungBrowser" },
          "SeaMonkey",
          { "label": "Silk", "pattern": "(?:Cloud9|Silk-Accelerated)" },
          "Sleipnir",
          "SlimBrowser",
          { "label": "SRWare Iron", "pattern": "Iron" },
          "Sunrise",
          "Swiftfox",
          "Vivaldi",
          "Waterfox",
          "WebPositive",
          { "label": "Yandex Browser", "pattern": "YaBrowser" },
          { "label": "UC Browser", "pattern": "UCBrowser" },
          "Opera Mini",
          { "label": "Opera Mini", "pattern": "OPiOS" },
          "Opera",
          { "label": "Opera", "pattern": "OPR" },
          "Chromium",
          "Chrome",
          { "label": "Chrome", "pattern": "(?:HeadlessChrome)" },
          { "label": "Chrome Mobile", "pattern": "(?:CriOS|CrMo)" },
          { "label": "Firefox", "pattern": "(?:Firefox|Minefield)" },
          { "label": "Firefox for iOS", "pattern": "FxiOS" },
          { "label": "IE", "pattern": "IEMobile" },
          { "label": "IE", "pattern": "MSIE" },
          "Safari"
        ]);
        var product = getProduct([
          { "label": "BlackBerry", "pattern": "BB10" },
          "BlackBerry",
          { "label": "Galaxy S", "pattern": "GT-I9000" },
          { "label": "Galaxy S2", "pattern": "GT-I9100" },
          { "label": "Galaxy S3", "pattern": "GT-I9300" },
          { "label": "Galaxy S4", "pattern": "GT-I9500" },
          { "label": "Galaxy S5", "pattern": "SM-G900" },
          { "label": "Galaxy S6", "pattern": "SM-G920" },
          { "label": "Galaxy S6 Edge", "pattern": "SM-G925" },
          { "label": "Galaxy S7", "pattern": "SM-G930" },
          { "label": "Galaxy S7 Edge", "pattern": "SM-G935" },
          "Google TV",
          "Lumia",
          "iPad",
          "iPod",
          "iPhone",
          "Kindle",
          { "label": "Kindle Fire", "pattern": "(?:Cloud9|Silk-Accelerated)" },
          "Nexus",
          "Nook",
          "PlayBook",
          "PlayStation Vita",
          "PlayStation",
          "TouchPad",
          "Transformer",
          { "label": "Wii U", "pattern": "WiiU" },
          "Wii",
          "Xbox One",
          { "label": "Xbox 360", "pattern": "Xbox" },
          "Xoom"
        ]);
        var manufacturer = getManufacturer({
          "Apple": { "iPad": 1, "iPhone": 1, "iPod": 1 },
          "Alcatel": {},
          "Archos": {},
          "Amazon": { "Kindle": 1, "Kindle Fire": 1 },
          "Asus": { "Transformer": 1 },
          "Barnes & Noble": { "Nook": 1 },
          "BlackBerry": { "PlayBook": 1 },
          "Google": { "Google TV": 1, "Nexus": 1 },
          "HP": { "TouchPad": 1 },
          "HTC": {},
          "Huawei": {},
          "Lenovo": {},
          "LG": {},
          "Microsoft": { "Xbox": 1, "Xbox One": 1 },
          "Motorola": { "Xoom": 1 },
          "Nintendo": { "Wii U": 1, "Wii": 1 },
          "Nokia": { "Lumia": 1 },
          "Oppo": {},
          "Samsung": { "Galaxy S": 1, "Galaxy S2": 1, "Galaxy S3": 1, "Galaxy S4": 1 },
          "Sony": { "PlayStation": 1, "PlayStation Vita": 1 },
          "Xiaomi": { "Mi": 1, "Redmi": 1 }
        });
        var os = getOS([
          "Windows Phone",
          "KaiOS",
          "Android",
          "CentOS",
          { "label": "Chrome OS", "pattern": "CrOS" },
          "Debian",
          { "label": "DragonFly BSD", "pattern": "DragonFly" },
          "Fedora",
          "FreeBSD",
          "Gentoo",
          "Haiku",
          "Kubuntu",
          "Linux Mint",
          "OpenBSD",
          "Red Hat",
          "SuSE",
          "Ubuntu",
          "Xubuntu",
          "Cygwin",
          "Symbian OS",
          "hpwOS",
          "webOS ",
          "webOS",
          "Tablet OS",
          "Tizen",
          "Linux",
          "Mac OS X",
          "Macintosh",
          "Mac",
          "Windows 98;",
          "Windows "
        ]);
        function getLayout(guesses) {
          return reduce(guesses, function(result, guess) {
            return result || RegExp("\\b" + (guess.pattern || qualify(guess)) + "\\b", "i").exec(ua) && (guess.label || guess);
          });
        }
        function getManufacturer(guesses) {
          return reduce(guesses, function(result, value, key) {
            return result || (value[product] || value[/^[a-z]+(?: +[a-z]+\b)*/i.exec(product)] || RegExp("\\b" + qualify(key) + "(?:\\b|\\w*\\d)", "i").exec(ua)) && key;
          });
        }
        function getName(guesses) {
          return reduce(guesses, function(result, guess) {
            return result || RegExp("\\b" + (guess.pattern || qualify(guess)) + "\\b", "i").exec(ua) && (guess.label || guess);
          });
        }
        function getOS(guesses) {
          return reduce(guesses, function(result, guess) {
            var pattern2 = guess.pattern || qualify(guess);
            if (!result && (result = RegExp("\\b" + pattern2 + "(?:/[\\d.]+|[ \\w.]*)", "i").exec(ua))) {
              result = cleanupOS(result, pattern2, guess.label || guess);
            }
            return result;
          });
        }
        function getProduct(guesses) {
          return reduce(guesses, function(result, guess) {
            var pattern2 = guess.pattern || qualify(guess);
            if (!result && (result = RegExp("\\b" + pattern2 + " *\\d+[.\\w_]*", "i").exec(ua) || RegExp("\\b" + pattern2 + " *\\w+-[\\w]*", "i").exec(ua) || RegExp("\\b" + pattern2 + "(?:; *(?:[a-z]+[_-])?[a-z]+\\d+|[^ ();-]*)", "i").exec(ua))) {
              if ((result = String(guess.label && !RegExp(pattern2, "i").test(guess.label) ? guess.label : result).split("/"))[1] && !/[\d.]+/.test(result[0])) {
                result[0] += " " + result[1];
              }
              guess = guess.label || guess;
              result = format(result[0].replace(RegExp(pattern2, "i"), guess).replace(RegExp("; *(?:" + guess + "[_-])?", "i"), " ").replace(RegExp("(" + guess + ")[-_.]?(\\w)", "i"), "$1 $2"));
            }
            return result;
          });
        }
        function getVersion(patterns) {
          return reduce(patterns, function(result, pattern2) {
            return result || (RegExp(pattern2 + "(?:-[\\d.]+/|(?: for [\\w-]+)?[ /-])([\\d.]+[^ ();/_-]*)", "i").exec(ua) || 0)[1] || null;
          });
        }
        function toStringPlatform() {
          return this.description || "";
        }
        layout && (layout = [layout]);
        if (/\bAndroid\b/.test(os) && !product && (data = /\bAndroid[^;]*;(.*?)(?:Build|\) AppleWebKit)\b/i.exec(ua))) {
          product = trim(data[1]).replace(/^[a-z]{2}-[a-z]{2};\s*/i, "") || null;
        }
        if (manufacturer && !product) {
          product = getProduct([manufacturer]);
        } else if (manufacturer && product) {
          product = product.replace(RegExp("^(" + qualify(manufacturer) + ")[-_.\\s]", "i"), manufacturer + " ").replace(RegExp("^(" + qualify(manufacturer) + ")[-_.]?(\\w)", "i"), manufacturer + " $2");
        }
        if (data = /\bGoogle TV\b/.exec(product)) {
          product = data[0];
        }
        if (/\bSimulator\b/i.test(ua)) {
          product = (product ? product + " " : "") + "Simulator";
        }
        if (name == "Opera Mini" && /\bOPiOS\b/.test(ua)) {
          description.push("running in Turbo/Uncompressed mode");
        }
        if (name == "IE" && /\blike iPhone OS\b/.test(ua)) {
          data = parse2(ua.replace(/like iPhone OS/, ""));
          manufacturer = data.manufacturer;
          product = data.product;
        } else if (/^iP/.test(product)) {
          name || (name = "Safari");
          os = "iOS" + ((data = / OS ([\d_]+)/i.exec(ua)) ? " " + data[1].replace(/_/g, ".") : "");
        } else if (name == "Konqueror" && /^Linux\b/i.test(os)) {
          os = "Kubuntu";
        } else if (manufacturer && manufacturer != "Google" && (/Chrome/.test(name) && !/\bMobile Safari\b/i.test(ua) || /\bVita\b/.test(product)) || /\bAndroid\b/.test(os) && /^Chrome/.test(name) && /\bVersion\//i.test(ua)) {
          name = "Android Browser";
          os = /\bAndroid\b/.test(os) ? os : "Android";
        } else if (name == "Silk") {
          if (!/\bMobi/i.test(ua)) {
            os = "Android";
            description.unshift("desktop mode");
          }
          if (/Accelerated *= *true/i.test(ua)) {
            description.unshift("accelerated");
          }
        } else if (name == "UC Browser" && /\bUCWEB\b/.test(ua)) {
          description.push("speed mode");
        } else if (name == "PaleMoon" && (data = /\bFirefox\/([\d.]+)\b/.exec(ua))) {
          description.push("identifying as Firefox " + data[1]);
        } else if (name == "Firefox" && (data = /\b(Mobile|Tablet|TV)\b/i.exec(ua))) {
          os || (os = "Firefox OS");
          product || (product = data[1]);
        } else if (!name || (data = !/\bMinefield\b/i.test(ua) && /\b(?:Firefox|Safari)\b/.exec(name))) {
          if (name && !product && /[\/,]|^[^(]+?\)/.test(ua.slice(ua.indexOf(data + "/") + 8))) {
            name = null;
          }
          if ((data = product || manufacturer || os) && (product || manufacturer || /\b(?:Android|Symbian OS|Tablet OS|webOS)\b/.test(os))) {
            name = /[a-z]+(?: Hat)?/i.exec(/\bAndroid\b/.test(os) ? os : data) + " Browser";
          }
        } else if (name == "Electron" && (data = (/\bChrome\/([\d.]+)\b/.exec(ua) || 0)[1])) {
          description.push("Chromium " + data);
        }
        if (!version) {
          version = getVersion([
            "(?:Cloud9|CriOS|CrMo|Edge|Edg|EdgA|EdgiOS|FxiOS|HeadlessChrome|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|SamsungBrowser|Silk(?!/[\\d.]+$)|UCBrowser|YaBrowser)",
            "Version",
            qualify(name),
            "(?:Firefox|Minefield|NetFront)"
          ]);
        }
        if (data = layout == "iCab" && parseFloat(version) > 3 && "WebKit" || /\bOpera\b/.test(name) && (/\bOPR\b/.test(ua) ? "Blink" : "Presto") || /\b(?:Midori|Nook|Safari)\b/i.test(ua) && !/^(?:Trident|EdgeHTML)$/.test(layout) && "WebKit" || !layout && /\bMSIE\b/i.test(ua) && (os == "Mac OS" ? "Tasman" : "Trident") || layout == "WebKit" && /\bPlayStation\b(?! Vita\b)/i.test(name) && "NetFront") {
          layout = [data];
        }
        if (name == "IE" && (data = (/; *(?:XBLWP|ZuneWP)(\d+)/i.exec(ua) || 0)[1])) {
          name += " Mobile";
          os = "Windows Phone " + (/\+$/.test(data) ? data : data + ".x");
          description.unshift("desktop mode");
        } else if (/\bWPDesktop\b/i.test(ua)) {
          name = "IE Mobile";
          os = "Windows Phone 8.x";
          description.unshift("desktop mode");
          version || (version = (/\brv:([\d.]+)/.exec(ua) || 0)[1]);
        } else if (name != "IE" && layout == "Trident" && (data = /\brv:([\d.]+)/.exec(ua))) {
          if (name) {
            description.push("identifying as " + name + (version ? " " + version : ""));
          }
          name = "IE";
          version = data[1];
        }
        if (useFeatures) {
          if (isHostType(context, "global")) {
            if (java) {
              data = java.lang.System;
              arch = data.getProperty("os.arch");
              os = os || data.getProperty("os.name") + " " + data.getProperty("os.version");
            }
            if (rhino) {
              try {
                version = context.require("ringo/engine").version.join(".");
                name = "RingoJS";
              } catch (e) {
                if ((data = context.system) && data.global.system == context.system) {
                  name = "Narwhal";
                  os || (os = data[0].os || null);
                }
              }
              if (!name) {
                name = "Rhino";
              }
            } else if (typeof context.process == "object" && !context.process.browser && (data = context.process)) {
              if (typeof data.versions == "object") {
                if (typeof data.versions.electron == "string") {
                  description.push("Node " + data.versions.node);
                  name = "Electron";
                  version = data.versions.electron;
                } else if (typeof data.versions.nw == "string") {
                  description.push("Chromium " + version, "Node " + data.versions.node);
                  name = "NW.js";
                  version = data.versions.nw;
                }
              }
              if (!name) {
                name = "Node.js";
                arch = data.arch;
                os = data.platform;
                version = /[\d.]+/.exec(data.version);
                version = version ? version[0] : null;
              }
            }
          } else if (getClassOf(data = context.runtime) == airRuntimeClass) {
            name = "Adobe AIR";
            os = data.flash.system.Capabilities.os;
          } else if (getClassOf(data = context.phantom) == phantomClass) {
            name = "PhantomJS";
            version = (data = data.version || null) && data.major + "." + data.minor + "." + data.patch;
          } else if (typeof doc.documentMode == "number" && (data = /\bTrident\/(\d+)/i.exec(ua))) {
            version = [version, doc.documentMode];
            if ((data = +data[1] + 4) != version[1]) {
              description.push("IE " + version[1] + " mode");
              layout && (layout[1] = "");
              version[1] = data;
            }
            version = name == "IE" ? String(version[1].toFixed(1)) : version[0];
          } else if (typeof doc.documentMode == "number" && /^(?:Chrome|Firefox)\b/.test(name)) {
            description.push("masking as " + name + " " + version);
            name = "IE";
            version = "11.0";
            layout = ["Trident"];
            os = "Windows";
          }
          os = os && format(os);
        }
        if (version && (data = /(?:[ab]|dp|pre|[ab]\d+pre)(?:\d+\+?)?$/i.exec(version) || /(?:alpha|beta)(?: ?\d)?/i.exec(ua + ";" + (useFeatures && nav.appMinorVersion)) || /\bMinefield\b/i.test(ua) && "a")) {
          prerelease = /b/i.test(data) ? "beta" : "alpha";
          version = version.replace(RegExp(data + "\\+?$"), "") + (prerelease == "beta" ? beta : alpha) + (/\d+\+?/.exec(data) || "");
        }
        if (name == "Fennec" || name == "Firefox" && /\b(?:Android|Firefox OS|KaiOS)\b/.test(os)) {
          name = "Firefox Mobile";
        } else if (name == "Maxthon" && version) {
          version = version.replace(/\.[\d.]+/, ".x");
        } else if (/\bXbox\b/i.test(product)) {
          if (product == "Xbox 360") {
            os = null;
          }
          if (product == "Xbox 360" && /\bIEMobile\b/.test(ua)) {
            description.unshift("mobile mode");
          }
        } else if ((/^(?:Chrome|IE|Opera)$/.test(name) || name && !product && !/Browser|Mobi/.test(name)) && (os == "Windows CE" || /Mobi/i.test(ua))) {
          name += " Mobile";
        } else if (name == "IE" && useFeatures) {
          try {
            if (context.external === null) {
              description.unshift("platform preview");
            }
          } catch (e) {
            description.unshift("embedded");
          }
        } else if ((/\bBlackBerry\b/.test(product) || /\bBB10\b/.test(ua)) && (data = (RegExp(product.replace(/ +/g, " *") + "/([.\\d]+)", "i").exec(ua) || 0)[1] || version)) {
          data = [data, /BB10/.test(ua)];
          os = (data[1] ? (product = null, manufacturer = "BlackBerry") : "Device Software") + " " + data[0];
          version = null;
        } else if (this != forOwn && product != "Wii" && (useFeatures && opera || /Opera/.test(name) && /\b(?:MSIE|Firefox)\b/i.test(ua) || name == "Firefox" && /\bOS X (?:\d+\.){2,}/.test(os) || name == "IE" && (os && !/^Win/.test(os) && version > 5.5 || /\bWindows XP\b/.test(os) && version > 8 || version == 8 && !/\bTrident\b/.test(ua))) && !reOpera.test(data = parse2.call(forOwn, ua.replace(reOpera, "") + ";")) && data.name) {
          data = "ing as " + data.name + ((data = data.version) ? " " + data : "");
          if (reOpera.test(name)) {
            if (/\bIE\b/.test(data) && os == "Mac OS") {
              os = null;
            }
            data = "identify" + data;
          } else {
            data = "mask" + data;
            if (operaClass) {
              name = format(operaClass.replace(/([a-z])([A-Z])/g, "$1 $2"));
            } else {
              name = "Opera";
            }
            if (/\bIE\b/.test(data)) {
              os = null;
            }
            if (!useFeatures) {
              version = null;
            }
          }
          layout = ["Presto"];
          description.push(data);
        }
        if (data = (/\bAppleWebKit\/([\d.]+\+?)/i.exec(ua) || 0)[1]) {
          data = [parseFloat(data.replace(/\.(\d)$/, ".0$1")), data];
          if (name == "Safari" && data[1].slice(-1) == "+") {
            name = "WebKit Nightly";
            prerelease = "alpha";
            version = data[1].slice(0, -1);
          } else if (version == data[1] || version == (data[2] = (/\bSafari\/([\d.]+\+?)/i.exec(ua) || 0)[1])) {
            version = null;
          }
          data[1] = (/\b(?:Headless)?Chrome\/([\d.]+)/i.exec(ua) || 0)[1];
          if (data[0] == 537.36 && data[2] == 537.36 && parseFloat(data[1]) >= 28 && layout == "WebKit") {
            layout = ["Blink"];
          }
          if (!useFeatures || !likeChrome && !data[1]) {
            layout && (layout[1] = "like Safari");
            data = (data = data[0], data < 400 ? 1 : data < 500 ? 2 : data < 526 ? 3 : data < 533 ? 4 : data < 534 ? "4+" : data < 535 ? 5 : data < 537 ? 6 : data < 538 ? 7 : data < 601 ? 8 : data < 602 ? 9 : data < 604 ? 10 : data < 606 ? 11 : data < 608 ? 12 : "12");
          } else {
            layout && (layout[1] = "like Chrome");
            data = data[1] || (data = data[0], data < 530 ? 1 : data < 532 ? 2 : data < 532.05 ? 3 : data < 533 ? 4 : data < 534.03 ? 5 : data < 534.07 ? 6 : data < 534.1 ? 7 : data < 534.13 ? 8 : data < 534.16 ? 9 : data < 534.24 ? 10 : data < 534.3 ? 11 : data < 535.01 ? 12 : data < 535.02 ? "13+" : data < 535.07 ? 15 : data < 535.11 ? 16 : data < 535.19 ? 17 : data < 536.05 ? 18 : data < 536.1 ? 19 : data < 537.01 ? 20 : data < 537.11 ? "21+" : data < 537.13 ? 23 : data < 537.18 ? 24 : data < 537.24 ? 25 : data < 537.36 ? 26 : layout != "Blink" ? "27" : "28");
          }
          layout && (layout[1] += " " + (data += typeof data == "number" ? ".x" : /[.+]/.test(data) ? "" : "+"));
          if (name == "Safari" && (!version || parseInt(version) > 45)) {
            version = data;
          } else if (name == "Chrome" && /\bHeadlessChrome/i.test(ua)) {
            description.unshift("headless");
          }
        }
        if (name == "Opera" && (data = /\bzbov|zvav$/.exec(os))) {
          name += " ";
          description.unshift("desktop mode");
          if (data == "zvav") {
            name += "Mini";
            version = null;
          } else {
            name += "Mobile";
          }
          os = os.replace(RegExp(" *" + data + "$"), "");
        } else if (name == "Safari" && /\bChrome\b/.exec(layout && layout[1])) {
          description.unshift("desktop mode");
          name = "Chrome Mobile";
          version = null;
          if (/\bOS X\b/.test(os)) {
            manufacturer = "Apple";
            os = "iOS 4.3+";
          } else {
            os = null;
          }
        } else if (/\bSRWare Iron\b/.test(name) && !version) {
          version = getVersion("Chrome");
        }
        if (version && version.indexOf(data = /[\d.]+$/.exec(os)) == 0 && ua.indexOf("/" + data + "-") > -1) {
          os = trim(os.replace(data, ""));
        }
        if (os && os.indexOf(name) != -1 && !RegExp(name + " OS").test(os)) {
          os = os.replace(RegExp(" *" + qualify(name) + " *"), "");
        }
        if (layout && !/\b(?:Avant|Nook)\b/.test(name) && (/Browser|Lunascape|Maxthon/.test(name) || name != "Safari" && /^iOS/.test(os) && /\bSafari\b/.test(layout[1]) || /^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Samsung Internet|Sleipnir|SRWare Iron|Vivaldi|Web)/.test(name) && layout[1])) {
          (data = layout[layout.length - 1]) && description.push(data);
        }
        if (description.length) {
          description = ["(" + description.join("; ") + ")"];
        }
        if (manufacturer && product && product.indexOf(manufacturer) < 0) {
          description.push("on " + manufacturer);
        }
        if (product) {
          description.push((/^on /.test(description[description.length - 1]) ? "" : "on ") + product);
        }
        if (os) {
          data = / ([\d.+]+)$/.exec(os);
          isSpecialCasedOS = data && os.charAt(os.length - data[0].length - 1) == "/";
          os = {
            "architecture": 32,
            "family": data && !isSpecialCasedOS ? os.replace(data[0], "") : os,
            "version": data ? data[1] : null,
            "toString": function() {
              var version2 = this.version;
              return this.family + (version2 && !isSpecialCasedOS ? " " + version2 : "") + (this.architecture == 64 ? " 64-bit" : "");
            }
          };
        }
        if ((data = /\b(?:AMD|IA|Win|WOW|x86_|x)64\b/i.exec(arch)) && !/\bi686\b/i.test(arch)) {
          if (os) {
            os.architecture = 64;
            os.family = os.family.replace(RegExp(" *" + data), "");
          }
          if (name && (/\bWOW64\b/i.test(ua) || useFeatures && /\w(?:86|32)$/.test(nav.cpuClass || nav.platform) && !/\bWin64; x64\b/i.test(ua))) {
            description.unshift("32-bit");
          }
        } else if (os && /^OS X/.test(os.family) && name == "Chrome" && parseFloat(version) >= 39) {
          os.architecture = 64;
        }
        ua || (ua = null);
        var platform2 = {};
        platform2.description = ua;
        platform2.layout = layout && layout[0];
        platform2.manufacturer = manufacturer;
        platform2.name = name;
        platform2.prerelease = prerelease;
        platform2.product = product;
        platform2.ua = ua;
        platform2.version = name && version;
        platform2.os = os || {
          /**
           * The CPU architecture the OS is built for.
           *
           * @memberOf platform.os
           * @type number|null
           */
          "architecture": null,
          /**
           * The family of the OS.
           *
           * Common values include:
           * "Windows", "Windows Server 2008 R2 / 7", "Windows Server 2008 / Vista",
           * "Windows XP", "OS X", "Linux", "Ubuntu", "Debian", "Fedora", "Red Hat",
           * "SuSE", "Android", "iOS" and "Windows Phone"
           *
           * @memberOf platform.os
           * @type string|null
           */
          "family": null,
          /**
           * The version of the OS.
           *
           * @memberOf platform.os
           * @type string|null
           */
          "version": null,
          /**
           * Returns the OS string.
           *
           * @memberOf platform.os
           * @returns {string} The OS string.
           */
          "toString": function() {
            return "null";
          }
        };
        platform2.parse = parse2;
        platform2.toString = toStringPlatform;
        if (platform2.version) {
          description.unshift(version);
        }
        if (platform2.name) {
          description.unshift(name);
        }
        if (os && name && !(os == String(os).split(" ")[0] && (os == name.split(" ")[0] || product))) {
          description.push(product ? "(" + os + ")" : "on " + os);
        }
        if (description.length) {
          platform2.description = description.join(" ");
        }
        return platform2;
      }
      var platform = parse2();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root.platform = platform;
        define(function() {
          return platform;
        });
      } else if (freeExports && freeModule) {
        forOwn(platform, function(value, key) {
          freeExports[key] = value;
        });
      } else {
        root.platform = platform;
      }
    }).call(exports);
  }
});

// node_modules/core-js/modules/es.string.match.js
var require_es_string_match = __commonJS({
  "node_modules/core-js/modules/es.string.match.js"() {
    "use strict";
    var call = require_function_call();
    var uncurryThis = require_function_uncurry_this();
    var fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
    var anObject = require_an_object();
    var isObject = require_is_object();
    var toLength = require_to_length();
    var toString = require_to_string();
    var requireObjectCoercible = require_require_object_coercible();
    var getMethod = require_get_method();
    var advanceStringIndex = require_advance_string_index();
    var getRegExpFlags = require_regexp_get_flags();
    var regExpExec = require_regexp_exec_abstract();
    var stringIndexOf = uncurryThis("".indexOf);
    fixRegExpWellKnownSymbolLogic("match", function(MATCH, nativeMatch, maybeCallNative) {
      return [
        // `String.prototype.match` method
        // https://tc39.es/ecma262/#sec-string.prototype.match
        function match(regexp) {
          var O = requireObjectCoercible(this);
          var matcher = isObject(regexp) ? getMethod(regexp, MATCH) : void 0;
          return matcher ? call(matcher, regexp, O) : new RegExp(regexp)[MATCH](toString(O));
        },
        // `RegExp.prototype[@@match]` method
        // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
        function(string) {
          var rx = anObject(this);
          var S = toString(string);
          var res = maybeCallNative(nativeMatch, rx, S);
          if (res.done) return res.value;
          var flags = toString(getRegExpFlags(rx));
          if (stringIndexOf(flags, "g") === -1) return regExpExec(rx, S);
          var fullUnicode = stringIndexOf(flags, "u") !== -1;
          rx.lastIndex = 0;
          var A = [];
          var n = 0;
          var result;
          while ((result = regExpExec(rx, S)) !== null) {
            var matchStr = toString(result[0]);
            A[n] = matchStr;
            if (matchStr === "") rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
            n++;
          }
          return n === 0 ? null : A;
        }
      ];
    });
  }
});

// node_modules/core-js/internals/same-value.js
var require_same_value = __commonJS({
  "node_modules/core-js/internals/same-value.js"(exports, module) {
    "use strict";
    module.exports = Object.is || function is(x, y) {
      return x === y ? x !== 0 || 1 / x === 1 / y : x !== x && y !== y;
    };
  }
});

// node_modules/core-js/modules/es.string.search.js
var require_es_string_search = __commonJS({
  "node_modules/core-js/modules/es.string.search.js"() {
    "use strict";
    var call = require_function_call();
    var fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
    var anObject = require_an_object();
    var isObject = require_is_object();
    var requireObjectCoercible = require_require_object_coercible();
    var sameValue = require_same_value();
    var toString = require_to_string();
    var getMethod = require_get_method();
    var regExpExec = require_regexp_exec_abstract();
    fixRegExpWellKnownSymbolLogic("search", function(SEARCH, nativeSearch, maybeCallNative) {
      return [
        // `String.prototype.search` method
        // https://tc39.es/ecma262/#sec-string.prototype.search
        function search(regexp) {
          var O = requireObjectCoercible(this);
          var searcher = isObject(regexp) ? getMethod(regexp, SEARCH) : void 0;
          return searcher ? call(searcher, regexp, O) : new RegExp(regexp)[SEARCH](toString(O));
        },
        // `RegExp.prototype[@@search]` method
        // https://tc39.es/ecma262/#sec-regexp.prototype-@@search
        function(string) {
          var rx = anObject(this);
          var S = toString(string);
          var res = maybeCallNative(nativeSearch, rx, S);
          if (res.done) return res.value;
          var previousLastIndex = rx.lastIndex;
          if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
          var result = regExpExec(rx, S);
          if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
          return result === null ? -1 : result.index;
        }
      ];
    });
  }
});

// node_modules/core-js/internals/array-set-length.js
var require_array_set_length = __commonJS({
  "node_modules/core-js/internals/array-set-length.js"(exports, module) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var isArray = require_is_array();
    var $TypeError = TypeError;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS && !function() {
      if (this !== void 0) return true;
      try {
        Object.defineProperty([], "length", { writable: false }).length = 1;
      } catch (error) {
        return error instanceof TypeError;
      }
    }();
    module.exports = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function(O, length) {
      if (isArray(O) && !getOwnPropertyDescriptor(O, "length").writable) {
        throw new $TypeError("Cannot set read only .length");
      }
      return O.length = length;
    } : function(O, length) {
      return O.length = length;
    };
  }
});

// node_modules/core-js/modules/es.array.splice.js
var require_es_array_splice = __commonJS({
  "node_modules/core-js/modules/es.array.splice.js"() {
    "use strict";
    var $ = require_export();
    var toObject = require_to_object();
    var toAbsoluteIndex = require_to_absolute_index();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var lengthOfArrayLike = require_length_of_array_like();
    var setArrayLength = require_array_set_length();
    var doesNotExceedSafeInteger = require_does_not_exceed_safe_integer();
    var arraySpeciesCreate = require_array_species_create();
    var createProperty = require_create_property();
    var deletePropertyOrThrow = require_delete_property_or_throw();
    var arrayMethodHasSpeciesSupport = require_array_method_has_species_support();
    var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("splice");
    var max = Math.max;
    var min = Math.min;
    $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
      splice: function splice(start, deleteCount) {
        var O = toObject(this);
        var len = lengthOfArrayLike(O);
        var actualStart = toAbsoluteIndex(start, len);
        var argumentsLength = arguments.length;
        var insertCount, actualDeleteCount, A, k, from, to;
        if (argumentsLength === 0) {
          insertCount = actualDeleteCount = 0;
        } else if (argumentsLength === 1) {
          insertCount = 0;
          actualDeleteCount = len - actualStart;
        } else {
          insertCount = argumentsLength - 2;
          actualDeleteCount = min(max(toIntegerOrInfinity(deleteCount), 0), len - actualStart);
        }
        doesNotExceedSafeInteger(len + insertCount - actualDeleteCount);
        A = arraySpeciesCreate(O, actualDeleteCount);
        for (k = 0; k < actualDeleteCount; k++) {
          from = actualStart + k;
          if (from in O) createProperty(A, k, O[from]);
        }
        A.length = actualDeleteCount;
        if (insertCount < actualDeleteCount) {
          for (k = actualStart; k < len - actualDeleteCount; k++) {
            from = k + actualDeleteCount;
            to = k + insertCount;
            if (from in O) O[to] = O[from];
            else deletePropertyOrThrow(O, to);
          }
          for (k = len; k > len - actualDeleteCount + insertCount; k--) deletePropertyOrThrow(O, k - 1);
        } else if (insertCount > actualDeleteCount) {
          for (k = len - actualDeleteCount; k > actualStart; k--) {
            from = k + actualDeleteCount - 1;
            to = k + insertCount - 1;
            if (from in O) O[to] = O[from];
            else deletePropertyOrThrow(O, to);
          }
        }
        for (k = 0; k < insertCount; k++) {
          O[k + actualStart] = arguments[k + 2];
        }
        setArrayLength(O, len - actualDeleteCount + insertCount);
        return A;
      }
    });
  }
});

// node_modules/twilsock/builds/browser.js
var require_browser5 = __commonJS({
  "node_modules/twilsock/builds/browser.js"(exports) {
    "use strict";
    var global2 = typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
    Object.defineProperty(exports, "__esModule", { value: true });
    require_es_reflect_construct();
    var _asyncToGenerator = require_asyncToGenerator();
    var _createClass = require_createClass();
    var _assertThisInitialized = require_assertThisInitialized();
    var _get = require_get();
    var _inherits = require_inherits();
    var _possibleConstructorReturn = require_possibleConstructorReturn();
    var _getPrototypeOf = require_getPrototypeOf();
    var _classCallCheck = require_classCallCheck();
    var _defineProperty = require_defineProperty();
    var _regeneratorRuntime = require_regenerator2();
    require_es_array_concat();
    require_es_object_to_string();
    require_es_regexp_to_string();
    require_es_array_join();
    require_es_array_map();
    var _typeof = require_typeof();
    var declarativeTypeValidator = require_browser4();
    require_es_array_from();
    require_es_string_iterator();
    var loglevelLog = require_loglevel();
    require_es_array_iterator();
    require_es_set();
    require_web_dom_collections_iterator();
    require_es_symbol();
    require_es_symbol_description();
    require_es_promise();
    var StateMachine = require_state_machine();
    var uuid = require_uuid();
    require_es_regexp_exec();
    require_es_string_replace();
    require_es_number_constructor();
    require_es_typed_array_uint8_array();
    require_es_typed_array_copy_within();
    require_es_typed_array_every();
    require_es_typed_array_fill();
    require_es_typed_array_filter();
    require_es_typed_array_find();
    require_es_typed_array_find_index();
    require_es_typed_array_for_each();
    require_es_typed_array_includes();
    require_es_typed_array_index_of();
    require_es_typed_array_iterator();
    require_es_typed_array_join();
    require_es_typed_array_last_index_of();
    require_es_typed_array_map();
    require_es_typed_array_reduce();
    require_es_typed_array_reduce_right();
    require_es_typed_array_reverse();
    require_es_typed_array_set();
    require_es_typed_array_slice();
    require_es_typed_array_some();
    require_es_typed_array_sort();
    require_es_typed_array_subarray();
    require_es_typed_array_to_locale_string();
    require_es_typed_array_to_string();
    require_es_string_split();
    var _wrapNativeSuper = require_wrapNativeSuper();
    require_es_object_keys();
    require_es_array_filter();
    require_es_object_get_own_property_descriptor();
    require_web_dom_collections_for_each();
    require_es_object_get_own_property_descriptors();
    var operationRetrier = require_browser3();
    require_es_map();
    var platform = require_platform();
    require_es_string_match();
    require_es_string_search();
    require_es_array_splice();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    function _interopNamespace(e) {
      if (e && e.__esModule) return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var _asyncToGenerator__default = _interopDefaultLegacy(_asyncToGenerator);
    var _createClass__default = _interopDefaultLegacy(_createClass);
    var _assertThisInitialized__default = _interopDefaultLegacy(_assertThisInitialized);
    var _get__default = _interopDefaultLegacy(_get);
    var _inherits__default = _interopDefaultLegacy(_inherits);
    var _possibleConstructorReturn__default = _interopDefaultLegacy(_possibleConstructorReturn);
    var _getPrototypeOf__default = _interopDefaultLegacy(_getPrototypeOf);
    var _classCallCheck__default = _interopDefaultLegacy(_classCallCheck);
    var _defineProperty__default = _interopDefaultLegacy(_defineProperty);
    var _regeneratorRuntime__default = _interopDefaultLegacy(_regeneratorRuntime);
    var _typeof__default = _interopDefaultLegacy(_typeof);
    var loglevelLog__namespace = _interopNamespace(loglevelLog);
    var StateMachine__namespace = _interopNamespace(StateMachine);
    var _wrapNativeSuper__default = _interopDefaultLegacy(_wrapNativeSuper);
    var platform__namespace = _interopNamespace(platform);
    function __decorate(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ((typeof Reflect === "undefined" ? "undefined" : _typeof__default["default"](Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      }
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __metadata(metadataKey, metadataValue) {
      if ((typeof Reflect === "undefined" ? "undefined" : _typeof__default["default"](Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }
    var domain;
    function EventHandlers() {
    }
    EventHandlers.prototype = /* @__PURE__ */ Object.create(null);
    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.usingDomains = false;
    EventEmitter.prototype.domain = void 0;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._maxListeners = void 0;
    EventEmitter.defaultMaxListeners = 10;
    EventEmitter.init = function() {
      this.domain = null;
      if (EventEmitter.usingDomains) {
        if (domain.active) ;
      }
      if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
        this._events = new EventHandlers();
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || isNaN(n))
        throw new TypeError('"n" argument must be a positive number');
      this._maxListeners = n;
      return this;
    };
    function $getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return $getMaxListeners(this);
    };
    function emitNone(handler, isFn, self2) {
      if (isFn)
        handler.call(self2);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self2);
      }
    }
    function emitOne(handler, isFn, self2, arg1) {
      if (isFn)
        handler.call(self2, arg1);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self2, arg1);
      }
    }
    function emitTwo(handler, isFn, self2, arg1, arg2) {
      if (isFn)
        handler.call(self2, arg1, arg2);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self2, arg1, arg2);
      }
    }
    function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
      if (isFn)
        handler.call(self2, arg1, arg2, arg3);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self2, arg1, arg2, arg3);
      }
    }
    function emitMany(handler, isFn, self2, args) {
      if (isFn)
        handler.apply(self2, args);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].apply(self2, args);
      }
    }
    EventEmitter.prototype.emit = function emit(type) {
      var er, handler, len, args, i, events, domain2;
      var doError = type === "error";
      events = this._events;
      if (events)
        doError = doError && events.error == null;
      else if (!doError)
        return false;
      domain2 = this.domain;
      if (doError) {
        er = arguments[1];
        if (domain2) {
          if (!er)
            er = new Error('Uncaught, unspecified "error" event');
          er.domainEmitter = this;
          er.domain = domain2;
          er.domainThrown = false;
          domain2.emit("error", er);
        } else if (er instanceof Error) {
          throw er;
        } else {
          var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
          err.context = er;
          throw err;
        }
        return false;
      }
      handler = events[type];
      if (!handler)
        return false;
      var isFn = typeof handler === "function";
      len = arguments.length;
      switch (len) {
        case 1:
          emitNone(handler, isFn, this);
          break;
        case 2:
          emitOne(handler, isFn, this, arguments[1]);
          break;
        case 3:
          emitTwo(handler, isFn, this, arguments[1], arguments[2]);
          break;
        case 4:
          emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
          break;
        default:
          args = new Array(len - 1);
          for (i = 1; i < len; i++)
            args[i - 1] = arguments[i];
          emitMany(handler, isFn, this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      events = target._events;
      if (!events) {
        events = target._events = new EventHandlers();
        target._eventsCount = 0;
      } else {
        if (events.newListener) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (!existing) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else {
          if (prepend) {
            existing.unshift(listener);
          } else {
            existing.push(listener);
          }
        }
        if (!existing.warned) {
          m = $getMaxListeners(target);
          if (m && m > 0 && existing.length > m) {
            existing.warned = true;
            var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type + " listeners added. Use emitter.setMaxListeners() to increase limit");
            w.name = "MaxListenersExceededWarning";
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            emitWarning(w);
          }
        }
      }
      return target;
    }
    function emitWarning(e) {
      typeof console.warn === "function" ? console.warn(e) : console.log(e);
    }
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function _onceWrap(target, type, listener) {
      var fired = false;
      function g() {
        target.removeListener(type, g);
        if (!fired) {
          fired = true;
          listener.apply(target, arguments);
        }
      }
      g.listener = listener;
      return g;
    }
    EventEmitter.prototype.once = function once(type, listener) {
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      events = this._events;
      if (!events)
        return this;
      list = events[type];
      if (!list)
        return this;
      if (list === listener || list.listener && list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = new EventHandlers();
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length; i-- > 0; ) {
          if (list[i] === listener || list[i].listener && list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (list.length === 1) {
          list[0] = void 0;
          if (--this._eventsCount === 0) {
            this._events = new EventHandlers();
            return this;
          } else {
            delete events[type];
          }
        } else {
          spliceOne(list, position);
        }
        if (events.removeListener)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.off = function(type, listener) {
      return this.removeListener(type, listener);
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events;
      events = this._events;
      if (!events)
        return this;
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        for (var i = 0, key; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener") continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = new EventHandlers();
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners) {
        do {
          this.removeListener(type, listeners[listeners.length - 1]);
        } while (listeners[0]);
      }
      return this;
    };
    EventEmitter.prototype.listeners = function listeners(type) {
      var evlistener;
      var ret;
      var events = this._events;
      if (!events)
        ret = [];
      else {
        evlistener = events[type];
        if (!evlistener)
          ret = [];
        else if (typeof evlistener === "function")
          ret = [evlistener.listener || evlistener];
        else
          ret = unwrapListeners(evlistener);
      }
      return ret;
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
    };
    function spliceOne(list, index) {
      for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
        list[i] = list[k];
      list.pop();
    }
    function arrayClone(arr, i) {
      var copy = new Array(i);
      while (i--)
        copy[i] = arr[i];
      return copy;
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    var log = loglevelLog__namespace.getLogger("twilsock");
    function prepareLine(prefix, args) {
      return ["".concat((/* @__PURE__ */ new Date()).toISOString(), " Twilsock ").concat(prefix, ":")].concat(Array.from(args));
    }
    var Logger = function() {
      function Logger2(prefix) {
        _classCallCheck__default["default"](this, Logger2);
        _defineProperty__default["default"](this, "prefix", "");
        this.prefix = prefix !== null && prefix !== void 0 && prefix.length > 0 ? " " + prefix + ":" : "";
      }
      _createClass__default["default"](Logger2, [{
        key: "setLevel",
        value: function setLevel(level) {
          log.setLevel(level);
        }
      }, {
        key: "trace",
        value: function trace() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          log.trace.apply(null, prepareLine("T", args));
        }
      }, {
        key: "debug",
        value: function debug() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          log.debug.apply(null, prepareLine("D", args));
        }
      }, {
        key: "info",
        value: function info() {
          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }
          log.info.apply(null, prepareLine("I", args));
        }
      }, {
        key: "warn",
        value: function warn() {
          for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args[_key4] = arguments[_key4];
          }
          log.warn.apply(null, prepareLine("W", args));
        }
      }, {
        key: "error",
        value: function error() {
          for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
            args[_key5] = arguments[_key5];
          }
          log.error.apply(null, prepareLine("E", args));
        }
      }], [{
        key: "setLevel",
        value: function setLevel(level) {
          log.setLevel(level);
        }
      }, {
        key: "trace",
        value: function trace() {
          for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
            args[_key6] = arguments[_key6];
          }
          log.trace.apply(null, prepareLine("T", args));
        }
      }, {
        key: "debug",
        value: function debug() {
          for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
            args[_key7] = arguments[_key7];
          }
          log.debug.apply(null, prepareLine("D", args));
        }
      }, {
        key: "info",
        value: function info() {
          for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
            args[_key8] = arguments[_key8];
          }
          log.info.apply(null, prepareLine("I", args));
        }
      }, {
        key: "warn",
        value: function warn() {
          for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
            args[_key9] = arguments[_key9];
          }
          log.warn.apply(null, prepareLine("W", args));
        }
      }, {
        key: "error",
        value: function error() {
          for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
            args[_key10] = arguments[_key10];
          }
          log.error.apply(null, prepareLine("E", args));
        }
      }]);
      return Logger2;
    }();
    var logInstance = new Logger("");
    var version = "0.12.2";
    var Configuration = function() {
      function Configuration2(token, activeGrant, options) {
        _classCallCheck__default["default"](this, Configuration2);
        _defineProperty__default["default"](this, "confirmedCapabilities", /* @__PURE__ */ new Set());
        this.activeGrant = activeGrant;
        this._token = token;
        var region = options.region || "us1";
        var defaultTwilsockUrl = "wss://tsock.".concat(region, ".twilio.com/v3/wsconnect");
        var twilsockOptions = options.twilsock || options.Twilsock || {};
        this.url = twilsockOptions.uri || defaultTwilsockUrl;
        this._continuationToken = options.continuationToken ? options.continuationToken : null;
        this.logLevel = options.logLevel ? options.logLevel : "error";
        this.retryPolicy = options.retryPolicy ? options.retryPolicy : {
          min: 1 * 1e3,
          max: 2 * 60 * 1e3,
          randomness: 0.2
        };
        this.clientMetadata = options.clientMetadata ? options.clientMetadata : {};
        this.clientMetadata.ver = version;
        this.initRegistrations = options.initRegistrations ? options.initRegistrations : null;
        this.tweaks = options.tweaks ? options.tweaks : null;
      }
      _createClass__default["default"](Configuration2, [{
        key: "token",
        get: function get() {
          return this._token;
        }
      }, {
        key: "continuationToken",
        get: function get() {
          return this._continuationToken;
        }
      }, {
        key: "updateToken",
        value: function updateToken(token) {
          this._token = token;
        }
      }, {
        key: "updateContinuationToken",
        value: function updateContinuationToken(continuationToken) {
          this._continuationToken = continuationToken;
        }
      }]);
      return Configuration2;
    }();
    var AbstractMessage = function AbstractMessage2(id) {
      _classCallCheck__default["default"](this, AbstractMessage2);
      this.id = id || "TM".concat(uuid.v4());
    };
    function _createSuper$f(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$f();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$f() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var Init = function(_AbstractMessage) {
      _inherits__default["default"](Init2, _AbstractMessage);
      var _super = _createSuper$f(Init2);
      function Init2(token, continuationToken, metadata, registrations, tweaks) {
        var _this;
        _classCallCheck__default["default"](this, Init2);
        _this = _super.call(this);
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "method", "init");
        _this.token = token;
        _this.continuation_token = continuationToken;
        _this.metadata = metadata;
        _this.registrations = registrations;
        _this.tweaks = tweaks;
        _this.capabilities = ["client_update", "offline_storage", "telemetry.v1"];
        return _this;
      }
      return Init2;
    }(AbstractMessage);
    function _createSuper$e(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$e();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$e() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var InitReply = function(_AbstractMessage) {
      _inherits__default["default"](InitReply2, _AbstractMessage);
      var _super = _createSuper$e(InitReply2);
      function InitReply2(id, continuationToken, confirmedCapabilities, continuationTokenStatus, offlineStorage, initRegistrations, debugInfo) {
        var _this;
        _classCallCheck__default["default"](this, InitReply2);
        _this = _super.call(this, id);
        _this.continuationToken = continuationToken;
        _this.continuationTokenStatus = continuationTokenStatus;
        _this.offlineStorage = offlineStorage;
        _this.initRegistrations = initRegistrations;
        _this.debugInfo = debugInfo;
        _this.confirmedCapabilities = confirmedCapabilities;
        return _this;
      }
      return InitReply2;
    }(AbstractMessage);
    function _createSuper$d(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$d();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$d() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var Update = function(_AbstractMessage) {
      _inherits__default["default"](Update2, _AbstractMessage);
      var _super = _createSuper$d(Update2);
      function Update2(token) {
        var _this;
        _classCallCheck__default["default"](this, Update2);
        _this = _super.call(this);
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "method", "update");
        _this.token = token;
        return _this;
      }
      return Update2;
    }(AbstractMessage);
    function _createSuper$c(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$c();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$c() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var Message = function(_AbstractMessage) {
      _inherits__default["default"](Message2, _AbstractMessage);
      var _super = _createSuper$c(Message2);
      function Message2(grant, contentType, request) {
        var _this;
        _classCallCheck__default["default"](this, Message2);
        _this = _super.call(this);
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "method", "message");
        _this.active_grant = grant;
        _this.payload_type = contentType;
        _this.http_request = request;
        return _this;
      }
      return Message2;
    }(AbstractMessage);
    function _createSuper$b(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$b();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$b() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var Reply = function(_AbstractMessage) {
      _inherits__default["default"](Reply2, _AbstractMessage);
      var _super = _createSuper$b(Reply2);
      function Reply2(id) {
        var _this;
        _classCallCheck__default["default"](this, Reply2);
        _this = _super.call(this, id);
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "method", "reply");
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "payload_type", "application/json");
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "status", {
          code: 200,
          status: "OK"
        });
        return _this;
      }
      return Reply2;
    }(AbstractMessage);
    function _createSuper$a(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$a();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$a() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var Close = function(_AbstractMessage) {
      _inherits__default["default"](Close2, _AbstractMessage);
      var _super = _createSuper$a(Close2);
      function Close2() {
        var _this;
        _classCallCheck__default["default"](this, Close2);
        _this = _super.call(this);
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "method", "close");
        return _this;
      }
      return Close2;
    }(AbstractMessage);
    function _createSuper$9(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$9();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$9() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var TelemetryEvent = function TelemetryEvent2(start, end2, title, details, id, type) {
      _classCallCheck__default["default"](this, TelemetryEvent2);
      this.start = start;
      this.end = end2;
      this.title = title;
      this.details = details;
      this.id = id;
      this.type = type;
    };
    var Telemetry = function(_AbstractMessage) {
      _inherits__default["default"](Telemetry2, _AbstractMessage);
      var _super = _createSuper$9(Telemetry2);
      function Telemetry2(events) {
        var _this;
        _classCallCheck__default["default"](this, Telemetry2);
        _this = _super.call(this);
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "method", "telemetry.v1");
        _this.events = events;
        return _this;
      }
      return Telemetry2;
    }(AbstractMessage);
    function byteLength(s) {
      var escstr = encodeURIComponent(s);
      var binstr = escstr.replace(/%([0-9A-F]{2})/g, function(match, p1) {
        return String.fromCharCode(Number("0x" + p1));
      });
      return binstr.length;
    }
    function stringToUint8Array(s) {
      var escstr = encodeURIComponent(s);
      var binstr = escstr.replace(/%([0-9A-F]{2})/g, function(match, p1) {
        return String.fromCharCode(Number("0x" + p1));
      });
      var ua = new Uint8Array(binstr.length);
      Array.prototype.forEach.call(binstr, function(ch, i) {
        ua[i] = ch.charCodeAt(0);
      });
      return ua;
    }
    function uint8ArrayToString(ua) {
      var binstr = Array.prototype.map.call(ua, function(ch) {
        return String.fromCharCode(ch);
      }).join("");
      var escstr = binstr.replace(/(.)/g, function(m, p) {
        var code = p.charCodeAt(0).toString(16).toUpperCase();
        if (code.length < 2) {
          code = "0" + code;
        }
        return "%" + code;
      });
      return decodeURIComponent(escstr);
    }
    function getJsonObject(array) {
      return JSON.parse(uint8ArrayToString(array));
    }
    function getMagic(buffer) {
      var strMagic = "";
      var idx = 0;
      for (; idx < buffer.length; ++idx) {
        var chr = String.fromCharCode(buffer[idx]);
        strMagic += chr;
        if (chr === "\r") {
          idx += 2;
          break;
        }
      }
      var magics = strMagic.split(" ");
      return {
        size: idx,
        protocol: magics[0],
        version: magics[1],
        headerSize: Number(magics[2])
      };
    }
    var Parser = function() {
      function Parser2() {
        _classCallCheck__default["default"](this, Parser2);
      }
      _createClass__default["default"](Parser2, null, [{
        key: "parse",
        value: function parse2(message) {
          var fieldMargin = 2;
          var dataView = new Uint8Array(message);
          var magic = getMagic(dataView);
          if (magic.protocol !== "TWILSOCK" || magic.version !== "V3.0") {
            logInstance.error("unsupported protocol: ".concat(magic.protocol, " ver ").concat(magic.version));
            return null;
          }
          var header;
          try {
            header = getJsonObject(dataView.subarray(magic.size, magic.size + magic.headerSize));
          } catch (e) {
            logInstance.error("failed to parse message header", e, message);
            return null;
          }
          logInstance.debug("message received: ", header.method);
          logInstance.trace("message received: ", header);
          var payload;
          if (header.payload_size > 0) {
            var payloadOffset = fieldMargin + magic.size + magic.headerSize;
            var payloadSize = header.payload_size;
            if (!header.hasOwnProperty("payload_type") || header.payload_type.indexOf("application/json") === 0) {
              try {
                payload = getJsonObject(dataView.subarray(payloadOffset, payloadOffset + payloadSize));
              } catch (e) {
                logInstance.error("failed to parse message body", e, message);
                return null;
              }
            } else if (header.payload_type.indexOf("text/plain") === 0) {
              payload = uint8ArrayToString(dataView.subarray(payloadOffset, payloadOffset + payloadSize));
            }
          }
          return {
            method: header.method,
            header,
            payload
          };
        }
      }, {
        key: "createPacket",
        value: function createPacket(header) {
          var payloadString = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
          header.payload_size = byteLength(payloadString);
          var headerString = JSON.stringify(header);
          var magicString = "TWILSOCK V3.0 " + byteLength(headerString);
          logInstance.debug("send request:", magicString + headerString + payloadString);
          var message = stringToUint8Array(magicString + "\r\n" + headerString + "\r\n" + payloadString);
          return message.buffer;
        }
      }]);
      return Parser2;
    }();
    function _createSuper$8(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$8();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$8() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var TwilsockError = function(_Error) {
      _inherits__default["default"](TwilsockError2, _Error);
      var _super = _createSuper$8(TwilsockError2);
      function TwilsockError2(description) {
        _classCallCheck__default["default"](this, TwilsockError2);
        return _super.call(this, description);
      }
      return TwilsockError2;
    }(_wrapNativeSuper__default["default"](Error));
    function _createSuper$7(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$7();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$7() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var TwilsockReplyError = function(_TwilsockError) {
      _inherits__default["default"](TwilsockReplyError2, _TwilsockError);
      var _super = _createSuper$7(TwilsockReplyError2);
      function TwilsockReplyError2(description, reply) {
        var _this;
        _classCallCheck__default["default"](this, TwilsockReplyError2);
        _this = _super.call(this, description);
        _this.reply = reply;
        return _this;
      }
      return TwilsockReplyError2;
    }(TwilsockError);
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        }
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty__default["default"](target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _createSuper$6(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$6();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$6() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var BackoffRetrier = function(_EventEmitter) {
      _inherits__default["default"](BackoffRetrier2, _EventEmitter);
      var _super = _createSuper$6(BackoffRetrier2);
      function BackoffRetrier2(options) {
        var _this;
        _classCallCheck__default["default"](this, BackoffRetrier2);
        _this = _super.call(this);
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "newBackoff", null);
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "usedBackoff", null);
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "retrier", null);
        _this.options = options ? _objectSpread({}, options) : {};
        return _this;
      }
      _createClass__default["default"](BackoffRetrier2, [{
        key: "inProgress",
        get: function get() {
          return !!this.retrier;
        }
      }, {
        key: "start",
        value: function start() {
          if (this.inProgress) {
            throw new Error("Already waiting for next attempt, call finishAttempt(success : boolean) to finish it");
          }
          this.createRetrier();
        }
        /**
         * Should be called to stop retrier entirely.
         */
      }, {
        key: "stop",
        value: function stop() {
          this.cleanRetrier();
          this.newBackoff = null;
          this.usedBackoff = null;
        }
        /**
         * Modifies backoff for next attempt.
         * Expected behavior:
         * - If there was no backoff passed previously reschedulling next attempt to given backoff
         * - If previous backoff was longer then ignoring this one.
         * - If previous backoff was shorter then reschedulling with this one.
         * With or without backoff retrier will keep growing normally.
         * @param delay delay of next attempts in ms.
         */
      }, {
        key: "modifyBackoff",
        value: function modifyBackoff(delay) {
          this.newBackoff = delay;
        }
        /**
         * Mark last emmited attempt as failed, initiating either next of fail if limits were hit.
         */
      }, {
        key: "attemptFailed",
        value: function attemptFailed() {
          if (!this.inProgress) {
            throw new Error("No attempt is in progress");
          }
          if (this.newBackoff) {
            var shouldUseNewBackoff = !this.usedBackoff || this.usedBackoff < this.newBackoff;
            if (shouldUseNewBackoff) {
              this.createRetrier();
            } else {
              var _this$retrier;
              (_this$retrier = this.retrier) === null || _this$retrier === void 0 ? void 0 : _this$retrier.failed(new Error());
            }
          } else {
            var _this$retrier2;
            (_this$retrier2 = this.retrier) === null || _this$retrier2 === void 0 ? void 0 : _this$retrier2.failed(new Error());
          }
        }
      }, {
        key: "cancel",
        value: function cancel() {
          var _this$retrier3;
          (_this$retrier3 = this.retrier) === null || _this$retrier3 === void 0 ? void 0 : _this$retrier3.cancel();
        }
      }, {
        key: "cleanRetrier",
        value: function cleanRetrier() {
          var _this$retrier4, _this$retrier5;
          (_this$retrier4 = this.retrier) === null || _this$retrier4 === void 0 ? void 0 : _this$retrier4.removeAllListeners();
          (_this$retrier5 = this.retrier) === null || _this$retrier5 === void 0 ? void 0 : _this$retrier5.cancel();
          this.retrier = null;
        }
      }, {
        key: "getRetryPolicy",
        value: function getRetryPolicy() {
          var clone = _objectSpread({}, this.options);
          if (this.newBackoff) {
            clone.min = this.newBackoff;
            clone.max = this.options.max && this.options.max > this.newBackoff ? this.options.max : this.newBackoff;
          }
          clone.maxAttemptsCount = this.options.maxAttemptsCount ? this.options.maxAttemptsCount + 1 : void 0;
          return clone;
        }
      }, {
        key: "createRetrier",
        value: function createRetrier() {
          var _this2 = this;
          this.cleanRetrier();
          var retryPolicy = this.getRetryPolicy();
          this.retrier = new operationRetrier.Retrier(retryPolicy);
          this.retrier.once("attempt", function() {
            var _this2$retrier, _this2$retrier2;
            (_this2$retrier = _this2.retrier) === null || _this2$retrier === void 0 ? void 0 : _this2$retrier.on("attempt", function() {
              return _this2.emit("attempt");
            });
            (_this2$retrier2 = _this2.retrier) === null || _this2$retrier2 === void 0 ? void 0 : _this2$retrier2.failed(new Error("Skipping first attempt"));
          });
          this.retrier.on("failed", function(err) {
            return _this2.emit("failed", err);
          });
          this.usedBackoff = this.newBackoff;
          this.newBackoff = null;
          this.retrier.start();
        }
      }]);
      return BackoffRetrier2;
    }(EventEmitter);
    function _createSuper$5(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$5();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$5() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var DISCONNECTING_TIMEOUT = 3e3;
    function trampoline(f) {
      setTimeout(f, 0);
    }
    var TwilsockChannel = function(_EventEmitter) {
      _inherits__default["default"](TwilsockChannel2, _EventEmitter);
      var _super = _createSuper$5(TwilsockChannel2);
      function TwilsockChannel2(websocket, transport, config) {
        var _this;
        _classCallCheck__default["default"](this, TwilsockChannel2);
        _this = _super.call(this);
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "disconnectingTimer", null);
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "disconnectedPromiseResolve", null);
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "terminalStates", ["disconnected", "rejected"]);
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "tokenExpiredSasCode", 20104);
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "terminationReason", "Connection is not initialized");
        _this.websocket = websocket;
        _this.websocket.on("connected", function() {
          return _this.fsm.socketConnected();
        });
        _this.websocket.on("disconnected", function() {
          return _this.fsm.socketClosed();
        });
        _this.websocket.on("message", function(message) {
          return _this.onIncomingMessage(message);
        });
        _this.websocket.on("socketError", function(e) {
          return _this.emit("connectionError", {
            terminal: false,
            message: "Socket error: ".concat(e.message),
            httpStatusCode: null,
            errorCode: null
          });
        });
        _this.transport = transport;
        _this.config = config;
        _this.retrier = new BackoffRetrier(config.retryPolicy);
        _this.retrier.on("attempt", function() {
          return _this.retry();
        });
        _this.retrier.on("failed", function(err) {
          logInstance.warn("Retrying failed: ".concat(err.message));
          _this.disconnect();
        });
        if (typeof window !== "undefined" && typeof window.addEventListener !== "undefined") {
          window.addEventListener("online", function() {
            logInstance.debug("Browser reported connectivity state: online");
            _this.resetBackoff();
            _this.fsm.systemOnline();
          });
          window.addEventListener("offline", function() {
            logInstance.debug("Browser reported connectivity state: offline");
            _this.websocket.close();
            _this.fsm.socketClosed();
          });
        }
        var TwilsockStateMachine = StateMachine__namespace.factory({
          init: "disconnected",
          transitions: [{
            name: "userConnect",
            from: ["disconnected", "rejected"],
            to: "connecting"
          }, {
            name: "userConnect",
            from: ["connecting", "connected"]
          }, {
            name: "userDisconnect",
            from: ["connecting", "initialising", "connected", "updating", "retrying", "rejected", "waitSocketClosed", "waitOffloadSocketClosed"],
            to: "disconnecting"
          }, {
            name: "userRetry",
            from: ["retrying"],
            to: "connecting"
          }, {
            name: "socketConnected",
            from: ["connecting"],
            to: "initialising"
          }, {
            name: "socketClosed",
            from: ["connecting", "initialising", "connected", "updating", "error", "waitOffloadSocketClosed"],
            to: "retrying"
          }, {
            name: "socketClosed",
            from: ["disconnecting"],
            to: "disconnected"
          }, {
            name: "socketClosed",
            from: ["waitSocketClosed"],
            to: "disconnected"
          }, {
            name: "socketClosed",
            from: ["rejected"],
            to: "rejected"
          }, {
            name: "initSuccess",
            from: ["initialising"],
            to: "connected"
          }, {
            name: "initError",
            from: ["initialising"],
            to: "error"
          }, {
            name: "tokenRejected",
            from: ["initialising", "updating"],
            to: "rejected"
          }, {
            name: "protocolError",
            from: ["initialising", "connected", "updating"],
            to: "error"
          }, {
            name: "receiveClose",
            from: ["initialising", "connected", "updating"],
            to: "waitSocketClosed"
          }, {
            name: "receiveOffload",
            from: ["initialising", "connected", "updating"],
            to: "waitOffloadSocketClosed"
          }, {
            name: "unsupportedProtocol",
            from: ["initialising", "connected", "updating"],
            to: "unsupported"
          }, {
            name: "receiveFatalClose",
            from: ["initialising", "connected", "updating"],
            to: "unsupported"
          }, {
            name: "userUpdateToken",
            from: ["disconnected", "rejected", "connecting", "retrying"],
            to: "connecting"
          }, {
            name: "userUpdateToken",
            from: ["connected"],
            to: "updating"
          }, {
            name: "updateSuccess",
            from: ["updating"],
            to: "connected"
          }, {
            name: "updateError",
            from: ["updating"],
            to: "error"
          }, {
            name: "userSend",
            from: ["connected"],
            to: "connected"
          }, {
            name: "systemOnline",
            from: ["retrying"],
            to: "connecting"
          }],
          methods: {
            onConnecting: function onConnecting() {
              _this.setupSocket();
              _this.emit("connecting");
            },
            onEnterInitialising: function onEnterInitialising() {
              _this.sendInit();
            },
            onLeaveInitialising: function onLeaveInitialising() {
              _this.cancelInit();
            },
            onEnterUpdating: function onEnterUpdating() {
              _this.sendUpdate();
            },
            onLeaveUpdating: function onLeaveUpdating() {
              _this.cancelUpdate();
            },
            onEnterRetrying: function onEnterRetrying() {
              _this.initRetry();
              _this.emit("connecting");
            },
            onEnterConnected: function onEnterConnected() {
              _this.resetBackoff();
              _this.onConnected();
            },
            onUserUpdateToken: function onUserUpdateToken() {
              _this.resetBackoff();
            },
            onTokenRejected: function onTokenRejected() {
              _this.resetBackoff();
              _this.closeSocket(true);
              _this.finalizeSocket();
            },
            onUserDisconnect: function onUserDisconnect() {
              _this.closeSocket(true);
            },
            onEnterDisconnecting: function onEnterDisconnecting() {
              _this.startDisconnectTimer();
            },
            onLeaveDisconnecting: function onLeaveDisconnecting() {
              _this.cancelDisconnectTimer();
            },
            onEnterWaitSocketClosed: function onEnterWaitSocketClosed() {
              _this.startDisconnectTimer();
            },
            onLeaveWaitSocketClosed: function onLeaveWaitSocketClosed() {
              _this.cancelDisconnectTimer();
            },
            onEnterWaitOffloadSocketClosed: function onEnterWaitOffloadSocketClosed() {
              _this.startDisconnectTimer();
            },
            onLeaveWaitOffloadSocketClosed: function onLeaveWaitOffloadSocketClosed() {
              _this.cancelDisconnectTimer();
            },
            onDisconnected: function onDisconnected() {
              _this.resetBackoff();
              _this.finalizeSocket();
            },
            onReceiveClose: function onReceiveClose() {
              _this.onCloseReceived();
            },
            onReceiveOffload: function onReceiveOffload(event, args) {
              logInstance.debug("onreceiveoffload: ", args);
              _this.modifyBackoff(args.body);
              _this.onCloseReceived();
            },
            onUnsupported: function onUnsupported() {
              _this.closeSocket(true);
              _this.finalizeSocket();
            },
            onError: function onError(lifecycle, graceful) {
              _this.closeSocket(graceful);
              _this.finalizeSocket();
            },
            onEnterState: function onEnterState(event) {
              if (event.from !== "none") {
                _this.changeState(event);
              }
            },
            onInvalidTransition: function onInvalidTransition(transition, from, to) {
              logInstance.warn("FSM: unexpected transition", from, to);
            }
          }
        });
        _this.fsm = new TwilsockStateMachine();
        return _this;
      }
      _createClass__default["default"](TwilsockChannel2, [{
        key: "changeState",
        value: function changeState(event) {
          logInstance.debug("FSM: ".concat(event.transition, ": ").concat(event.from, " --> ").concat(event.to));
          if (this.lastEmittedState !== this.state) {
            this.lastEmittedState = this.state;
            this.emit("stateChanged", this.state);
          }
        }
      }, {
        key: "resetBackoff",
        value: function resetBackoff() {
          logInstance.trace("resetBackoff");
          this.retrier.stop();
        }
      }, {
        key: "modifyBackoff",
        value: function modifyBackoff(body) {
          logInstance.trace("modifyBackoff", body);
          var backoffPolicy = body ? body.backoff_policy : null;
          if (backoffPolicy && typeof backoffPolicy.reconnect_min_ms === "number") {
            this.retrier.modifyBackoff(backoffPolicy.reconnect_min_ms);
          }
        }
      }, {
        key: "startDisconnectTimer",
        value: function startDisconnectTimer() {
          var _this2 = this;
          logInstance.trace("startDisconnectTimer");
          if (this.disconnectingTimer) {
            clearTimeout(this.disconnectingTimer);
            this.disconnectingTimer = null;
          }
          this.disconnectingTimer = setTimeout(function() {
            logInstance.debug("disconnecting is timed out");
            _this2.closeSocket(true);
          }, DISCONNECTING_TIMEOUT);
        }
      }, {
        key: "cancelDisconnectTimer",
        value: function cancelDisconnectTimer() {
          logInstance.trace("cancelDisconnectTimer");
          if (this.disconnectingTimer) {
            clearTimeout(this.disconnectingTimer);
            this.disconnectingTimer = null;
          }
        }
      }, {
        key: "isConnected",
        get: function get() {
          return this.state === "connected" && this.websocket.isConnected;
        }
      }, {
        key: "state",
        get: function get() {
          switch (this.fsm.state) {
            case "connecting":
            case "initialising":
            case "retrying":
            case "error":
              return "connecting";
            case "updating":
            case "connected":
              return "connected";
            case "rejected":
              return "denied";
            case "disconnecting":
            case "waitSocketClosed":
            case "waitOffloadSocketClosed":
              return "disconnecting";
            case "disconnected":
            default:
              return "disconnected";
          }
        }
      }, {
        key: "initRetry",
        value: function initRetry() {
          logInstance.debug("initRetry");
          if (this.retrier.inProgress) {
            this.retrier.attemptFailed();
          } else {
            this.retrier.start();
          }
        }
      }, {
        key: "retry",
        value: function retry() {
          if (this.fsm.state != "connecting") {
            logInstance.trace("retry");
            this.websocket.close();
            this.fsm.userRetry();
          } else {
            logInstance.trace("can	 retry as already connecting");
          }
        }
      }, {
        key: "onConnected",
        value: function onConnected() {
          this.emit("connected");
        }
      }, {
        key: "finalizeSocket",
        value: function finalizeSocket() {
          logInstance.trace("finalizeSocket");
          this.websocket.close();
          this.emit("disconnected");
          if (this.disconnectedPromiseResolve) {
            this.disconnectedPromiseResolve();
            this.disconnectedPromiseResolve = null;
          }
        }
      }, {
        key: "setupSocket",
        value: function setupSocket() {
          logInstance.trace("setupSocket:", this.config.token);
          this.emit("beforeConnect");
          this.websocket.connect();
        }
      }, {
        key: "onIncomingMessage",
        value: function onIncomingMessage(message) {
          var parsedMessage = Parser.parse(message);
          if (!parsedMessage) {
            return;
          }
          var method = parsedMessage.method, header = parsedMessage.header, payload = parsedMessage.payload;
          if (method !== "reply") {
            this.confirmReceiving(header);
          }
          if (method === "notification") {
            this.emit("message", header.message_type, payload);
          } else if (header.method === "reply") {
            this.transport.processReply({
              id: header.id,
              status: header.status,
              header,
              body: payload
            });
          } else if (header.method === "client_update") {
            if (header.client_update_type === "token_about_to_expire") {
              this.emit("tokenAboutToExpire");
            }
          } else if (header.method === "close") {
            if (header.status.code === 308) {
              logInstance.debug("Connection has been offloaded");
              this.fsm.receiveOffload({
                status: header.status.status,
                body: payload
              });
            } else if (header.status.code === 406) {
              var _message = "Server closed connection because can't parse protocol: ".concat(JSON.stringify(header.status));
              this.emitReplyConnectionError(_message, header, true);
              logInstance.error(_message);
              this.fsm.receiveFatalClose();
            } else if (header.status.code === 417) {
              logInstance.error("Server closed connection because can't parse client reply: ".concat(JSON.stringify(header.status)));
              this.fsm.receiveFatalClose(header.status.status);
            } else if (header.status.code === 410) {
              logInstance.warn("Server closed connection: ".concat(JSON.stringify(header.status)));
              this.fsm.receiveClose(header.status.status);
              this.emit("tokenExpired");
            } else if (header.status.code === 401) {
              logInstance.error("Server closed connection: ".concat(JSON.stringify(header.status)));
              this.fsm.receiveClose(header.status.status);
            } else {
              logInstance.warn("unexpected message: ", header.status);
              this.fsm.receiveOffload({
                status: header.status.status,
                body: null
              });
            }
          }
        }
      }, {
        key: "sendInit",
        value: function() {
          var _sendInit = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee() {
            var reply, isTerminalError;
            return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    logInstance.trace("sendInit");
                    _context.prev = 1;
                    this.emit("beforeSendInit");
                    _context.next = 5;
                    return this.transport.sendInit();
                  case 5:
                    reply = _context.sent;
                    this.config.updateContinuationToken(reply.continuationToken);
                    this.config.confirmedCapabilities = reply.confirmedCapabilities;
                    this.fsm.initSuccess(reply);
                    this.emit("initialized", reply);
                    this.emit("tokenUpdated");
                    _context.next = 17;
                    break;
                  case 13:
                    _context.prev = 13;
                    _context.t0 = _context["catch"](1);
                    if (_context.t0 instanceof TwilsockReplyError) {
                      isTerminalError = false;
                      logInstance.warn("Init rejected by server: ".concat(JSON.stringify(_context.t0.reply.status)));
                      this.emit("sendInitFailed");
                      if (_context.t0.reply.status.code === 401 || _context.t0.reply.status.code === 403) {
                        isTerminalError = true;
                        this.fsm.tokenRejected(_context.t0.reply.status);
                        if (_context.t0.reply.status.errorCode === this.tokenExpiredSasCode) {
                          this.emit("tokenExpired");
                        }
                      } else if (_context.t0.reply.status.code === 429) {
                        this.modifyBackoff(_context.t0.reply.body);
                        this.fsm.initError(true);
                      } else if (_context.t0.reply.status.code === 500) {
                        this.fsm.initError(false);
                      } else {
                        this.fsm.initError(true);
                      }
                      this.emitReplyConnectionError(_context.t0.message, _context.t0.reply, isTerminalError);
                    } else {
                      this.terminationReason = _context.t0.message;
                      this.emit("connectionError", {
                        terminal: true,
                        message: "Unknown error during connection initialisation: ".concat(_context.t0.message, "\n").concat(JSON.stringify(_context.t0, null, 2)),
                        httpStatusCode: null,
                        errorCode: null
                      });
                      this.fsm.initError(true);
                    }
                    this.emit("tokenUpdated", _context.t0);
                  case 17:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[1, 13]]);
          }));
          function sendInit() {
            return _sendInit.apply(this, arguments);
          }
          return sendInit;
        }()
      }, {
        key: "sendUpdate",
        value: function() {
          var _sendUpdate = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee2() {
            var message, reply, isTerminalError;
            return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    logInstance.trace("sendUpdate");
                    message = new Update(this.config.token);
                    _context2.prev = 2;
                    _context2.next = 5;
                    return this.transport.sendWithReply(message);
                  case 5:
                    reply = _context2.sent;
                    this.fsm.updateSuccess(reply.body);
                    this.emit("tokenUpdated");
                    _context2.next = 14;
                    break;
                  case 10:
                    _context2.prev = 10;
                    _context2.t0 = _context2["catch"](2);
                    if (_context2.t0 instanceof TwilsockReplyError) {
                      isTerminalError = false;
                      logInstance.warn("Token update rejected by server: ".concat(JSON.stringify(_context2.t0.reply.status)));
                      if (_context2.t0.reply.status.code === 401 || _context2.t0.reply.status.code === 403) {
                        isTerminalError = true;
                        this.fsm.tokenRejected(_context2.t0.reply.status);
                        if (_context2.t0.reply.status.errorCode === this.tokenExpiredSasCode) {
                          this.emit("tokenExpired");
                        }
                      } else if (_context2.t0.reply.status.code === 429) {
                        this.modifyBackoff(_context2.t0.reply.body);
                        this.fsm.updateError(_context2.t0.reply.status);
                      } else {
                        this.fsm.updateError(_context2.t0.reply.status);
                      }
                      this.emitReplyConnectionError(_context2.t0.message, _context2.t0.reply, isTerminalError);
                    } else {
                      this.emit("error", false, _context2.t0.message, null, null);
                      this.fsm.updateError(_context2.t0);
                    }
                    this.emit("tokenUpdated", _context2.t0);
                  case 14:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this, [[2, 10]]);
          }));
          function sendUpdate() {
            return _sendUpdate.apply(this, arguments);
          }
          return sendUpdate;
        }()
      }, {
        key: "emitReplyConnectionError",
        value: function emitReplyConnectionError(message, header, terminal) {
          var description = header.status && header.status.description ? header.status.description : message;
          var httpStatusCode = header.status.code;
          var errorCode = header.status && header.status.errorCode ? header.status.errorCode : null;
          if (terminal) {
            this.terminationReason = description;
          }
          this.emit("connectionError", {
            terminal,
            message: "Connection error: ".concat(description),
            httpStatusCode,
            errorCode
          });
        }
      }, {
        key: "cancelInit",
        value: function cancelInit() {
          logInstance.trace("cancelInit");
        }
      }, {
        key: "cancelUpdate",
        value: function cancelUpdate() {
          logInstance.trace("cancelUpdate");
        }
        /**
         * Should be called for each message to confirm it received
         */
      }, {
        key: "confirmReceiving",
        value: function confirmReceiving(messageHeader) {
          logInstance.trace("confirmReceiving");
          try {
            this.transport.send(new Reply(messageHeader.id));
          } catch (e) {
            logInstance.debug("failed to confirm packet receiving", e);
          }
        }
        /**
         * Shutdown connection
         */
      }, {
        key: "closeSocket",
        value: function closeSocket(graceful) {
          var _this3 = this;
          logInstance.trace("closeSocket (graceful: ".concat(graceful, ")"));
          if (graceful && this.transport.isConnected) {
            this.transport.sendClose();
          }
          this.websocket.close();
          trampoline(function() {
            return _this3.fsm.socketClosed();
          });
        }
        /**
         * Initiate the twilsock connection
         * If already connected, it does nothing
         */
      }, {
        key: "connect",
        value: function connect() {
          logInstance.trace("connect");
          this.fsm.userConnect();
        }
        /**
         * Close twilsock connection
         * If already disconnected, it does nothing
         */
      }, {
        key: "disconnect",
        value: function disconnect() {
          var _this4 = this;
          logInstance.trace("disconnect");
          if (this.fsm.is("disconnected")) {
            return Promise.resolve();
          }
          return new Promise(function(resolve) {
            _this4.disconnectedPromiseResolve = resolve;
            _this4.fsm.userDisconnect();
          });
        }
        /**
         * Update fpa token for twilsock connection
         */
      }, {
        key: "updateToken",
        value: function updateToken(token) {
          var _this5 = this;
          logInstance.trace("updateToken:", token);
          return new Promise(function(resolve, reject) {
            _this5.once("tokenUpdated", function(e) {
              if (e) {
                reject(e);
              } else {
                resolve();
              }
            });
            _this5.fsm.userUpdateToken();
          });
        }
      }, {
        key: "isTerminalState",
        get: function get() {
          return this.terminalStates.indexOf(this.fsm.state) !== -1;
        }
      }, {
        key: "getTerminationReason",
        get: function get() {
          return this.terminationReason;
        }
      }, {
        key: "onCloseReceived",
        value: function onCloseReceived() {
          this.websocket.close();
        }
      }]);
      return TwilsockChannel2;
    }(EventEmitter);
    var Metadata = function() {
      function Metadata2() {
        _classCallCheck__default["default"](this, Metadata2);
      }
      _createClass__default["default"](Metadata2, null, [{
        key: "getMetadata",
        value: function getMetadata(options) {
          var _platform$name, _platform$version, _platform$os$family, _platform$os, _platform$os$version, _platform$os2, _platform$os$architec, _platform$os3;
          var overrides = options && options.clientMetadata ? options.clientMetadata : {};
          var fieldNames = ["ver", "env", "envv", "os", "osv", "osa", "type", "sdk", "sdkv", "dev", "devv", "devt", "app", "appv"];
          var defaults = {
            env: (_platform$name = platform__namespace.name) !== null && _platform$name !== void 0 ? _platform$name : "unknown",
            envv: (_platform$version = platform__namespace.version) !== null && _platform$version !== void 0 ? _platform$version : "unknown",
            os: (_platform$os$family = (_platform$os = platform__namespace.os) === null || _platform$os === void 0 ? void 0 : _platform$os.family) !== null && _platform$os$family !== void 0 ? _platform$os$family : "unknown",
            osv: (_platform$os$version = (_platform$os2 = platform__namespace.os) === null || _platform$os2 === void 0 ? void 0 : _platform$os2.version) !== null && _platform$os$version !== void 0 ? _platform$os$version : "unknown",
            osa: (_platform$os$architec = (_platform$os3 = platform__namespace.os) === null || _platform$os3 === void 0 ? void 0 : _platform$os3.architecture) !== null && _platform$os$architec !== void 0 ? _platform$os$architec : "unknown",
            sdk: "js-default"
          };
          var finalClientMetadata = {};
          fieldNames.filter(function(key) {
            return key in overrides || key in defaults;
          }).forEach(function(key) {
            return finalClientMetadata[key] = key in overrides ? overrides[key] : defaults[key];
          });
          return finalClientMetadata;
        }
      }]);
      return Metadata2;
    }();
    var REQUEST_TIMEOUT$1 = 3e4;
    function isHttpSuccess$1(code) {
      return code >= 200 && code < 300;
    }
    function preparePayload(payload) {
      switch (_typeof__default["default"](payload)) {
        case "undefined":
          return "";
        case "object":
          return JSON.stringify(payload);
        default:
          return payload;
      }
    }
    var PacketInterface = function() {
      function PacketInterface2(channel, config) {
        var _this = this;
        _classCallCheck__default["default"](this, PacketInterface2);
        this.config = config;
        this.activeRequests = /* @__PURE__ */ new Map();
        this.channel = channel;
        this.channel.on("reply", function(reply) {
          return _this.processReply(reply);
        });
        this.channel.on("disconnected", function() {
          _this.activeRequests.forEach(function(descriptor) {
            clearTimeout(descriptor.timeout);
            descriptor.reject(new TwilsockError("disconnected"));
          });
          _this.activeRequests.clear();
        });
      }
      _createClass__default["default"](PacketInterface2, [{
        key: "isConnected",
        get: function get() {
          return this.channel.isConnected;
        }
      }, {
        key: "processReply",
        value: function processReply(reply) {
          var request = this.activeRequests.get(reply.id);
          if (request) {
            clearTimeout(request.timeout);
            this.activeRequests.delete(reply.id);
            if (!isHttpSuccess$1(reply.status.code)) {
              request.reject(new TwilsockReplyError("Transport failure: " + reply.status.status, reply));
              logInstance.trace("message rejected");
            } else {
              request.resolve(reply);
            }
          }
        }
      }, {
        key: "storeRequest",
        value: function storeRequest(id, resolve, reject) {
          var requestDescriptor = {
            resolve,
            reject,
            timeout: setTimeout(function() {
              logInstance.trace("request", id, "is timed out");
              reject(new TwilsockError("Twilsock: request timeout: " + id));
            }, REQUEST_TIMEOUT$1)
          };
          this.activeRequests.set(id, requestDescriptor);
        }
      }, {
        key: "shutdown",
        value: function shutdown() {
          this.activeRequests.forEach(function(descriptor) {
            clearTimeout(descriptor.timeout);
            descriptor.reject(new TwilsockError("Twilsock: request cancelled by user"));
          });
          this.activeRequests.clear();
        }
      }, {
        key: "sendInit",
        value: function() {
          var _sendInit = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee() {
            var metadata, message, response;
            return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    logInstance.trace("sendInit");
                    metadata = Metadata.getMetadata(this.config);
                    message = new Init(this.config.token, this.config.continuationToken, metadata, this.config.initRegistrations, this.config.tweaks);
                    _context.next = 5;
                    return this.sendWithReply(message);
                  case 5:
                    response = _context.sent;
                    return _context.abrupt("return", new InitReply(response.id, response.header.continuation_token, new Set(response.header.capabilities), response.header.continuation_token_status, response.header.offline_storage, response.header.init_registrations, response.header.debug_info));
                  case 7:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function sendInit() {
            return _sendInit.apply(this, arguments);
          }
          return sendInit;
        }()
      }, {
        key: "sendClose",
        value: function sendClose() {
          var message = new Close();
          this.send(message);
        }
      }, {
        key: "sendWithReply",
        value: function sendWithReply(header, payload) {
          var _this2 = this;
          return new Promise(function(resolve, reject) {
            var id = _this2.send(header, payload);
            _this2.storeRequest(id, resolve, reject);
          });
        }
      }, {
        key: "send",
        value: function send(header, payload) {
          header.id = header.id || "TM".concat(uuid.v4());
          var message = Parser.createPacket(header, preparePayload(payload));
          try {
            this.channel.send(message);
            return header.id;
          } catch (e) {
            logInstance.debug("failed to send ", header, e);
            logInstance.trace(e.stack);
            throw e;
          }
        }
      }]);
      return PacketInterface2;
    }();
    function _createSuper$4(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$4();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$4() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var WebSocketChannel = function(_EventEmitter) {
      _inherits__default["default"](WebSocketChannel2, _EventEmitter);
      var _super = _createSuper$4(WebSocketChannel2);
      function WebSocketChannel2(url) {
        var _this;
        _classCallCheck__default["default"](this, WebSocketChannel2);
        _this = _super.call(this);
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "socket", null);
        _this.url = url;
        _this.url = url;
        _this.WebSocket = global2["WebSocket"] || global2["MozWebSocket"] || {};
        return _this;
      }
      _createClass__default["default"](WebSocketChannel2, [{
        key: "isConnected",
        get: function get() {
          return !!this.socket && this.socket.readyState === 1;
        }
      }, {
        key: "connect",
        value: function connect() {
          var _this2 = this;
          logInstance.trace("connecting to socket");
          var socket;
          try {
            socket = new this.WebSocket(this.url);
          } catch (e) {
            logInstance.debug("Socket error: ".concat(this.url));
            this.emit("socketError", e);
            return;
          }
          socket.binaryType = "arraybuffer";
          socket.onopen = function() {
            logInstance.debug("socket opened ".concat(_this2.url));
            _this2.emit("connected");
          };
          socket.onclose = function(e) {
            logInstance.debug("socket closed", e);
            _this2.emit("disconnected", e);
          };
          socket.onerror = function(e) {
            logInstance.debug("Socket error:", e);
            _this2.emit("socketError", e);
          };
          socket.onmessage = function(message) {
            _this2.emit("message", message.data);
          };
          this.socket = socket;
        }
      }, {
        key: "send",
        value: function send(message) {
          return this.socket && this.socket.send(message);
        }
      }, {
        key: "close",
        value: function close() {
          logInstance.trace("closing socket");
          if (this.socket) {
            this.socket.onopen = null;
            this.socket.onclose = null;
            this.socket.onerror = null;
            this.socket.onmessage = null;
            try {
              this.socket.close();
            } finally {
            }
          }
        }
      }]);
      return WebSocketChannel2;
    }(EventEmitter);
    function _createSuper$3(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$3() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var Registrations = function(_EventEmitter) {
      _inherits__default["default"](Registrations2, _EventEmitter);
      var _super = _createSuper$3(Registrations2);
      function Registrations2(transport) {
        var _this;
        _classCallCheck__default["default"](this, Registrations2);
        _this = _super.call(this);
        _this.transport = transport;
        _this.registrations = /* @__PURE__ */ new Map();
        _this.registrationsInProgress = /* @__PURE__ */ new Map();
        return _this;
      }
      _createClass__default["default"](Registrations2, [{
        key: "putNotificationContext",
        value: function() {
          var _putNotificationContext = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee(contextId, context) {
            var header;
            return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    header = {
                      method: "put_notification_ctx",
                      notification_ctx_id: contextId
                    };
                    _context.next = 3;
                    return this.transport.sendWithReply(header, context);
                  case 3:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function putNotificationContext(_x, _x2) {
            return _putNotificationContext.apply(this, arguments);
          }
          return putNotificationContext;
        }()
      }, {
        key: "deleteNotificationContext",
        value: function() {
          var _deleteNotificationContext = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee2(contextId) {
            var message;
            return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    message = {
                      method: "delete_notification_ctx",
                      notification_ctx_id: contextId
                    };
                    _context2.next = 3;
                    return this.transport.sendWithReply(message);
                  case 3:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function deleteNotificationContext(_x3) {
            return _deleteNotificationContext.apply(this, arguments);
          }
          return deleteNotificationContext;
        }()
      }, {
        key: "updateRegistration",
        value: function() {
          var _updateRegistration = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee3(contextId, context) {
            var registrationAttempts, attemptId;
            return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    logInstance.debug("update registration for context", contextId);
                    registrationAttempts = this.registrationsInProgress.get(contextId);
                    if (!registrationAttempts) {
                      registrationAttempts = /* @__PURE__ */ new Set();
                      this.registrationsInProgress.set(contextId, registrationAttempts);
                    }
                    attemptId = uuid.v4();
                    registrationAttempts.add(attemptId);
                    _context3.prev = 5;
                    _context3.next = 8;
                    return this.putNotificationContext(contextId, context);
                  case 8:
                    logInstance.debug("registration attempt succeeded for context", context);
                    registrationAttempts.delete(attemptId);
                    if (registrationAttempts.size === 0) {
                      this.registrationsInProgress.delete(contextId);
                      this.emit("registered", contextId);
                    }
                    _context3.next = 19;
                    break;
                  case 13:
                    _context3.prev = 13;
                    _context3.t0 = _context3["catch"](5);
                    logInstance.warn("registration attempt failed for context", context);
                    logInstance.debug(_context3.t0);
                    registrationAttempts.delete(attemptId);
                    if (registrationAttempts.size === 0) {
                      this.registrationsInProgress.delete(contextId);
                      this.emit("registrationFailed", contextId, _context3.t0);
                    }
                  case 19:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this, [[5, 13]]);
          }));
          function updateRegistration(_x4, _x5) {
            return _updateRegistration.apply(this, arguments);
          }
          return updateRegistration;
        }()
      }, {
        key: "updateRegistrations",
        value: function() {
          var _updateRegistrations = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee4() {
            var _this2 = this;
            var promises;
            return _regeneratorRuntime__default["default"].wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    logInstance.trace("refreshing ".concat(this.registrations.size, " registrations"));
                    promises = [];
                    this.registrations.forEach(function(context, id) {
                      promises.push(_this2.updateRegistration(id, context));
                    });
                    _context4.next = 5;
                    return Promise.all(promises);
                  case 5:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));
          function updateRegistrations() {
            return _updateRegistrations.apply(this, arguments);
          }
          return updateRegistrations;
        }()
      }, {
        key: "setNotificationsContext",
        value: function() {
          var _setNotificationsContext = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee5(contextId, context) {
            return _regeneratorRuntime__default["default"].wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    if (!(!contextId || !context)) {
                      _context5.next = 2;
                      break;
                    }
                    throw new TwilsockError("Invalid arguments provided");
                  case 2:
                    this.registrations.set(contextId, context);
                    _context5.next = 5;
                    return this.updateRegistration(contextId, context);
                  case 5:
                    return _context5.abrupt("return", _context5.sent);
                  case 6:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));
          function setNotificationsContext(_x6, _x7) {
            return _setNotificationsContext.apply(this, arguments);
          }
          return setNotificationsContext;
        }()
      }, {
        key: "removeNotificationsContext",
        value: function() {
          var _removeNotificationsContext = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee6(contextId) {
            return _regeneratorRuntime__default["default"].wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    if (this.registrations.has(contextId)) {
                      _context6.next = 2;
                      break;
                    }
                    return _context6.abrupt("return");
                  case 2:
                    _context6.next = 4;
                    return this.deleteNotificationContext(contextId);
                  case 4:
                    if (this.transport.isConnected) {
                      this.registrations.delete(contextId);
                    }
                  case 5:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, this);
          }));
          function removeNotificationsContext(_x8) {
            return _removeNotificationsContext.apply(this, arguments);
          }
          return removeNotificationsContext;
        }()
      }]);
      return Registrations2;
    }(EventEmitter);
    function _createSuper$2(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$2() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var TwilsockUpstreamError = function(_TwilsockError) {
      _inherits__default["default"](TwilsockUpstreamError2, _TwilsockError);
      var _super = _createSuper$2(TwilsockUpstreamError2);
      function TwilsockUpstreamError2(status, description, body) {
        var _this;
        _classCallCheck__default["default"](this, TwilsockUpstreamError2);
        _this = _super.call(this, description);
        _this.status = status;
        _this.description = description;
        _this.body = body;
        return _this;
      }
      return TwilsockUpstreamError2;
    }(TwilsockError);
    function _createSuper$1(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$1() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var TransportUnavailableError = function(_TwilsockError) {
      _inherits__default["default"](TransportUnavailableError2, _TwilsockError);
      var _super = _createSuper$1(TransportUnavailableError2);
      function TransportUnavailableError2(description) {
        _classCallCheck__default["default"](this, TransportUnavailableError2);
        return _super.call(this, description);
      }
      return TransportUnavailableError2;
    }(TwilsockError);
    var REQUEST_TIMEOUT = 2e4;
    function isHttpSuccess(code) {
      return code >= 200 && code < 300;
    }
    function isHttpReply(packet) {
      return packet && packet.header && packet.header.http_status;
    }
    function parseUri(uri) {
      var match = uri.match(/^(https?\:)\/\/(([^:\/?#]*)(?:\:([0-9]+))?)(\/[^?#]*)(\?[^#]*|)(#.*|)$/);
      if (match) {
        var uriStruct = {
          protocol: match[1],
          host: match[2],
          hostname: match[3],
          port: match[4],
          pathname: match[5],
          search: match[6],
          hash: match[7],
          params: {}
        };
        if (uriStruct.search.length > 0) {
          var paramsString = uriStruct.search.substring(1);
          uriStruct.params = paramsString.split("&").map(function(el) {
            return el.split("=");
          }).reduce(function(prev, curr) {
            if (!prev.hasOwnProperty(curr[0])) {
              prev[curr[0]] = curr[1];
            } else if (Array.isArray(prev[curr[0]])) {
              prev[curr[0]].push(curr[1]);
            } else {
              prev[curr[0]] = [prev[curr[0]], curr[1]];
            }
            return prev;
          }, {});
        }
        return uriStruct;
      }
      throw new TwilsockError("Incorrect URI: " + uri);
    }
    function twilsockAddress(method, uri) {
      var parsedUri = parseUri(uri);
      var to = {
        method,
        host: parsedUri.host,
        path: parsedUri.pathname
      };
      if (parsedUri.params) {
        to.params = parsedUri.params;
      }
      return to;
    }
    function twilsockParams(method, uri, headers, body, grant) {
      return {
        to: twilsockAddress(method, uri),
        headers,
        body,
        grant
      };
    }
    var Upstream = function() {
      function Upstream2(transport, twilsock, config) {
        _classCallCheck__default["default"](this, Upstream2);
        this.config = config;
        this.transport = transport;
        this.pendingMessages = [];
        this.twilsock = twilsock;
      }
      _createClass__default["default"](Upstream2, [{
        key: "saveMessage",
        value: function saveMessage(message) {
          var _this = this;
          return new Promise(function(resolve, reject) {
            var requestDescriptor = {
              message,
              resolve,
              reject,
              alreadyRejected: false,
              timeout: setTimeout(function() {
                logInstance.debug("request is timed out");
                reject(new TwilsockError("request '".concat(message.to.method, "' to '").concat(message.to.host, "' timed out")));
                requestDescriptor.alreadyRejected = true;
              }, REQUEST_TIMEOUT)
            };
            _this.pendingMessages.push(requestDescriptor);
          });
        }
      }, {
        key: "sendPendingMessages",
        value: function sendPendingMessages() {
          var _this2 = this;
          var _loop = function _loop2() {
            var request = _this2.pendingMessages[0];
            if (!request.alreadyRejected) {
              try {
                var message = request.message;
                _this2.actualSend(message).then(function(response) {
                  return request.resolve(response);
                }).catch(function(e) {
                  return request.reject(e);
                });
                clearTimeout(request.timeout);
              } catch (e) {
                logInstance.debug("Failed to send pending message", e);
                return "break";
              }
            }
            _this2.pendingMessages.splice(0, 1);
          };
          while (this.pendingMessages.length > 0) {
            var _ret = _loop();
            if (_ret === "break") break;
          }
        }
      }, {
        key: "rejectPendingMessages",
        value: function rejectPendingMessages() {
          var _this3 = this;
          this.pendingMessages.forEach(function(message) {
            message.reject(new TransportUnavailableError(
              // @todo Error Unhandled promise rejection!
              "Unable to connect: " + _this3.twilsock.getTerminationReason
            ));
            message.alreadyRejected = true;
            clearTimeout(message.timeout);
          });
          this.pendingMessages.splice(0, this.pendingMessages.length);
        }
      }, {
        key: "actualSend",
        value: function() {
          var _actualSend = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee(message) {
            var _message$grant;
            var address, headers, body, grant, httpRequest, upstreamMessage, reply;
            return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    address = message.to;
                    headers = message.headers;
                    body = message.body;
                    grant = (_message$grant = message.grant) !== null && _message$grant !== void 0 ? _message$grant : this.config.activeGrant;
                    httpRequest = {
                      host: address.host,
                      path: address.path,
                      method: address.method,
                      params: address.params,
                      headers
                    };
                    upstreamMessage = new Message(grant, headers["Content-Type"] || "application/json", httpRequest);
                    logInstance.trace("Sending upstream message", upstreamMessage);
                    _context.next = 9;
                    return this.transport.sendWithReply(upstreamMessage, body);
                  case 9:
                    reply = _context.sent;
                    logInstance.trace("Received upstream message response", reply);
                    if (!(isHttpReply(reply) && !isHttpSuccess(reply.header.http_status.code))) {
                      _context.next = 13;
                      break;
                    }
                    throw new TwilsockUpstreamError(reply.header.http_status.code, reply.header.http_status.status, reply.body);
                  case 13:
                    return _context.abrupt("return", {
                      status: reply.header.http_status,
                      headers: reply.header.http_headers,
                      body: reply.body
                    });
                  case 14:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function actualSend(_x) {
            return _actualSend.apply(this, arguments);
          }
          return actualSend;
        }()
        /**
         * Send an upstream message
         * @param {string} method The upstream method
         * @param {string} url URL to send the message to
         * @param {object} [headers] The message headers
         * @param {any} [body] The message body
         * @param {string} [grant] The product grant
         * @returns {Promise<Result>} Result from remote side
         */
      }, {
        key: "send",
        value: function send(method, url) {
          var headers = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          var body = arguments.length > 3 ? arguments[3] : void 0;
          var grant = arguments.length > 4 ? arguments[4] : void 0;
          if (this.twilsock.isTerminalState) {
            return Promise.reject(new TransportUnavailableError("Unable to connect: " + this.twilsock.getTerminationReason));
          }
          var twilsockMessage = twilsockParams(method, url, headers, body, grant);
          if (!this.twilsock.isConnected) {
            return this.saveMessage(twilsockMessage);
          }
          return this.actualSend(twilsockMessage);
        }
      }]);
      return Upstream2;
    }();
    var Deferred = function() {
      function Deferred2() {
        var _this = this;
        _classCallCheck__default["default"](this, Deferred2);
        this._promise = new Promise(function(resolve, reject) {
          _this._resolve = resolve;
          _this._reject = reject;
        });
      }
      _createClass__default["default"](Deferred2, [{
        key: "promise",
        get: function get() {
          return this._promise;
        }
      }, {
        key: "update",
        value: function update(value) {
          this._resolve(value);
        }
      }, {
        key: "set",
        value: function set(value) {
          this._resolve(value);
        }
      }, {
        key: "fail",
        value: function fail(e) {
          this._reject(e);
        }
      }]);
      return Deferred2;
    }();
    var OfflineProductStorage = function() {
      function OfflineProductStorage2(id) {
        _classCallCheck__default["default"](this, OfflineProductStorage2);
        this.id = id;
      }
      _createClass__default["default"](OfflineProductStorage2, null, [{
        key: "create",
        value: function create(productPayload) {
          if (productPayload instanceof Object && "storage_id" in productPayload) {
            return new OfflineProductStorage2(productPayload.storage_id);
          } else {
            throw new TwilsockError('Field "storage_id" is missing');
          }
        }
      }]);
      return OfflineProductStorage2;
    }();
    var TokenStorage = function() {
      function TokenStorage2() {
        _classCallCheck__default["default"](this, TokenStorage2);
        _defineProperty__default["default"](this, "initializedFlag", "twilio_twilsock_token_storage");
        _defineProperty__default["default"](this, "tokenStoragePrefix", "twilio_continuation_token_");
        if (!TokenStorage2._instance) {
          this.initialize();
          TokenStorage2._instance = this;
        }
        return TokenStorage2._instance;
      }
      _createClass__default["default"](TokenStorage2, [{
        key: "sessionStorage",
        value: function sessionStorage2() {
          try {
            return global2["sessionStorage"];
          } catch (err) {
            return null;
          }
        }
      }, {
        key: "window",
        value: function window2() {
          try {
            return global2["window"];
          } catch (err) {
            return null;
          }
        }
      }, {
        key: "storeToken",
        value: function storeToken(continuationToken, productId) {
          if (this.canStore()) {
            this.sessionStorage.setItem(this.getKeyName(productId), continuationToken);
          }
        }
      }, {
        key: "getStoredToken",
        value: function getStoredToken(productId) {
          if (!this.canStore()) {
            return null;
          }
          return this.sessionStorage.getItem(this.getKeyName(productId));
        }
      }, {
        key: "initialize",
        value: function initialize() {
          var _this = this;
          if (this.canStore()) {
            var flag = this.sessionStorage.getItem(this.initializedFlag);
            if (flag) {
              this.clear();
            }
            this.sessionStorage.setItem(this.initializedFlag, "true");
            var removeStorageItem = this.sessionStorage.removeItem;
            this.window.addEventListener("unload", function() {
              removeStorageItem(_this.initializedFlag);
            });
          }
        }
      }, {
        key: "clear",
        value: function clear() {
          if (this.canStore()) {
            var keyToDelete = [];
            for (var i = 0; i < this.sessionStorage.length; i++) {
              var key = this.sessionStorage.key(i);
              if (key && key.indexOf(this.tokenStoragePrefix) === 0) {
                keyToDelete.push(key);
              }
            }
            var removeStorageItem = this.sessionStorage.removeItem;
            keyToDelete.forEach(function(key2) {
              return removeStorageItem(key2);
            });
            removeStorageItem(this.initializedFlag);
          }
        }
      }, {
        key: "getKeyName",
        value: function getKeyName(productId) {
          return "".concat(this.tokenStoragePrefix).concat(productId);
        }
      }, {
        key: "canStore",
        value: function canStore() {
          return !!(this.sessionStorage && this.sessionStorage.length && this.window);
        }
      }]);
      return TokenStorage2;
    }();
    _defineProperty__default["default"](TokenStorage, "_instance", null);
    var TokenStorage$1 = new TokenStorage();
    var TelemetryEventDescription = function() {
      function TelemetryEventDescription2(title, details, start, end2, type, id) {
        _classCallCheck__default["default"](this, TelemetryEventDescription2);
        this.title = title;
        this.details = details;
        this.start = start;
        this.type = type;
        this.id = id;
        this.end = end2;
      }
      _createClass__default["default"](TelemetryEventDescription2, [{
        key: "toTelemetryEvent",
        value: function toTelemetryEvent() {
          var now = /* @__PURE__ */ new Date();
          var actualStart = this.start;
          var actualEnd = this.end ? this.end : now;
          if (actualEnd < actualStart) {
            var tmp = actualEnd;
            actualEnd = actualStart;
            actualStart = tmp;
          }
          var startOffset = actualStart.getTime() - now.getTime();
          var endOffset = actualEnd.getTime() - now.getTime();
          var result = new TelemetryEvent(startOffset, endOffset, this.title, this.details, this.id, this.type);
          return result;
        }
      }]);
      return TelemetryEventDescription2;
    }();
    exports.TelemetryPoint = void 0;
    (function(TelemetryPoint) {
      TelemetryPoint[TelemetryPoint["Start"] = 0] = "Start";
      TelemetryPoint[TelemetryPoint["End"] = 1] = "End";
    })(exports.TelemetryPoint || (exports.TelemetryPoint = {}));
    exports.EventSendingLimitation = void 0;
    (function(EventSendingLimitation) {
      EventSendingLimitation[EventSendingLimitation["MinEventsPortion"] = 0] = "MinEventsPortion";
      EventSendingLimitation[EventSendingLimitation["AnyEvents"] = 1] = "AnyEvents";
      EventSendingLimitation[EventSendingLimitation["AnyEventsIncludingUnfinished"] = 2] = "AnyEventsIncludingUnfinished";
    })(exports.EventSendingLimitation || (exports.EventSendingLimitation = {}));
    var TelemetryTracker = function() {
      function TelemetryTracker2(config, packetInterface) {
        _classCallCheck__default["default"](this, TelemetryTracker2);
        _defineProperty__default["default"](this, "minEventsPortionToSend", 50);
        _defineProperty__default["default"](this, "maxEventsPortionToSend", 100);
        _defineProperty__default["default"](this, "pendingEvents", /* @__PURE__ */ new Map());
        _defineProperty__default["default"](this, "readyEvents", []);
        _defineProperty__default["default"](this, "hasInitializationFinished", false);
        _defineProperty__default["default"](this, "_canSendTelemetry", false);
        this.config = config;
        this.packetInterface = packetInterface;
      }
      _createClass__default["default"](TelemetryTracker2, [{
        key: "isTelemetryEnabled",
        get: function get() {
          return this.config.confirmedCapabilities.has("telemetry.v1");
        }
      }, {
        key: "canSendTelemetry",
        get: function get() {
          return this._canSendTelemetry && this.isTelemetryEnabled;
        },
        set: function set(enable) {
          logInstance.debug("TelemetryTracker.canSendTelemetry: ".concat(enable, " TelemetryTracker.isTelemetryEnabled: ").concat(this.isTelemetryEnabled));
          if (this._canSendTelemetry && !enable) {
            this.pendingEvents.clear();
            this.readyEvents = [];
          }
          this._canSendTelemetry = enable;
          if (enable) {
            this.sendTelemetry(exports.EventSendingLimitation.AnyEvents);
          }
          if (enable && !this.hasInitializationFinished) {
            this.hasInitializationFinished = true;
          }
        }
        // Add complete event
      }, {
        key: "addTelemetryEvent",
        value: function addTelemetryEvent(event) {
          if (!this.canSendTelemetry && this.hasInitializationFinished) {
            return;
          }
          this.readyEvents.push(event);
        }
        // Add incomplete event (with either starting or ending time point)
      }, {
        key: "addPartialEvent",
        value: function addPartialEvent(incompleteEvent, eventKey, point) {
          logInstance.debug("Adding ".concat(point === exports.TelemetryPoint.Start ? "starting" : "ending", " timepoint for '").concat(eventKey, "' event"));
          var exists = this.pendingEvents.has(eventKey);
          if (point === exports.TelemetryPoint.Start) {
            if (exists) {
              logInstance.debug("Overwriting starting point for '".concat(eventKey, "' event"));
            }
            this.pendingEvents.set(eventKey, incompleteEvent);
          } else {
            if (!exists) {
              logInstance.info("Could not find started event for '".concat(eventKey, "' event"));
              return;
            }
            this.addTelemetryEvent(this.merge(this.pendingEvents.get(eventKey), incompleteEvent));
            this.pendingEvents.delete(eventKey);
          }
        }
      }, {
        key: "getTelemetryToSend",
        value: function getTelemetryToSend(sendingLimit) {
          if (!this.canSendTelemetry || this.readyEvents.length == 0) {
            return [];
          }
          if (sendingLimit == exports.EventSendingLimitation.MinEventsPortion && this.readyEvents.length < this.minEventsPortionToSend) {
            return [];
          }
          return this.getTelemetryPortion(sendingLimit == exports.EventSendingLimitation.AnyEventsIncludingUnfinished);
        }
      }, {
        key: "getTelemetryPortion",
        value: function getTelemetryPortion(includeUnfinished) {
          var _this = this;
          var eventsPortionToSend = Math.min(this.readyEvents.length, this.maxEventsPortionToSend);
          var res = this.readyEvents.splice(0, eventsPortionToSend);
          if (includeUnfinished && res.length < this.maxEventsPortionToSend) {
            this.pendingEvents.forEach(function(value, key) {
              if (res.length >= _this.maxEventsPortionToSend) {
                return;
              }
              var event = _this.pendingEvents.get(key);
              _this.pendingEvents.delete(key);
              res.push(new TelemetryEventDescription(
                "[UNFINISHED] ".concat(event.title),
                // add prefix title to mark unfinished events for CleanSock
                event.details,
                event.start,
                null,
                // Not ended, on sending will be replaced with now
                event.type,
                event.id
              ));
            });
          }
          return res;
        }
        // Merging 2 partial events:
        //   use start.startTime & end.endTime.
        // For other fields,
        //   if there are values in end, use them,
        //   else use values from start.
      }, {
        key: "merge",
        value: function merge(start, end2) {
          return new TelemetryEventDescription(end2.title ? end2.title : start.title, end2.details ? end2.details : start.details, start.start, end2.end, end2.type ? end2.type : start.type, end2.id ? end2.id : start.id);
        }
      }, {
        key: "sendTelemetryIfMinimalPortionCollected",
        value: function sendTelemetryIfMinimalPortionCollected() {
          this.sendTelemetry(exports.EventSendingLimitation.MinEventsPortion);
        }
        // NB: getTelemetryToSend will return non-empty array only if we have already received initReply
        // and telemetry.v1 capability is enabled there.
      }, {
        key: "sendTelemetry",
        value: function sendTelemetry(limit) {
          var events = this.getTelemetryToSend(limit);
          if (events.length === 0) {
            return;
          }
          try {
            this.packetInterface.send(new Telemetry(events.map(function(e) {
              return e.toTelemetryEvent();
            })));
          } catch (err) {
            logInstance.debug("Error while sending ".concat(events.length, " telemetry events due to ").concat(err, "; they will be resubmitted"));
            this.readyEvents = this.readyEvents.concat(events);
          }
        }
      }]);
      return TelemetryTracker2;
    }();
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var TelemetryEvents = function TelemetryEvents2() {
      _classCallCheck__default["default"](this, TelemetryEvents2);
    };
    _defineProperty__default["default"](TelemetryEvents, "TWILSOCK_CONNECT", "twilsock.sdk.connect");
    _defineProperty__default["default"](TelemetryEvents, "TWILSOCK_INIT", "twilsock.sdk.init");
    exports.TwilsockClient = function(_EventEmitter) {
      _inherits__default["default"](TwilsockClient, _EventEmitter);
      var _super = _createSuper(TwilsockClient);
      function TwilsockClient(token, productId, options) {
        var _this;
        _classCallCheck__default["default"](this, TwilsockClient);
        _this = _super.call(this);
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "version", version);
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "offlineStorageDeferred", new Deferred());
        options.continuationToken = options.continuationToken ? options.continuationToken : TokenStorage$1.getStoredToken(productId);
        var config = _this.config = new Configuration(token, productId, options);
        logInstance.setLevel(config.logLevel);
        var websocket = new WebSocketChannel(config.url);
        var transport = new PacketInterface(websocket, config);
        _this.channel = new TwilsockChannel(websocket, transport, config);
        _this.registrations = new Registrations(transport);
        _this.upstream = new Upstream(transport, _this.channel, config);
        _this.telemetryTracker = new TelemetryTracker(config, transport);
        _this.channel.on("initialized", function() {
          return _this.telemetryTracker.canSendTelemetry = true;
        });
        websocket.on("disconnected", function() {
          return _this.telemetryTracker.canSendTelemetry = false;
        });
        _this.registrations.on("registered", function(id) {
          return _this.emit("registered", id);
        });
        _this.channel.on("message", function(type, message) {
          return setTimeout(function() {
            return _this.emit("message", type, message);
          }, 0);
        });
        _this.channel.on("stateChanged", function(state) {
          return setTimeout(function() {
            return _this.emit("stateChanged", state);
          }, 0);
        });
        _this.channel.on("connectionError", function(connectionError) {
          return setTimeout(function() {
            return _this.emit("connectionError", connectionError);
          }, 0);
        });
        _this.channel.on("tokenAboutToExpire", function() {
          return setTimeout(function() {
            return _this.emit("tokenAboutToExpire");
          }, 0);
        });
        _this.channel.on("tokenExpired", function() {
          return setTimeout(function() {
            return _this.emit("tokenExpired");
          }, 0);
        });
        _this.channel.on("connected", function() {
          return _this.registrations.updateRegistrations();
        });
        _this.channel.on("connected", function() {
          return _this.upstream.sendPendingMessages();
        });
        _this.channel.on("connected", function() {
          return setTimeout(function() {
            return _this.emit("connected");
          }, 0);
        });
        _this.channel.on("beforeConnect", function() {
          return _this.telemetryTracker.addPartialEvent(new TelemetryEventDescription("Establish WebSocket connection", "", /* @__PURE__ */ new Date()), TelemetryEvents.TWILSOCK_CONNECT, exports.TelemetryPoint.Start);
        });
        _this.channel.on("connected", function() {
          return _this.telemetryTracker.addPartialEvent(new TelemetryEventDescription("Establish WebSocket connection", "", /* @__PURE__ */ new Date(), /* @__PURE__ */ new Date()), TelemetryEvents.TWILSOCK_CONNECT, exports.TelemetryPoint.End);
        });
        _this.channel.on("beforeSendInit", function() {
          return _this.telemetryTracker.addPartialEvent(new TelemetryEventDescription("Send Twilsock init", "", /* @__PURE__ */ new Date()), TelemetryEvents.TWILSOCK_INIT, exports.TelemetryPoint.Start);
        });
        _this.channel.on("initialized", function() {
          return _this.telemetryTracker.addPartialEvent(new TelemetryEventDescription("Send Twilsock init", "Succeeded", /* @__PURE__ */ new Date(), /* @__PURE__ */ new Date()), TelemetryEvents.TWILSOCK_INIT, exports.TelemetryPoint.End);
        });
        _this.channel.on("sendInitFailed", function() {
          return _this.telemetryTracker.addPartialEvent(new TelemetryEventDescription("Send Twilsock init", "Failed", /* @__PURE__ */ new Date(), /* @__PURE__ */ new Date()), TelemetryEvents.TWILSOCK_INIT, exports.TelemetryPoint.End);
        });
        _this.channel.on("initialized", function(initReply) {
          _this.handleStorageId(productId, initReply);
          TokenStorage$1.storeToken(initReply.continuationToken, productId);
          setTimeout(function() {
            return _this.emit("initialized", initReply);
          }, 0);
        });
        _this.channel.on("disconnected", function() {
          return setTimeout(function() {
            return _this.emit("disconnected");
          }, 0);
        });
        _this.channel.on("disconnected", function() {
          return _this.upstream.rejectPendingMessages();
        });
        _this.channel.on("disconnected", function() {
          return _this.offlineStorageDeferred.fail(new TwilsockError("Client disconnected"));
        });
        _this.offlineStorageDeferred.promise.catch(function() {
          return void 0;
        });
        return _this;
      }
      _createClass__default["default"](TwilsockClient, [{
        key: "emit",
        value: function emit(event) {
          var _get2;
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          logInstance.debug("Emitting ".concat(event.toString(), "(").concat(args.map(function(a) {
            return JSON.stringify(a);
          }).join(", "), ")"));
          return (_get2 = _get__default["default"](_getPrototypeOf__default["default"](TwilsockClient.prototype), "emit", this)).call.apply(_get2, [this, event].concat(args));
        }
      }, {
        key: "handleStorageId",
        value: function handleStorageId(productId, initReply) {
          if (!initReply.offlineStorage) {
            this.offlineStorageDeferred.fail(new TwilsockError("No offline storage id"));
          } else if (initReply.offlineStorage.hasOwnProperty(productId)) {
            try {
              this.offlineStorageDeferred.set(OfflineProductStorage.create(initReply.offlineStorage[productId]));
              logInstance.debug("Offline storage for '".concat(productId, "' product: ").concat(JSON.stringify(initReply.offlineStorage[productId]), "."));
            } catch (e) {
              this.offlineStorageDeferred.fail(new TwilsockError("Failed to parse offline storage for ".concat(productId, " ").concat(JSON.stringify(initReply.offlineStorage[productId]), ". ").concat(e, ".")));
            }
          } else {
            this.offlineStorageDeferred.fail(new TwilsockError("No offline storage id for '".concat(productId, "' product: ").concat(JSON.stringify(initReply.offlineStorage))));
          }
        }
        /**
         * Get offline storage ID
         * @returns {Promise}
         */
      }, {
        key: "storageId",
        value: function storageId() {
          return this.offlineStorageDeferred.promise;
        }
        /**
         * Indicates if twilsock is connected now
         * @returns {Boolean}
         */
      }, {
        key: "isConnected",
        get: function get() {
          return this.channel.isConnected;
        }
        /**
         * Current state
         * @returns {ConnectionState}
         */
      }, {
        key: "state",
        get: function get() {
          return this.channel.state;
        }
        /**
         * Update token
         * @param {String} token
         * @returns {Promise}
         */
      }, {
        key: "updateToken",
        value: function() {
          var _updateToken = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee(token) {
            return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    logInstance.trace("updating token '".concat(token, "'"));
                    if (!(this.config.token === token)) {
                      _context.next = 3;
                      break;
                    }
                    return _context.abrupt("return");
                  case 3:
                    this.config.updateToken(token);
                    _context.next = 6;
                    return this.channel.updateToken(token);
                  case 6:
                    return _context.abrupt("return", _context.sent);
                  case 7:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function updateToken(_x) {
            return _updateToken.apply(this, arguments);
          }
          return updateToken;
        }()
        /**
         * Updates notification context.
         * This method shouldn't be used anyone except twilio notifications library
         * @param contextId id of notification context
         * @param context value of notification context
         * @private
         */
      }, {
        key: "setNotificationsContext",
        value: function() {
          var _setNotificationsContext = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee2(contextId, context) {
            return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.next = 2;
                    return this.registrations.setNotificationsContext(contextId, context);
                  case 2:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function setNotificationsContext(_x2, _x3) {
            return _setNotificationsContext.apply(this, arguments);
          }
          return setNotificationsContext;
        }()
        /**
         * Remove notification context.
         * This method shouldn't be used anyone except twilio notifications library
         * @param contextId id of notification context
         * @private
         */
      }, {
        key: "removeNotificationsContext",
        value: function() {
          var _removeNotificationsContext = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee3(contextId) {
            return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    _context3.next = 2;
                    return this.registrations.removeNotificationsContext(contextId);
                  case 2:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));
          function removeNotificationsContext(_x4) {
            return _removeNotificationsContext.apply(this, arguments);
          }
          return removeNotificationsContext;
        }()
        /**
         * Connect to the server
         * @fires Twilsock#connected
         * @public
         * @returns {void}
         */
      }, {
        key: "connect",
        value: function connect() {
          return this.channel.connect();
        }
        /**
         * Disconnect from the server
         * @fires Twilsock#disconnected
         * @public
         * @returns {Promise}
         */
      }, {
        key: "disconnect",
        value: function() {
          var _disconnect = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee4() {
            return _regeneratorRuntime__default["default"].wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    this.telemetryTracker.sendTelemetry(exports.EventSendingLimitation.AnyEventsIncludingUnfinished);
                    _context4.next = 3;
                    return this.channel.disconnect();
                  case 3:
                    return _context4.abrupt("return", _context4.sent);
                  case 4:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));
          function disconnect() {
            return _disconnect.apply(this, arguments);
          }
          return disconnect;
        }()
        /**
         * Get HTTP request to upstream service
         * @param {string} url Upstream service url
         * @param {headers} headers Set of custom headers
         * @param {string} [grant] The product grant
         * @returns {Promise}
         */
      }, {
        key: "get",
        value: function() {
          var _get3 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee5(url, headers, grant) {
            return _regeneratorRuntime__default["default"].wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    this.telemetryTracker.sendTelemetry(exports.EventSendingLimitation.AnyEvents);
                    _context5.next = 3;
                    return this.upstream.send("GET", url, headers, void 0, grant);
                  case 3:
                    return _context5.abrupt("return", _context5.sent);
                  case 4:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));
          function get(_x5, _x6, _x7) {
            return _get3.apply(this, arguments);
          }
          return get;
        }()
        /**
         * Post HTTP request to upstream service
         * @param {string} url Upstream service url
         * @param {headers} headers Set of custom headers
         * @param {body} body Body to send
         * @param {string} [grant] The product grant
         * @returns {Promise}
         */
      }, {
        key: "post",
        value: function() {
          var _post = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee6(url, headers, body, grant) {
            return _regeneratorRuntime__default["default"].wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    this.telemetryTracker.sendTelemetry(exports.EventSendingLimitation.AnyEvents);
                    _context6.next = 3;
                    return this.upstream.send("POST", url, headers, body, grant);
                  case 3:
                    return _context6.abrupt("return", _context6.sent);
                  case 4:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, this);
          }));
          function post(_x8, _x9, _x10, _x11) {
            return _post.apply(this, arguments);
          }
          return post;
        }()
        /**
         * Put HTTP request to upstream service
         * @param {string} url Upstream service url
         * @param {headers} headers Set of custom headers
         * @param {body} body Body to send
         * @param {string} [grant] The product grant
         * @returns {Promise}
         */
      }, {
        key: "put",
        value: function() {
          var _put = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee7(url, headers, body, grant) {
            return _regeneratorRuntime__default["default"].wrap(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    this.telemetryTracker.sendTelemetry(exports.EventSendingLimitation.AnyEvents);
                    _context7.next = 3;
                    return this.upstream.send("PUT", url, headers, body, grant);
                  case 3:
                    return _context7.abrupt("return", _context7.sent);
                  case 4:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee7, this);
          }));
          function put(_x12, _x13, _x14, _x15) {
            return _put.apply(this, arguments);
          }
          return put;
        }()
        /**
         * Delete HTTP request to upstream service
         * @param {string} url Upstream service url
         * @param {headers} headers Set of custom headers
         * @param {body} body Body to send
         * @param {string} [grant] The product grant
         * @returns {Promise}
         */
      }, {
        key: "delete",
        value: function() {
          var _delete2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee8(url, headers, body, grant) {
            return _regeneratorRuntime__default["default"].wrap(function _callee8$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    this.telemetryTracker.sendTelemetry(exports.EventSendingLimitation.AnyEvents);
                    _context8.next = 3;
                    return this.upstream.send("DELETE", url, headers, body, grant);
                  case 3:
                    return _context8.abrupt("return", _context8.sent);
                  case 4:
                  case "end":
                    return _context8.stop();
                }
              }
            }, _callee8, this);
          }));
          function _delete(_x16, _x17, _x18, _x19) {
            return _delete2.apply(this, arguments);
          }
          return _delete;
        }()
        /**
         * Submits internal telemetry event. Not to be used for any customer and/or sensitive data.
         * @param {TelemetryEventDescription} event Event details.
         * @returns {void}
         */
      }, {
        key: "addTelemetryEvent",
        value: function addTelemetryEvent(event) {
          this.telemetryTracker.addTelemetryEvent(event);
          this.telemetryTracker.sendTelemetryIfMinimalPortionCollected();
        }
        /**
         * Submits internal telemetry event. Not to be used for any customer and/or sensitive data.
         * @param {TelemetryEventDescription} event Event details.
         * @param {string} eventKey Unique event key.
         * @param {TelemetryPoint} point Is this partial event for start or end of measurement.
         * @returns {void}
         */
      }, {
        key: "addPartialTelemetryEvent",
        value: function addPartialTelemetryEvent(event, eventKey, point) {
          this.telemetryTracker.addPartialEvent(event, eventKey, point);
          if (point === exports.TelemetryPoint.End) {
            this.telemetryTracker.sendTelemetryIfMinimalPortionCollected();
          }
        }
      }]);
      return TwilsockClient;
    }(EventEmitter);
    exports.TwilsockClient = __decorate([declarativeTypeValidator.validateConstructorTypes(declarativeTypeValidator.nonEmptyString, declarativeTypeValidator.nonEmptyString, [declarativeTypeValidator.pureObject, "undefined", declarativeTypeValidator.literal(null)]), __metadata("design:paramtypes", [String, String, Object])], exports.TwilsockClient);
    var InitRegistration = function() {
      function InitRegistration2(product) {
        _classCallCheck__default["default"](this, InitRegistration2);
        this.product = product;
        this.type = "ers";
        this.notification_protocol_version = 0;
        this.message_types = [];
      }
      _createClass__default["default"](InitRegistration2, [{
        key: "populateInitRegistrations",
        value: function populateInitRegistrations(types) {
          var s = new Set(this.message_types);
          for (var idx in types) {
            s.add(types[idx]);
          }
          this.message_types = Array.from(s);
        }
      }]);
      return InitRegistration2;
    }();
    exports.InitRegistration = InitRegistration;
    exports.TelemetryEventDescription = TelemetryEventDescription;
    exports.TelemetryTracker = TelemetryTracker;
    exports.TransportUnavailableError = TransportUnavailableError;
    exports.Twilsock = exports.TwilsockClient;
    exports.TwilsockError = TwilsockError;
  }
});

// node_modules/core-js/internals/object-assign.js
var require_object_assign = __commonJS({
  "node_modules/core-js/internals/object-assign.js"(exports, module) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var uncurryThis = require_function_uncurry_this();
    var call = require_function_call();
    var fails = require_fails();
    var objectKeys = require_object_keys();
    var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();
    var propertyIsEnumerableModule = require_object_property_is_enumerable();
    var toObject = require_to_object();
    var IndexedObject = require_indexed_object();
    var $assign = Object.assign;
    var defineProperty = Object.defineProperty;
    var concat = uncurryThis([].concat);
    module.exports = !$assign || fails(function() {
      if (DESCRIPTORS && $assign({ b: 1 }, $assign(defineProperty({}, "a", {
        enumerable: true,
        get: function() {
          defineProperty(this, "b", {
            value: 3,
            enumerable: false
          });
        }
      }), { b: 2 })).b !== 1) return true;
      var A = {};
      var B = {};
      var symbol = Symbol("assign detection");
      var alphabet = "abcdefghijklmnopqrst";
      A[symbol] = 7;
      alphabet.split("").forEach(function(chr) {
        B[chr] = chr;
      });
      return $assign({}, A)[symbol] !== 7 || objectKeys($assign({}, B)).join("") !== alphabet;
    }) ? function assign(target, source) {
      var T = toObject(target);
      var argumentsLength = arguments.length;
      var index = 1;
      var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
      var propertyIsEnumerable = propertyIsEnumerableModule.f;
      while (argumentsLength > index) {
        var S = IndexedObject(arguments[index++]);
        var keys = getOwnPropertySymbols ? concat(objectKeys(S), getOwnPropertySymbols(S)) : objectKeys(S);
        var length = keys.length;
        var j = 0;
        var key;
        while (length > j) {
          key = keys[j++];
          if (!DESCRIPTORS || call(propertyIsEnumerable, S, key)) T[key] = S[key];
        }
      }
      return T;
    } : $assign;
  }
});

// node_modules/core-js/modules/es.object.assign.js
var require_es_object_assign = __commonJS({
  "node_modules/core-js/modules/es.object.assign.js"() {
    "use strict";
    var $ = require_export();
    var assign = require_object_assign();
    $({ target: "Object", stat: true, arity: 2, forced: Object.assign !== assign }, {
      assign
    });
  }
});

// node_modules/@twilio/conversations/node_modules/uuid/lib/rng-browser.js
var require_rng_browser2 = __commonJS({
  "node_modules/@twilio/conversations/node_modules/uuid/lib/rng-browser.js"(exports, module) {
    var getRandomValues = typeof crypto != "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != "undefined" && typeof window.msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (getRandomValues) {
      rnds8 = new Uint8Array(16);
      module.exports = function whatwgRNG() {
        getRandomValues(rnds8);
        return rnds8;
      };
    } else {
      rnds = new Array(16);
      module.exports = function mathRNG() {
        for (var i = 0, r; i < 16; i++) {
          if ((i & 3) === 0) r = Math.random() * 4294967296;
          rnds[i] = r >>> ((i & 3) << 3) & 255;
        }
        return rnds;
      };
    }
    var rnds8;
    var rnds;
  }
});

// node_modules/@twilio/conversations/node_modules/uuid/lib/bytesToUuid.js
var require_bytesToUuid2 = __commonJS({
  "node_modules/@twilio/conversations/node_modules/uuid/lib/bytesToUuid.js"(exports, module) {
    var byteToHex = [];
    for (i = 0; i < 256; ++i) {
      byteToHex[i] = (i + 256).toString(16).substr(1);
    }
    var i;
    function bytesToUuid(buf, offset) {
      var i2 = offset || 0;
      var bth = byteToHex;
      return [
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]]
      ].join("");
    }
    module.exports = bytesToUuid;
  }
});

// node_modules/@twilio/conversations/node_modules/uuid/v1.js
var require_v12 = __commonJS({
  "node_modules/@twilio/conversations/node_modules/uuid/v1.js"(exports, module) {
    var rng = require_rng_browser2();
    var bytesToUuid = require_bytesToUuid2();
    var _nodeId;
    var _clockseq;
    var _lastMSecs = 0;
    var _lastNSecs = 0;
    function v1(options, buf, offset) {
      var i = buf && offset || 0;
      var b = buf || [];
      options = options || {};
      var node = options.node || _nodeId;
      var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
      if (node == null || clockseq == null) {
        var seedBytes = rng();
        if (node == null) {
          node = _nodeId = [
            seedBytes[0] | 1,
            seedBytes[1],
            seedBytes[2],
            seedBytes[3],
            seedBytes[4],
            seedBytes[5]
          ];
        }
        if (clockseq == null) {
          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
        }
      }
      var msecs = options.msecs !== void 0 ? options.msecs : (/* @__PURE__ */ new Date()).getTime();
      var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
      var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
      if (dt < 0 && options.clockseq === void 0) {
        clockseq = clockseq + 1 & 16383;
      }
      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
        nsecs = 0;
      }
      if (nsecs >= 1e4) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;
      msecs += 122192928e5;
      var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      b[i++] = tl >>> 24 & 255;
      b[i++] = tl >>> 16 & 255;
      b[i++] = tl >>> 8 & 255;
      b[i++] = tl & 255;
      var tmh = msecs / 4294967296 * 1e4 & 268435455;
      b[i++] = tmh >>> 8 & 255;
      b[i++] = tmh & 255;
      b[i++] = tmh >>> 24 & 15 | 16;
      b[i++] = tmh >>> 16 & 255;
      b[i++] = clockseq >>> 8 | 128;
      b[i++] = clockseq & 255;
      for (var n = 0; n < 6; ++n) {
        b[i + n] = node[n];
      }
      return buf ? buf : bytesToUuid(b);
    }
    module.exports = v1;
  }
});

// node_modules/@twilio/conversations/node_modules/uuid/v4.js
var require_v42 = __commonJS({
  "node_modules/@twilio/conversations/node_modules/uuid/v4.js"(exports, module) {
    var rng = require_rng_browser2();
    var bytesToUuid = require_bytesToUuid2();
    function v4(options, buf, offset) {
      var i = buf && offset || 0;
      if (typeof options == "string") {
        buf = options === "binary" ? new Array(16) : null;
        options = null;
      }
      options = options || {};
      var rnds = options.random || (options.rng || rng)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        for (var ii = 0; ii < 16; ++ii) {
          buf[i + ii] = rnds[ii];
        }
      }
      return buf || bytesToUuid(rnds);
    }
    module.exports = v4;
  }
});

// node_modules/@twilio/conversations/node_modules/uuid/index.js
var require_uuid2 = __commonJS({
  "node_modules/@twilio/conversations/node_modules/uuid/index.js"(exports, module) {
    var v1 = require_v12();
    var v4 = require_v42();
    var uuid = v4;
    uuid.v1 = v1;
    uuid.v4 = v4;
    module.exports = uuid;
  }
});

// node_modules/@twilio/conversations/node_modules/@twilio/notifications/builds/browser.js
var require_browser6 = __commonJS({
  "node_modules/@twilio/conversations/node_modules/@twilio/notifications/builds/browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    require_es_reflect_to_string_tag();
    require_es_reflect_construct();
    var _asyncToGenerator = require_asyncToGenerator();
    var _classCallCheck = require_classCallCheck();
    var _createClass = require_createClass();
    var _inherits = require_inherits();
    var _possibleConstructorReturn = require_possibleConstructorReturn();
    var _getPrototypeOf = require_getPrototypeOf();
    var _regeneratorRuntime = require_regenerator2();
    require_es_array_iterator();
    require_es_map();
    require_es_object_to_string();
    require_es_string_iterator();
    require_web_dom_collections_iterator();
    require_es_array_concat();
    require_web_dom_collections_for_each();
    require_es_promise();
    var _typeof = require_typeof();
    var twilsock = require_browser5();
    var _assertThisInitialized = require_assertThisInitialized();
    var _defineProperty = require_defineProperty();
    require_es_regexp_to_string();
    require_es_array_from();
    require_es_object_assign();
    var operationRetrier = require_browser3();
    var _slicedToArray = require_slicedToArray();
    var _toConsumableArray = require_toConsumableArray();
    require_es_set();
    require_es_array_filter();
    var logger = require_loglevel();
    var uuid = require_uuid2();
    var declarativeTypeValidator = require_browser();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    function _interopNamespace(e) {
      if (e && e.__esModule) return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var _asyncToGenerator__default = _interopDefaultLegacy(_asyncToGenerator);
    var _classCallCheck__default = _interopDefaultLegacy(_classCallCheck);
    var _createClass__default = _interopDefaultLegacy(_createClass);
    var _inherits__default = _interopDefaultLegacy(_inherits);
    var _possibleConstructorReturn__default = _interopDefaultLegacy(_possibleConstructorReturn);
    var _getPrototypeOf__default = _interopDefaultLegacy(_getPrototypeOf);
    var _regeneratorRuntime__default = _interopDefaultLegacy(_regeneratorRuntime);
    var _typeof__default = _interopDefaultLegacy(_typeof);
    var _assertThisInitialized__default = _interopDefaultLegacy(_assertThisInitialized);
    var _defineProperty__default = _interopDefaultLegacy(_defineProperty);
    var _slicedToArray__default = _interopDefaultLegacy(_slicedToArray);
    var _toConsumableArray__default = _interopDefaultLegacy(_toConsumableArray);
    var logger__namespace = _interopNamespace(logger);
    var uuid__namespace = _interopNamespace(uuid);
    function __decorate(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ((typeof Reflect === "undefined" ? "undefined" : _typeof__default["default"](Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      }
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __metadata(metadataKey, metadataValue) {
      if ((typeof Reflect === "undefined" ? "undefined" : _typeof__default["default"](Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }
    var domain;
    function EventHandlers() {
    }
    EventHandlers.prototype = /* @__PURE__ */ Object.create(null);
    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.usingDomains = false;
    EventEmitter.prototype.domain = void 0;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._maxListeners = void 0;
    EventEmitter.defaultMaxListeners = 10;
    EventEmitter.init = function() {
      this.domain = null;
      if (EventEmitter.usingDomains) {
        if (domain.active) ;
      }
      if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
        this._events = new EventHandlers();
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || isNaN(n))
        throw new TypeError('"n" argument must be a positive number');
      this._maxListeners = n;
      return this;
    };
    function $getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return $getMaxListeners(this);
    };
    function emitNone(handler, isFn, self2) {
      if (isFn)
        handler.call(self2);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self2);
      }
    }
    function emitOne(handler, isFn, self2, arg1) {
      if (isFn)
        handler.call(self2, arg1);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self2, arg1);
      }
    }
    function emitTwo(handler, isFn, self2, arg1, arg2) {
      if (isFn)
        handler.call(self2, arg1, arg2);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self2, arg1, arg2);
      }
    }
    function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
      if (isFn)
        handler.call(self2, arg1, arg2, arg3);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self2, arg1, arg2, arg3);
      }
    }
    function emitMany(handler, isFn, self2, args) {
      if (isFn)
        handler.apply(self2, args);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].apply(self2, args);
      }
    }
    EventEmitter.prototype.emit = function emit(type) {
      var er, handler, len, args, i, events, domain2;
      var doError = type === "error";
      events = this._events;
      if (events)
        doError = doError && events.error == null;
      else if (!doError)
        return false;
      domain2 = this.domain;
      if (doError) {
        er = arguments[1];
        if (domain2) {
          if (!er)
            er = new Error('Uncaught, unspecified "error" event');
          er.domainEmitter = this;
          er.domain = domain2;
          er.domainThrown = false;
          domain2.emit("error", er);
        } else if (er instanceof Error) {
          throw er;
        } else {
          var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
          err.context = er;
          throw err;
        }
        return false;
      }
      handler = events[type];
      if (!handler)
        return false;
      var isFn = typeof handler === "function";
      len = arguments.length;
      switch (len) {
        case 1:
          emitNone(handler, isFn, this);
          break;
        case 2:
          emitOne(handler, isFn, this, arguments[1]);
          break;
        case 3:
          emitTwo(handler, isFn, this, arguments[1], arguments[2]);
          break;
        case 4:
          emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
          break;
        default:
          args = new Array(len - 1);
          for (i = 1; i < len; i++)
            args[i - 1] = arguments[i];
          emitMany(handler, isFn, this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      events = target._events;
      if (!events) {
        events = target._events = new EventHandlers();
        target._eventsCount = 0;
      } else {
        if (events.newListener) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (!existing) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else {
          if (prepend) {
            existing.unshift(listener);
          } else {
            existing.push(listener);
          }
        }
        if (!existing.warned) {
          m = $getMaxListeners(target);
          if (m && m > 0 && existing.length > m) {
            existing.warned = true;
            var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type + " listeners added. Use emitter.setMaxListeners() to increase limit");
            w.name = "MaxListenersExceededWarning";
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            emitWarning(w);
          }
        }
      }
      return target;
    }
    function emitWarning(e) {
      typeof console.warn === "function" ? console.warn(e) : console.log(e);
    }
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function _onceWrap(target, type, listener) {
      var fired = false;
      function g() {
        target.removeListener(type, g);
        if (!fired) {
          fired = true;
          listener.apply(target, arguments);
        }
      }
      g.listener = listener;
      return g;
    }
    EventEmitter.prototype.once = function once(type, listener) {
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      events = this._events;
      if (!events)
        return this;
      list = events[type];
      if (!list)
        return this;
      if (list === listener || list.listener && list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = new EventHandlers();
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length; i-- > 0; ) {
          if (list[i] === listener || list[i].listener && list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (list.length === 1) {
          list[0] = void 0;
          if (--this._eventsCount === 0) {
            this._events = new EventHandlers();
            return this;
          } else {
            delete events[type];
          }
        } else {
          spliceOne(list, position);
        }
        if (events.removeListener)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.off = function(type, listener) {
      return this.removeListener(type, listener);
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events;
      events = this._events;
      if (!events)
        return this;
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        for (var i = 0, key; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener") continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = new EventHandlers();
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners) {
        do {
          this.removeListener(type, listeners[listeners.length - 1]);
        } while (listeners[0]);
      }
      return this;
    };
    EventEmitter.prototype.listeners = function listeners(type) {
      var evlistener;
      var ret;
      var events = this._events;
      if (!events)
        ret = [];
      else {
        evlistener = events[type];
        if (!evlistener)
          ret = [];
        else if (typeof evlistener === "function")
          ret = [evlistener.listener || evlistener];
        else
          ret = unwrapListeners(evlistener);
      }
      return ret;
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
    };
    function spliceOne(list, index) {
      for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
        list[i] = list[k];
      list.pop();
    }
    function arrayClone(arr, i) {
      var copy = new Array(i);
      while (i--)
        copy[i] = arr[i];
      return copy;
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    var log = logger__namespace.getLogger("twilio-notificatiions");
    function prepareLine(prefix, args) {
      return ["".concat((/* @__PURE__ */ new Date()).toISOString(), " Twilio.Notifications ").concat(prefix, ":")].concat(Array.from(args));
    }
    var Logger = function() {
      function Logger2() {
        _classCallCheck__default["default"](this, Logger2);
      }
      _createClass__default["default"](Logger2, [{
        key: "setLevel",
        value: function setLevel(level) {
          log.setLevel(level);
        }
      }, {
        key: "trace",
        value: function trace() {
          if (log.getLevel() == log.levels.TRACE) {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            log.debug.apply(null, prepareLine("T", args));
          }
        }
      }, {
        key: "debug",
        value: function debug() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          log.debug.apply(null, prepareLine("D", args));
        }
      }, {
        key: "info",
        value: function info() {
          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }
          log.info.apply(null, prepareLine("I", args));
        }
      }, {
        key: "warn",
        value: function warn() {
          for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args[_key4] = arguments[_key4];
          }
          log.warn.apply(null, prepareLine("W", args));
        }
      }, {
        key: "error",
        value: function error() {
          for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
            args[_key5] = arguments[_key5];
          }
          log.error.apply(null, prepareLine("E", args));
        }
      }]);
      return Logger2;
    }();
    var logInstance = new Logger();
    function _createSuper$3(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$3() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var RegistrationState = _createClass__default["default"](function RegistrationState2() {
      var token = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var notificationId = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var messageTypes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : /* @__PURE__ */ new Set();
      _classCallCheck__default["default"](this, RegistrationState2);
      this.token = token;
      this.notificationId = notificationId;
      this.messageTypes = messageTypes;
    });
    function setDifference(a, b) {
      return [].concat(_toConsumableArray__default["default"](_toConsumableArray__default["default"](a).filter(function(x) {
        return !b.has(x);
      })), _toConsumableArray__default["default"](_toConsumableArray__default["default"](b).filter(function(x) {
        return !a.has(x);
      })));
    }
    function hasDifference(a, b) {
      var reasons = /* @__PURE__ */ new Set();
      if (a.notificationId !== b.notificationId) {
        reasons.add("notificationId");
      }
      if (a.token !== b.token) {
        reasons.add("token");
      }
      if (setDifference(a.messageTypes, b.messageTypes).length > 0) {
        reasons.add("messageType");
      }
      return [reasons.size > 0, reasons];
    }
    var Connector = function(_EventEmitter) {
      _inherits__default["default"](Connector2, _EventEmitter);
      var _super = _createSuper$3(Connector2);
      function Connector2(channelType) {
        var _this;
        _classCallCheck__default["default"](this, Connector2);
        _this = _super.call(this);
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "desiredState", new RegistrationState());
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "currentState", new RegistrationState());
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "_hasActiveAttempt", false);
        _this.channelType = channelType;
        return _this;
      }
      _createClass__default["default"](Connector2, [{
        key: "setNotificationId",
        value: function setNotificationId(notificationId) {
          this.desiredState.notificationId = notificationId;
        }
        /**
         * Return true is this connector is in usable state and should be able to commit changes.
         */
      }, {
        key: "isActive",
        value: function isActive() {
          return this.desiredState.notificationId !== "";
        }
      }, {
        key: "subscribe",
        value: function subscribe(messageType) {
          if (this.desiredState.messageTypes.has(messageType)) {
            logInstance.debug("message type '".concat(messageType, "' for channel ").concat(this.channelType, " is already registered"));
            return;
          }
          this.desiredState.messageTypes.add(messageType);
        }
      }, {
        key: "unsubscribe",
        value: function unsubscribe(messageType) {
          if (!this.desiredState.messageTypes.has(messageType)) {
            return;
          }
          this.desiredState.messageTypes.delete(messageType);
        }
      }, {
        key: "updateToken",
        value: function updateToken(token) {
          this.desiredState.token = token;
        }
        /**
         * Perform actual registration after all required changes are settled.
         */
      }, {
        key: "commitChanges",
        value: function() {
          var _commitChanges = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee() {
            var _hasDifference, _hasDifference2, needToUpdate, reasons, stateToPersist, persistedState;
            return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (!this._hasActiveAttempt) {
                      _context.next = 3;
                      break;
                    }
                    logInstance.error("One registration attempt is already in progress");
                    throw new Error("One registration attempt is already in progress");
                  case 3:
                    _hasDifference = hasDifference(this.desiredState, this.currentState), _hasDifference2 = _slicedToArray__default["default"](_hasDifference, 2), needToUpdate = _hasDifference2[0], reasons = _hasDifference2[1];
                    if (needToUpdate) {
                      _context.next = 6;
                      break;
                    }
                    return _context.abrupt("return");
                  case 6:
                    if (!this.currentState.notificationId) {
                      reasons.delete("notificationId");
                    }
                    logInstance.trace("Persisting ".concat(this.channelType, " registration"), reasons, this.desiredState);
                    _context.prev = 8;
                    this._hasActiveAttempt = true;
                    stateToPersist = new RegistrationState();
                    stateToPersist.token = this.desiredState.token;
                    stateToPersist.notificationId = this.desiredState.notificationId;
                    stateToPersist.messageTypes = new Set(this.desiredState.messageTypes);
                    if (!(stateToPersist.messageTypes.size > 0)) {
                      _context.next = 24;
                      break;
                    }
                    _context.next = 17;
                    return this.updateRegistration(stateToPersist, reasons);
                  case 17:
                    persistedState = _context.sent;
                    this.currentState.token = persistedState.token;
                    this.currentState.notificationId = persistedState.notificationId;
                    this.currentState.messageTypes = new Set(persistedState.messageTypes);
                    this.emit("stateChanged", this.channelType, "registered", this.currentState);
                    _context.next = 30;
                    break;
                  case 24:
                    _context.next = 26;
                    return this.removeRegistration();
                  case 26:
                    this.currentState.token = stateToPersist.token;
                    this.currentState.notificationId = stateToPersist.notificationId;
                    this.currentState.messageTypes.clear();
                    this.emit("stateChanged", this.channelType, "unregistered", this.currentState);
                  case 30:
                    _context.next = 35;
                    break;
                  case 32:
                    _context.prev = 32;
                    _context.t0 = _context["catch"](8);
                    throw _context.t0;
                  case 35:
                    _context.prev = 35;
                    this._hasActiveAttempt = false;
                    return _context.finish(35);
                  case 38:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[8, 32, 35, 38]]);
          }));
          function commitChanges() {
            return _commitChanges.apply(this, arguments);
          }
          return commitChanges;
        }()
      }]);
      return Connector2;
    }(EventEmitter);
    function _createSuper$2(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$2() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var retrierConfig = {
      min: 2e3,
      max: 12e4,
      randomness: 0.2
    };
    var RegistrarConnector = function(_Connector) {
      _inherits__default["default"](RegistrarConnector2, _Connector);
      var _super = _createSuper$2(RegistrarConnector2);
      function RegistrarConnector2(channelType, context, twilsock2, registrarUrl) {
        var _this;
        _classCallCheck__default["default"](this, RegistrarConnector2);
        _this = _super.call(this, channelType);
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "registrationId", null);
        _this.context = context;
        _this.twilsock = twilsock2;
        _this.registrarUrl = registrarUrl;
        return _this;
      }
      _createClass__default["default"](RegistrarConnector2, [{
        key: "updateRegistration",
        value: function() {
          var _updateRegistration = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee(registration, reasons) {
            var _this2 = this;
            var registrarRequest, productId, url, headers, response;
            return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (!reasons.has("notificationId")) {
                      _context.next = 3;
                      break;
                    }
                    _context.next = 3;
                    return this.removeRegistration();
                  case 3:
                    if (!(!registration.notificationId || !registration.notificationId.length)) {
                      _context.next = 6;
                      break;
                    }
                    logInstance.error("No push notification ID for registration");
                    throw new Error("No push notification ID for registration");
                  case 6:
                    logInstance.trace("Registering", this.channelType, registration);
                    registrarRequest = {
                      endpoint_platform: this.context.platform,
                      channel_type: this.channelType,
                      version: this.context.protocolVersion.toString(),
                      message_types: Array.from(registration.messageTypes),
                      data: {
                        registration_id: registration.notificationId
                      }
                      //ttl: 'PT24H' - This is totally ignored by notify, all bindings use PT1Y ttl.
                    };
                    productId = this.context.productId;
                    url = "".concat(this.registrarUrl, "?productId=").concat(productId);
                    headers = {
                      "Content-Type": "application/json"
                      // 'X-Twilio-Token': registration.token
                    };
                    logInstance.trace("Creating registration for channel ".concat(this.channelType));
                    _context.prev = 12;
                    _context.next = 15;
                    return new operationRetrier.AsyncRetrier(retrierConfig).run(function() {
                      return _this2.twilsock.post(url, headers, registrarRequest, productId);
                    });
                  case 15:
                    response = _context.sent;
                    this.registrationId = response.body.id;
                    logInstance.debug("Registration created: ", response);
                    _context.next = 24;
                    break;
                  case 20:
                    _context.prev = 20;
                    _context.t0 = _context["catch"](12);
                    logInstance.error("Registration failed: ", _context.t0);
                    throw _context.t0;
                  case 24:
                    return _context.abrupt("return", registration);
                  case 25:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[12, 20]]);
          }));
          function updateRegistration(_x, _x2) {
            return _updateRegistration.apply(this, arguments);
          }
          return updateRegistration;
        }()
      }, {
        key: "removeRegistration",
        value: function() {
          var _removeRegistration = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee2() {
            var _this3 = this;
            var productId, url, headers;
            return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    if (this.registrationId) {
                      _context2.next = 2;
                      break;
                    }
                    return _context2.abrupt("return");
                  case 2:
                    productId = this.context.productId;
                    url = "".concat(this.registrarUrl, "/").concat(this.registrationId, "?productId=").concat(productId);
                    headers = {
                      "Content-Type": "application/json"
                      // 'X-Twilio-Token': this.config.token
                    };
                    logInstance.trace("Removing registration for ".concat(this.channelType));
                    _context2.prev = 6;
                    _context2.next = 9;
                    return new operationRetrier.AsyncRetrier(Object.assign(retrierConfig, {
                      maxAttemptsCount: 3
                    })).run(function() {
                      return _this3.twilsock.delete(url, headers, {}, productId);
                    });
                  case 9:
                    this.registrationId = null;
                    this.currentState.notificationId = "";
                    logInstance.debug("Registration removed for ".concat(this.channelType));
                    _context2.next = 18;
                    break;
                  case 14:
                    _context2.prev = 14;
                    _context2.t0 = _context2["catch"](6);
                    logInstance.error("Failed to remove registration ", this.channelType, _context2.t0);
                    throw _context2.t0;
                  case 18:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this, [[6, 14]]);
          }));
          function removeRegistration() {
            return _removeRegistration.apply(this, arguments);
          }
          return removeRegistration;
        }()
      }, {
        key: "sendDeviceRemoveRequest",
        value: function() {
          var _sendDeviceRemoveRequest = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee3(registrationId) {
            var _this4 = this;
            var productId, url, headers, payload;
            return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    if (!(registrationId === "")) {
                      _context3.next = 2;
                      break;
                    }
                    throw new Error("Empty registration ID");
                  case 2:
                    productId = this.context.productId;
                    url = "".concat(this.registrarUrl, "?productId=").concat(productId);
                    headers = {
                      "Content-Type": "application/json"
                      // @todo Content-Length??
                    };
                    payload = {
                      binding_type: this.channelType,
                      address: registrationId
                    };
                    _context3.prev = 6;
                    logInstance.trace("Removing old registrations for ".concat(this.channelType));
                    _context3.next = 10;
                    return new operationRetrier.AsyncRetrier(Object.assign(retrierConfig, {
                      maxAttemptsCount: 3
                    })).run(function() {
                      return _this4.twilsock.delete(url, headers, payload, productId);
                    });
                  case 10:
                    this.registrationId = null;
                    this.currentState.notificationId = "";
                    logInstance.debug("Registration removed for ".concat(this.channelType));
                    _context3.next = 19;
                    break;
                  case 15:
                    _context3.prev = 15;
                    _context3.t0 = _context3["catch"](6);
                    logInstance.error("Failed to remove registration ", this.channelType, _context3.t0);
                    throw _context3.t0;
                  case 19:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this, [[6, 15]]);
          }));
          function sendDeviceRemoveRequest(_x3) {
            return _sendDeviceRemoveRequest.apply(this, arguments);
          }
          return sendDeviceRemoveRequest;
        }()
      }]);
      return RegistrarConnector2;
    }(Connector);
    function _createSuper$1(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$1() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var TwilsockConnector = function(_Connector) {
      _inherits__default["default"](TwilsockConnector2, _Connector);
      var _super = _createSuper$1(TwilsockConnector2);
      function TwilsockConnector2(productId, platform, twilsock2) {
        var _this;
        _classCallCheck__default["default"](this, TwilsockConnector2);
        _this = _super.call(this, "twilsock");
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "contextId", uuid__namespace.v4());
        _this.productId = productId;
        _this.platform = platform;
        _this.twilsock = twilsock2;
        return _this;
      }
      _createClass__default["default"](TwilsockConnector2, [{
        key: "updateRegistration",
        value: function() {
          var _updateRegistration = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee(registration, reasons) {
            var messageTypes, context;
            return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (reasons.has("messageType")) {
                      _context.next = 2;
                      break;
                    }
                    return _context.abrupt("return", registration);
                  case 2:
                    messageTypes = Array.from(registration.messageTypes);
                    context = {
                      product_id: this.productId,
                      notification_protocol_version: 4,
                      endpoint_platform: this.platform,
                      message_types: messageTypes
                    };
                    _context.prev = 4;
                    _context.next = 7;
                    return this.twilsock.setNotificationsContext(this.contextId, context);
                  case 7:
                    _context.next = 13;
                    break;
                  case 9:
                    _context.prev = 9;
                    _context.t0 = _context["catch"](4);
                    logInstance.error("Failed to update twilsock notification context: ".concat(_context.t0));
                    throw _context.t0;
                  case 13:
                    return _context.abrupt("return", registration);
                  case 14:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[4, 9]]);
          }));
          function updateRegistration(_x, _x2) {
            return _updateRegistration.apply(this, arguments);
          }
          return updateRegistration;
        }()
      }, {
        key: "removeRegistration",
        value: function() {
          var _removeRegistration = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee2() {
            return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.prev = 0;
                    _context2.next = 3;
                    return this.twilsock.removeNotificationsContext(this.contextId);
                  case 3:
                    _context2.next = 9;
                    break;
                  case 5:
                    _context2.prev = 5;
                    _context2.t0 = _context2["catch"](0);
                    logInstance.error("Failed to remove twilsock notification context: ".concat(_context2.t0));
                    throw _context2.t0;
                  case 9:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this, [[0, 5]]);
          }));
          function removeRegistration() {
            return _removeRegistration.apply(this, arguments);
          }
          return removeRegistration;
        }()
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
      }, {
        key: "sendDeviceRemoveRequest",
        value: function() {
          var _sendDeviceRemoveRequest = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee3(registrationId) {
            return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3);
          }));
          function sendDeviceRemoveRequest(_x3) {
            return _sendDeviceRemoveRequest.apply(this, arguments);
          }
          return sendDeviceRemoveRequest;
        }()
      }]);
      return TwilsockConnector2;
    }(Connector);
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var Client_1;
    var channelTypeRule = declarativeTypeValidator.literal("apn", "fcm", "twilsock");
    exports.Notifications = Client_1 = function(_EventEmitter) {
      _inherits__default["default"](Client, _EventEmitter);
      var _super = _createSuper(Client);
      function Client(token) {
        var _options$logLevel, _options$productId, _options$twilsockClie, _options$notification, _ref, _config$region;
        var _this;
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        _classCallCheck__default["default"](this, Client);
        _this = _super.call(this);
        options.logLevel = (_options$logLevel = options.logLevel) !== null && _options$logLevel !== void 0 ? _options$logLevel : "error";
        logInstance.setLevel(options.logLevel);
        var productId = (_options$productId = options.productId) !== null && _options$productId !== void 0 ? _options$productId : "notifications";
        var startTwilsock = !options.twilsockClient;
        var twilsock$1 = options.twilsockClient = (_options$twilsockClie = options.twilsockClient) !== null && _options$twilsockClie !== void 0 ? _options$twilsockClie : new twilsock.TwilsockClient(token, productId, options);
        var config = (_options$notification = options.notifications) !== null && _options$notification !== void 0 ? _options$notification : {};
        var region = (_ref = (_config$region = config.region) !== null && _config$region !== void 0 ? _config$region : options.region) !== null && _ref !== void 0 ? _ref : "us1";
        var defaultUrl = "https://ers.".concat(region, ".twilio.com/v1/registrations");
        var registrarUrl = config.ersUrl || defaultUrl;
        _this.connectors = /* @__PURE__ */ new Map();
        var platform = Client_1._detectPlatform();
        _this.connectors.set("apn", new RegistrarConnector("apn", {
          protocolVersion: 4,
          productId,
          platform
        }, twilsock$1, registrarUrl));
        _this.connectors.set("fcm", new RegistrarConnector("fcm", {
          protocolVersion: 3,
          productId,
          platform
        }, twilsock$1, registrarUrl));
        _this.connectors.set("twilsock", new TwilsockConnector(productId, platform, twilsock$1));
        twilsock$1.on("stateChanged", function(state) {
          return _this.emit("transportState", state);
        });
        _this._connector("twilsock").on("stateChanged", function(type, value, state) {
          return _this.emit("stateChanged", type, value, state);
        });
        _this._connector("apn").on("stateChanged", function(type, value, state) {
          return _this.emit("stateChanged", type, value, state);
        });
        _this._connector("fcm").on("stateChanged", function(type, value, state) {
          return _this.emit("stateChanged", type, value, state);
        });
        twilsock$1.on("message", function(type, message) {
          return _this._routeMessage(type, message);
        });
        _this.updateToken(token);
        if (startTwilsock) {
          twilsock$1.connect();
          _this.twilsock = twilsock$1;
        }
        return _this;
      }
      _createClass__default["default"](Client, [{
        key: "shutdown",
        value: function() {
          var _shutdown = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee() {
            return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    this.connectors.clear();
                    if (!this.twilsock) {
                      _context.next = 4;
                      break;
                    }
                    _context.next = 4;
                    return this.twilsock.disconnect();
                  case 4:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function shutdown() {
            return _shutdown.apply(this, arguments);
          }
          return shutdown;
        }()
        /**
         * Set OS-provided APNS/FCM registration binding for the given channel type. Not used for 'twilsock'.
         *
         * You must call this function once you've received the ID of your device from the underlying OS.
         *
         * @param {ChannelType} channelType Channel type ('apn'/'fcm').
         * @param {string} pushRegistrationId Token received from FCM/APNS system on device.
         */
      }, {
        key: "setPushRegistrationId",
        value: function setPushRegistrationId(channelType, pushRegistrationId) {
          logInstance.debug("Set ".concat(channelType, " push registration id '").concat(pushRegistrationId, "'"));
          this._connector(channelType).setNotificationId(pushRegistrationId);
        }
        /**
         * Subscribe to a given message type for a given channel type.
         *
         * Creates a subscriptions to receive incoming messages according to message type.
         * Subscription establishes a binding and you will receive a signal when a notification
         * of this type has been received by the library.
         *
         * Subscribed binding is preserved for 1 year, after which time it needs to be re-subscribed.
         * This is the responsibility of the client SDK.
         *
         * @param {ChannelType} channelType Supported are 'twilsock', 'apn' and 'fcm'
         * @param {string} messageType The type of message that you want to receive
         */
      }, {
        key: "subscribe",
        value: function subscribe(channelType, messageType) {
          logInstance.debug("Add ".concat(channelType, " subscriptions for message type ").concat(messageType));
          this._connector(channelType).subscribe(messageType);
        }
        /**
         * Unsubscribe from a given message type.
         *
         * Unsubscribing breaks a binding and you will not receive more notifications for this message type.
         * Please note that you have to call commitChanges() and receive a successful result before
         * the subscription is actually removed.
         *
         * @param {ChannelType} channelType Supported are 'twilsock', 'apn' and 'fcm'
         * @param {string} messageType The type of message that you don't want to receive anymore
         */
      }, {
        key: "unsubscribe",
        value: function unsubscribe(channelType, messageType) {
          logInstance.debug("Remove ".concat(channelType, " subscriptions for message type ").concat(messageType));
          this._connector(channelType).unsubscribe(messageType);
        }
        /**
         * Update subscription token. You must update the token when the old one expires.
         *
         * When you receive onTokenWillExpire event from twilsock, call this function with the new refreshed
         * token _after_ you have updated twilsock and other associated objects with the new token.
         *
         * @param {string} token Authentication token for registrations
         */
      }, {
        key: "updateToken",
        value: function updateToken(token) {
          this.connectors.forEach(function(connector) {
            return connector.updateToken(token);
          });
        }
        /**
         * Commit all collected subscription changes as a batched update. This function tries to reduce
         * number of network calls necessary to update bindings status.
         */
      }, {
        key: "commitChanges",
        value: function() {
          var _commitChanges = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee2() {
            var promises;
            return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    promises = [];
                    this.connectors.forEach(function(connector) {
                      if (connector.isActive()) {
                        promises.push(connector.commitChanges());
                      }
                    });
                    _context2.next = 4;
                    return Promise.all(promises);
                  case 4:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function commitChanges() {
            return _commitChanges.apply(this, arguments);
          }
          return commitChanges;
        }()
        /**
         * Clear existing registrations directly using provided device token.
         * This is useful to ensure stopped subscriptions without resubscribing.
         *
         * This function goes completely beside the state machine and removes all registrations.
         * Use with caution: if it races with current state machine operations, madness will ensue.
         *
         * @param {ChannelType} channelType Channel type ('apn'/'fcm').
         * @param {string} registrationId Token received from FCM/APNS system on device.
         */
      }, {
        key: "removeRegistrations",
        value: function() {
          var _removeRegistrations = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee3(channelType, registrationId) {
            return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    _context3.next = 2;
                    return this._connector(channelType).sendDeviceRemoveRequest(registrationId);
                  case 2:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));
          function removeRegistrations(_x, _x2) {
            return _removeRegistrations.apply(this, arguments);
          }
          return removeRegistrations;
        }()
        /**
         * Handle incoming push notification.
         * Client application should call this method when it receives push notifications and pass the received data.
         * @param {Object} message push message
         * @return {PushNotification} A reformatted payload with extracted message type.
         */
      }, {
        key: "handlePushNotification",
        value: function handlePushNotification(message) {
          return {
            messageType: message.twi_message_type,
            payload: message.payload
          };
        }
        /**
         * Routes messages to the external subscribers
         */
      }, {
        key: "_routeMessage",
        value: function _routeMessage(type, message) {
          logInstance.debug("Notification message arrived: ", type, message);
          this.emit("message", type, message);
        }
        /**
         * @param {String} type Channel type
         * @throws {Error} Error with description
         */
      }, {
        key: "_connector",
        value: function _connector(type) {
          var connector = this.connectors.get(type);
          if (!connector) {
            throw new Error("Unknown channel type: ".concat(type));
          }
          return connector;
        }
        /**
         * Returns platform string limited to max 128 chars
         */
      }], [{
        key: "_detectPlatform",
        value: function _detectPlatform() {
          var platform = "";
          if (typeof navigator !== "undefined") {
            platform = "unknown";
            if (typeof navigator.product !== "undefined") {
              platform = navigator.product;
            }
            if (typeof navigator.userAgent !== "undefined") {
              platform = navigator.userAgent;
            }
          } else {
            platform = "web";
          }
          return platform.substring(0, 128);
        }
      }]);
      return Client;
    }(EventEmitter);
    __decorate([declarativeTypeValidator.validateTypes(channelTypeRule, declarativeTypeValidator.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String, String]), __metadata("design:returntype", void 0)], exports.Notifications.prototype, "setPushRegistrationId", null);
    __decorate([declarativeTypeValidator.validateTypes(channelTypeRule, declarativeTypeValidator.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String, String]), __metadata("design:returntype", void 0)], exports.Notifications.prototype, "subscribe", null);
    __decorate([declarativeTypeValidator.validateTypes(channelTypeRule, declarativeTypeValidator.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String, String]), __metadata("design:returntype", void 0)], exports.Notifications.prototype, "unsubscribe", null);
    __decorate([declarativeTypeValidator.validateTypes(declarativeTypeValidator.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", void 0)], exports.Notifications.prototype, "updateToken", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(channelTypeRule, declarativeTypeValidator.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String, String]), __metadata("design:returntype", Promise)], exports.Notifications.prototype, "removeRegistrations", null);
    exports.Notifications = Client_1 = __decorate([declarativeTypeValidator.validateConstructorTypes(declarativeTypeValidator.nonEmptyString, [declarativeTypeValidator.pureObject, "undefined", declarativeTypeValidator.literal(null)]), __metadata("design:paramtypes", [String, Object])], exports.Notifications);
  }
});

// node_modules/@twilio/conversations/node_modules/twilio-sync/node_modules/@twilio/declarative-type-validator/builds/browser.js
var require_browser7 = __commonJS({
  "node_modules/@twilio/conversations/node_modules/twilio-sync/node_modules/@twilio/declarative-type-validator/builds/browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    require_es_array_slice();
    require_es_object_to_string();
    require_es_array_from();
    require_es_string_iterator();
    require_es_symbol();
    require_es_symbol_description();
    require_es_symbol_iterator();
    require_es_array_iterator();
    require_web_dom_collections_iterator();
    var _typeof = require_typeof();
    require_es_function_name();
    require_es_number_is_integer();
    require_es_number_constructor();
    var _slicedToArray = require_slicedToArray();
    require_es_object_entries();
    require_es_array_concat();
    require_es_reflect_construct();
    var _toConsumableArray = require_toConsumableArray();
    var _classCallCheck = require_classCallCheck();
    var _inherits = require_inherits();
    var _possibleConstructorReturn = require_possibleConstructorReturn();
    var _getPrototypeOf = require_getPrototypeOf();
    require_es_array_includes();
    require_es_promise();
    require_es_array_join();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var _typeof__default = _interopDefaultLegacy(_typeof);
    var _slicedToArray__default = _interopDefaultLegacy(_slicedToArray);
    var _toConsumableArray__default = _interopDefaultLegacy(_toConsumableArray);
    var _classCallCheck__default = _interopDefaultLegacy(_classCallCheck);
    var _inherits__default = _interopDefaultLegacy(_inherits);
    var _possibleConstructorReturn__default = _interopDefaultLegacy(_possibleConstructorReturn);
    var _getPrototypeOf__default = _interopDefaultLegacy(_getPrototypeOf);
    var custom = function custom2() {
      for (var _len = arguments.length, checks = new Array(_len), _key = 0; _key < _len; _key++) {
        checks[_key] = arguments[_key];
      }
      return {
        checks
      };
    };
    function _createForOfIteratorHelper$3(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      } };
    }
    function _unsupportedIterableToArray$3(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray$3(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen);
    }
    function _arrayLikeToArray$3(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var type = function type2() {
      for (var _len = arguments.length, checks = new Array(_len), _key = 0; _key < _len; _key++) {
        checks[_key] = arguments[_key];
      }
      return custom(function(value) {
        var isValid = false;
        var expectedTypes = [];
        var _iterator = _createForOfIteratorHelper$3(checks), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var _type = _step.value;
            if (typeof _type === "string") {
              isValid = isValid || _typeof__default["default"](value) === _type;
              expectedTypes.push("of type ".concat(_type));
              continue;
            }
            isValid = isValid || value instanceof _type;
            expectedTypes.push("an instance of ".concat(_type.name));
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return [isValid, expectedTypes];
      });
    };
    function _createForOfIteratorHelper$2(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      } };
    }
    function _unsupportedIterableToArray$2(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray$2(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen);
    }
    function _arrayLikeToArray$2(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var literal = function literal2() {
      for (var _len = arguments.length, checks = new Array(_len), _key = 0; _key < _len; _key++) {
        checks[_key] = arguments[_key];
      }
      return custom(function(value) {
        var isValid = false;
        var expectedTypes = [];
        var _iterator = _createForOfIteratorHelper$2(checks), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var type2 = _step.value;
            isValid = isValid || value === type2;
            expectedTypes.push(typeof type2 === "string" ? '"'.concat(type2, '"') : "".concat(type2));
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return [isValid, expectedTypes];
      });
    };
    var nonEmptyString = custom(function(value) {
      return [typeof value === "string" && value.length > 0, "a non-empty string"];
    });
    var nonNegativeInteger = custom(function(value) {
      return [typeof value === "number" && Number.isInteger(value) && value >= 0, "a non-negative integer"];
    });
    var pureObject = custom(function(value) {
      return [_typeof__default["default"](value) === "object" && value !== null && !Array.isArray(value), "a pure object (non-null and non-array)"];
    });
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _createForOfIteratorHelper$1(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      } };
    }
    function _unsupportedIterableToArray$1(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
    }
    function _arrayLikeToArray$1(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var runtimeTypeValidation = function runtimeTypeValidation2(rules, values) {
      if (values.length > rules.length) {
        throw new Error("Expected at most ".concat(rules.length, " argument(s), but got ").concat(values.length));
      }
      while (values.length < rules.length) {
        values.push(void 0);
      }
      var _iterator = _createForOfIteratorHelper$1(values.entries()), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var _step$value = _slicedToArray__default["default"](_step.value, 2), index = _step$value[0], value = _step$value[1];
          var _validateValue = validateValue(rules[index], value), _validateValue2 = _slicedToArray__default["default"](_validateValue, 4), isValid = _validateValue2[0], received = _validateValue2[1], expected = _validateValue2[2], delimeter = _validateValue2[3];
          if (isValid) {
            continue;
          }
          var argumentIndex = index + 1;
          throw new Error("Argument ".concat(argumentIndex, " is expected to be ").concat(expected).concat(delimeter, " but got ").concat(received));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    };
    var stringifyReceivedType = function stringifyReceivedType2(value) {
      var _value$constructor;
      var receivedType;
      var types = ["undefined", "boolean", "number", "bigint", "string"];
      if (types.includes(_typeof__default["default"](value))) {
        receivedType = typeof value === "string" ? '"'.concat(value, '"') : "".concat(value);
      }
      if (_typeof__default["default"](value) === "object" && (value === null || value === void 0 ? void 0 : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name) !== "Object") {
        var _value$constructor2;
        receivedType = value === null ? "null" : "instance of ".concat(value === null || value === void 0 ? void 0 : (_value$constructor2 = value.constructor) === null || _value$constructor2 === void 0 ? void 0 : _value$constructor2.name);
      }
      if (!receivedType) {
        receivedType = _typeof__default["default"](value);
      }
      return receivedType;
    };
    var validateConstructorTypes = function validateConstructorTypes2() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var finalRuleSet = convertRuleArguments(args);
      return function(ctor) {
        return function(_ctor) {
          _inherits__default["default"](_class, _ctor);
          var _super = _createSuper(_class);
          function _class() {
            _classCallCheck__default["default"](this, _class);
            for (var _len2 = arguments.length, args2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args2[_key2] = arguments[_key2];
            }
            runtimeTypeValidation(finalRuleSet, args2);
            return _super.call.apply(_super, [this].concat(args2));
          }
          return _class;
        }(ctor);
      };
    };
    var validateTypes = function validateTypes2() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      var finalRuleSet = convertRuleArguments(args);
      return function(target, propertyKey, descriptor) {
        if (typeof descriptor.value !== "function") {
          throw new Error("The validateTypes decorator can only be applied to methods");
        }
        var originalMethod = descriptor.value;
        descriptor.value = function() {
          for (var _len4 = arguments.length, args2 = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args2[_key4] = arguments[_key4];
          }
          runtimeTypeValidation(finalRuleSet, args2);
          return originalMethod.apply(this, args2);
        };
      };
    };
    var validateTypesAsync = function validateTypesAsync2() {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }
      var finalRuleSet = convertRuleArguments(args);
      return function(target, propertyKey, descriptor) {
        if (typeof descriptor.value !== "function") {
          throw new Error("The validateTypesAsync decorator can only be applied to methods");
        }
        var originalMethod = descriptor.value;
        descriptor.value = function() {
          for (var _len6 = arguments.length, args2 = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
            args2[_key6] = arguments[_key6];
          }
          try {
            runtimeTypeValidation(finalRuleSet, args2);
          } catch (e) {
            return Promise.reject(e);
          }
          return originalMethod.apply(this, args2);
        };
      };
    };
    var convertRuleArguments = function convertRuleArguments2(args) {
      var finalRuleDefinitionSet = [];
      var _iterator2 = _createForOfIteratorHelper$1(args), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var arg = _step2.value;
          finalRuleDefinitionSet.push(convertRuleArgument(arg));
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return finalRuleDefinitionSet;
    };
    var convertRuleArgument = function convertRuleArgument2(arg) {
      var finalArgumentRuleDefinitions = [];
      var declaredRules = Array.isArray(arg) ? arg : [arg];
      var _iterator3 = _createForOfIteratorHelper$1(declaredRules), _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
          var rule = _step3.value;
          if (typeof rule === "string" || typeof rule === "function") {
            finalArgumentRuleDefinitions.push(type(rule));
            continue;
          }
          finalArgumentRuleDefinitions.push(rule);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      return finalArgumentRuleDefinitions;
    };
    var validateValue = function validateValue2(ruleDefinitions, value) {
      var expectedTypes = [];
      var customReceivedType;
      var isValid = false;
      var _iterator4 = _createForOfIteratorHelper$1(ruleDefinitions), _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
          var definition = _step4.value;
          var _iterator5 = _createForOfIteratorHelper$1(definition.checks), _step5;
          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
              var check = _step5.value;
              var _check = check(value), _check2 = _slicedToArray__default["default"](_check, 3), checkPassed = _check2[0], typeDescription = _check2[1], _receivedType = _check2[2];
              isValid = isValid || checkPassed;
              if (!customReceivedType && _receivedType) {
                customReceivedType = _receivedType;
              }
              if (typeDescription) {
                expectedTypes = typeof typeDescription === "string" ? [].concat(_toConsumableArray__default["default"](expectedTypes), [typeDescription]) : [].concat(_toConsumableArray__default["default"](expectedTypes), _toConsumableArray__default["default"](typeDescription));
              }
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
      if (isValid) {
        return [true];
      }
      var receivedType = customReceivedType || stringifyReceivedType(value);
      var lastIndex = expectedTypes.length - 1;
      var expectedTypesString = lastIndex > 0 ? "".concat(expectedTypes.slice(0, lastIndex).join(", "), " or ").concat(expectedTypes[lastIndex]) : expectedTypes.join(", ");
      return [false, receivedType, expectedTypesString, lastIndex > 1 ? ";" : ","];
    };
    var objectSchema = function objectSchema2(name, schema) {
      return custom(function(object) {
        if (_typeof__default["default"](object) !== "object" || object === null || Array.isArray(object)) {
          return [false, "valid ".concat(name, " (should be a pure object)")];
        }
        for (var _i = 0, _Object$entries = Object.entries(schema); _i < _Object$entries.length; _i++) {
          var _Object$entries$_i = _slicedToArray__default["default"](_Object$entries[_i], 2), key = _Object$entries$_i[0], rules = _Object$entries$_i[1];
          var _validateValue = validateValue(convertRuleArgument(rules), object[key]), _validateValue2 = _slicedToArray__default["default"](_validateValue, 3), isValid = _validateValue2[0], received = _validateValue2[1], expected = _validateValue2[2];
          if (!isValid) {
            return [false, "valid ".concat(name, ' (key "').concat(key, '" should be ').concat(expected, ")"), "malformed ".concat(name, ' (key "').concat(key, '" is ').concat(received, ")")];
          }
        }
        return [true];
      });
    };
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var array = function array2(name, rules) {
      return custom(function(value) {
        if (!Array.isArray(value)) {
          return [false, "an array of ".concat(name)];
        }
        var _iterator = _createForOfIteratorHelper(value.entries()), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var _step$value = _slicedToArray__default["default"](_step.value, 2), key = _step$value[0], valueOfKey = _step$value[1];
            var _validateValue = validateValue(convertRuleArgument(rules), valueOfKey), _validateValue2 = _slicedToArray__default["default"](_validateValue, 3), isValid = _validateValue2[0], received = _validateValue2[1], expected = _validateValue2[2];
            if (!isValid) {
              return [false, "a valid array of ".concat(name, " (index ").concat(key, " should be ").concat(expected, ")"), "malformed array of ".concat(name, " (index ").concat(key, " is ").concat(received, ")")];
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return [true];
      });
    };
    exports.array = array;
    exports.custom = custom;
    exports.literal = literal;
    exports.nonEmptyString = nonEmptyString;
    exports.nonNegativeInteger = nonNegativeInteger;
    exports.objectSchema = objectSchema;
    exports.pureObject = pureObject;
    exports.runtimeTypeValidation = runtimeTypeValidation;
    exports.stringifyReceivedType = stringifyReceivedType;
    exports.type = type;
    exports.validateConstructorTypes = validateConstructorTypes;
    exports.validateTypes = validateTypes;
    exports.validateTypesAsync = validateTypesAsync;
  }
});

// node_modules/@twilio/conversations/node_modules/twilio-sync/builds/browser.js
var require_browser8 = __commonJS({
  "node_modules/@twilio/conversations/node_modules/twilio-sync/builds/browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    require_es_object_keys();
    require_es_symbol();
    require_es_array_filter();
    require_es_object_get_own_property_descriptor();
    require_web_dom_collections_for_each();
    require_es_object_get_own_property_descriptors();
    require_es_reflect_construct();
    var _asyncToGenerator = require_asyncToGenerator();
    var _classCallCheck = require_classCallCheck();
    var _createClass = require_createClass();
    var _assertThisInitialized = require_assertThisInitialized();
    var _inherits = require_inherits();
    var _possibleConstructorReturn = require_possibleConstructorReturn();
    var _getPrototypeOf = require_getPrototypeOf();
    var _defineProperty = require_defineProperty();
    require_es_array_map();
    require_es_object_to_string();
    require_es_promise();
    var _regeneratorRuntime = require_regenerator2();
    var _typeof = require_typeof();
    var declarativeTypeValidator = require_browser7();
    var twilsock = require_browser5();
    require_es_array_join();
    var _wrapNativeSuper = require_wrapNativeSuper();
    require_es_function_name();
    require_es_array_concat();
    require_es_array_includes();
    require_es_array_from();
    require_es_string_iterator();
    var loglevelLog = require_loglevel();
    require_es_array_slice();
    require_es_symbol_description();
    require_es_symbol_iterator();
    var _slicedToArray = require_slicedToArray();
    require_es_array_iterator();
    require_es_map();
    require_web_dom_collections_iterator();
    require_es_object_assign();
    require_es_regexp_exec();
    require_es_string_match();
    var operationRetrier = require_browser3();
    require_es_string_replace();
    var uuid = require_uuid2();
    var _get = require_get();
    require_es_number_constructor();
    var platform = require_platform();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    function _interopNamespace(e) {
      if (e && e.__esModule) return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var _asyncToGenerator__default = _interopDefaultLegacy(_asyncToGenerator);
    var _classCallCheck__default = _interopDefaultLegacy(_classCallCheck);
    var _createClass__default = _interopDefaultLegacy(_createClass);
    var _assertThisInitialized__default = _interopDefaultLegacy(_assertThisInitialized);
    var _inherits__default = _interopDefaultLegacy(_inherits);
    var _possibleConstructorReturn__default = _interopDefaultLegacy(_possibleConstructorReturn);
    var _getPrototypeOf__default = _interopDefaultLegacy(_getPrototypeOf);
    var _defineProperty__default = _interopDefaultLegacy(_defineProperty);
    var _regeneratorRuntime__default = _interopDefaultLegacy(_regeneratorRuntime);
    var _typeof__default = _interopDefaultLegacy(_typeof);
    var _wrapNativeSuper__default = _interopDefaultLegacy(_wrapNativeSuper);
    var loglevelLog__namespace = _interopNamespace(loglevelLog);
    var _slicedToArray__default = _interopDefaultLegacy(_slicedToArray);
    var uuid__namespace = _interopNamespace(uuid);
    var _get__default = _interopDefaultLegacy(_get);
    var platform__namespace = _interopNamespace(platform);
    function __decorate(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ((typeof Reflect === "undefined" ? "undefined" : _typeof__default["default"](Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      }
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __metadata(metadataKey, metadataValue) {
      if ((typeof Reflect === "undefined" ? "undefined" : _typeof__default["default"](Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }
    var domain;
    function EventHandlers() {
    }
    EventHandlers.prototype = /* @__PURE__ */ Object.create(null);
    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.usingDomains = false;
    EventEmitter.prototype.domain = void 0;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._maxListeners = void 0;
    EventEmitter.defaultMaxListeners = 10;
    EventEmitter.init = function() {
      this.domain = null;
      if (EventEmitter.usingDomains) {
        if (domain.active) ;
      }
      if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
        this._events = new EventHandlers();
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || isNaN(n))
        throw new TypeError('"n" argument must be a positive number');
      this._maxListeners = n;
      return this;
    };
    function $getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return $getMaxListeners(this);
    };
    function emitNone(handler, isFn, self2) {
      if (isFn)
        handler.call(self2);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self2);
      }
    }
    function emitOne(handler, isFn, self2, arg1) {
      if (isFn)
        handler.call(self2, arg1);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self2, arg1);
      }
    }
    function emitTwo(handler, isFn, self2, arg1, arg2) {
      if (isFn)
        handler.call(self2, arg1, arg2);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self2, arg1, arg2);
      }
    }
    function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
      if (isFn)
        handler.call(self2, arg1, arg2, arg3);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self2, arg1, arg2, arg3);
      }
    }
    function emitMany(handler, isFn, self2, args) {
      if (isFn)
        handler.apply(self2, args);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].apply(self2, args);
      }
    }
    EventEmitter.prototype.emit = function emit(type) {
      var er, handler, len, args, i, events, domain2;
      var doError = type === "error";
      events = this._events;
      if (events)
        doError = doError && events.error == null;
      else if (!doError)
        return false;
      domain2 = this.domain;
      if (doError) {
        er = arguments[1];
        if (domain2) {
          if (!er)
            er = new Error('Uncaught, unspecified "error" event');
          er.domainEmitter = this;
          er.domain = domain2;
          er.domainThrown = false;
          domain2.emit("error", er);
        } else if (er instanceof Error) {
          throw er;
        } else {
          var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
          err.context = er;
          throw err;
        }
        return false;
      }
      handler = events[type];
      if (!handler)
        return false;
      var isFn = typeof handler === "function";
      len = arguments.length;
      switch (len) {
        case 1:
          emitNone(handler, isFn, this);
          break;
        case 2:
          emitOne(handler, isFn, this, arguments[1]);
          break;
        case 3:
          emitTwo(handler, isFn, this, arguments[1], arguments[2]);
          break;
        case 4:
          emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
          break;
        default:
          args = new Array(len - 1);
          for (i = 1; i < len; i++)
            args[i - 1] = arguments[i];
          emitMany(handler, isFn, this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      events = target._events;
      if (!events) {
        events = target._events = new EventHandlers();
        target._eventsCount = 0;
      } else {
        if (events.newListener) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (!existing) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else {
          if (prepend) {
            existing.unshift(listener);
          } else {
            existing.push(listener);
          }
        }
        if (!existing.warned) {
          m = $getMaxListeners(target);
          if (m && m > 0 && existing.length > m) {
            existing.warned = true;
            var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type + " listeners added. Use emitter.setMaxListeners() to increase limit");
            w.name = "MaxListenersExceededWarning";
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            emitWarning(w);
          }
        }
      }
      return target;
    }
    function emitWarning(e) {
      typeof console.warn === "function" ? console.warn(e) : console.log(e);
    }
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function _onceWrap(target, type, listener) {
      var fired = false;
      function g() {
        target.removeListener(type, g);
        if (!fired) {
          fired = true;
          listener.apply(target, arguments);
        }
      }
      g.listener = listener;
      return g;
    }
    EventEmitter.prototype.once = function once(type, listener) {
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      events = this._events;
      if (!events)
        return this;
      list = events[type];
      if (!list)
        return this;
      if (list === listener || list.listener && list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = new EventHandlers();
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length; i-- > 0; ) {
          if (list[i] === listener || list[i].listener && list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (list.length === 1) {
          list[0] = void 0;
          if (--this._eventsCount === 0) {
            this._events = new EventHandlers();
            return this;
          } else {
            delete events[type];
          }
        } else {
          spliceOne(list, position);
        }
        if (events.removeListener)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.off = function(type, listener) {
      return this.removeListener(type, listener);
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events;
      events = this._events;
      if (!events)
        return this;
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        for (var i = 0, key; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener") continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = new EventHandlers();
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners) {
        do {
          this.removeListener(type, listeners[listeners.length - 1]);
        } while (listeners[0]);
      }
      return this;
    };
    EventEmitter.prototype.listeners = function listeners(type) {
      var evlistener;
      var ret;
      var events = this._events;
      if (!events)
        ret = [];
      else {
        evlistener = events[type];
        if (!evlistener)
          ret = [];
        else if (typeof evlistener === "function")
          ret = [evlistener.listener || evlistener];
        else
          ret = unwrapListeners(evlistener);
      }
      return ret;
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
    };
    function spliceOne(list, index) {
      for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
        list[i] = list[k];
      list.pop();
    }
    function arrayClone(arr, i) {
      var copy = new Array(i);
      while (i--)
        copy[i] = arr[i];
      return copy;
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    var UriBuilder = function() {
      function UriBuilder2(base) {
        _classCallCheck__default["default"](this, UriBuilder2);
        this.base = base;
        this.args = new Array();
        this.paths = new Array();
      }
      _createClass__default["default"](UriBuilder2, [{
        key: "pathSegment",
        value: function pathSegment(name) {
          this.paths.push(encodeURIComponent(name));
          return this;
        }
      }, {
        key: "queryParam",
        value: function queryParam(name, value) {
          if (typeof value !== "undefined") {
            this.args.push(encodeURIComponent(name) + "=" + encodeURIComponent(value));
          }
          return this;
        }
      }, {
        key: "build",
        value: function build() {
          var result = this.base;
          if (this.paths.length) {
            result += "/" + this.paths.join("/");
          }
          if (this.args.length) {
            result += "?" + this.args.join("&");
          }
          return result;
        }
      }]);
      return UriBuilder2;
    }();
    function _createSuper$7(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$7();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$7() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var SyncError = function(_Error) {
      _inherits__default["default"](SyncError2, _Error);
      var _super = _createSuper$7(SyncError2);
      function SyncError2(message) {
        var _this;
        var status = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        var code = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        _classCallCheck__default["default"](this, SyncError2);
        _this = _super.call(this);
        _this.name = _this.constructor.name;
        _this.message = "".concat(message, " (status: ").concat(status, ", code: ").concat(code, ")");
        _this.status = status;
        _this.code = code;
        return _this;
      }
      return SyncError2;
    }(_wrapNativeSuper__default["default"](Error));
    var SyncNetworkError = function(_SyncError) {
      _inherits__default["default"](SyncNetworkError2, _SyncError);
      var _super2 = _createSuper$7(SyncNetworkError2);
      function SyncNetworkError2(message) {
        var _this2;
        var status = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        var code = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        var body = arguments.length > 3 ? arguments[3] : void 0;
        _classCallCheck__default["default"](this, SyncNetworkError2);
        _this2 = _super2.call(this, message, status, code);
        _this2.body = body;
        return _this2;
      }
      return SyncNetworkError2;
    }(SyncError);
    function deepClone(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
    function validatePageSize(pageSize) {
      var validPageSize = pageSize === void 0 || isPositiveInteger(pageSize);
      if (!validPageSize) {
        throw new SyncError("Invalid pageSize parameter. Expected a positive integer, was '".concat(pageSize, "'."), 400, 20007);
      }
    }
    function isInteger(number) {
      return !isNaN(parseInt(number)) && isFinite(number);
    }
    function isPositiveInteger(number) {
      return isInteger(number) && number > 0;
    }
    var log = loglevelLog__namespace.getLogger("twilio-sync");
    function prepareLine(prefix, args) {
      return ["".concat((/* @__PURE__ */ new Date()).toISOString(), " Sync ").concat(prefix, ":")].concat(Array.from(args));
    }
    var log$1 = {
      setLevel: function setLevel(level) {
        log.setLevel(level);
      },
      trace: function trace() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        log.trace.apply(null, prepareLine("T", args));
      },
      debug: function debug() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        log.debug.apply(null, prepareLine("D", args));
      },
      info: function info() {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }
        log.info.apply(null, prepareLine("I", args));
      },
      warn: function warn() {
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }
        log.warn.apply(null, prepareLine("W", args));
      },
      error: function error() {
        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          args[_key5] = arguments[_key5];
        }
        log.error.apply(null, prepareLine("E", args));
      }
    };
    var SUBSCRIPTIONS_PATH = "/v4/Subscriptions";
    var MAPS_PATH = "/v3/Maps";
    var LISTS_PATH = "/v3/Lists";
    var DOCUMENTS_PATH = "/v3/Documents";
    var STREAMS_PATH = "/v3/Streams";
    var INSIGHTS_PATH = "/v3/Insights";
    function getWithDefault(container, key, defaultValue) {
      if (container && typeof container[key] !== "undefined") {
        return container[key];
      }
      return defaultValue;
    }
    var Configuration = function() {
      function Configuration2() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck__default["default"](this, Configuration2);
        var region = options.region || "us1";
        var defaultCdsUrl = "https://cds.".concat(region, ".twilio.com");
        var baseUri = options.cdsUri || defaultCdsUrl;
        this.settings = {
          subscriptionsUri: baseUri + SUBSCRIPTIONS_PATH,
          documentsUri: baseUri + DOCUMENTS_PATH,
          listsUri: baseUri + LISTS_PATH,
          mapsUri: baseUri + MAPS_PATH,
          streamsUri: baseUri + STREAMS_PATH,
          insightsUri: baseUri + INSIGHTS_PATH,
          sessionStorageEnabled: getWithDefault(options.Sync, "enableSessionStorage", true),
          productId: options.productId
        };
      }
      _createClass__default["default"](Configuration2, [{
        key: "subscriptionsUri",
        get: function get() {
          return this.settings.subscriptionsUri;
        }
      }, {
        key: "documentsUri",
        get: function get() {
          return this.settings.documentsUri;
        }
      }, {
        key: "listsUri",
        get: function get() {
          return this.settings.listsUri;
        }
      }, {
        key: "mapsUri",
        get: function get() {
          return this.settings.mapsUri;
        }
      }, {
        key: "streamsUri",
        get: function get() {
          return this.settings.streamsUri;
        }
      }, {
        key: "insightsUri",
        get: function get() {
          return this.settings.insightsUri;
        }
      }, {
        key: "backoffConfig",
        get: function get() {
          return this.settings.backoffConfig || {};
        }
      }, {
        key: "sessionStorageEnabled",
        get: function get() {
          return this.settings.sessionStorageEnabled;
        }
      }, {
        key: "productId",
        get: function get() {
          return this.settings.productId;
        }
      }]);
      return Configuration2;
    }();
    function _createForOfIteratorHelper$3(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      } };
    }
    function _unsupportedIterableToArray$3(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray$3(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen);
    }
    function _arrayLikeToArray$3(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var SubscribedEntity = function() {
      function SubscribedEntity2(entity) {
        _classCallCheck__default["default"](this, SubscribedEntity2);
        this.localObject = entity;
        this.pendingCorrelationId = null;
        this.pendingAction = null;
        this.established = false;
        this.retryCount = 0;
      }
      _createClass__default["default"](SubscribedEntity2, [{
        key: "sid",
        get: function get() {
          return this.localObject.sid;
        }
      }, {
        key: "type",
        get: function get() {
          return this.localObject.type;
        }
      }, {
        key: "lastEventId",
        get: function get() {
          return this.localObject.lastEventId;
        }
        // below properties are specific to Insights only
      }, {
        key: "indexName",
        get: function get() {
          return this.localObject.indexName;
        }
      }, {
        key: "queryString",
        get: function get() {
          return this.localObject.queryString;
        }
      }, {
        key: "isEstablished",
        get: function get() {
          return this.established;
        }
      }, {
        key: "update",
        value: function update(event, isStrictlyOrdered) {
          this.localObject._update(event, isStrictlyOrdered);
        }
      }, {
        key: "updatePending",
        value: function updatePending(action, correlationId) {
          this.pendingAction = action;
          this.pendingCorrelationId = correlationId;
        }
      }, {
        key: "reset",
        value: function reset() {
          this.updatePending(null, null);
          this.retryCount = 0;
          this.established = false;
          this.setSubscriptionState("none");
        }
      }, {
        key: "markAsFailed",
        value: function markAsFailed(message) {
          this.rejectedWithError = message.error;
          this.updatePending(null, null);
          this.localObject.reportFailure(new SyncError("Failed to subscribe on service events: ".concat(message.error.message), message.error.status, message.error.code));
        }
      }, {
        key: "complete",
        value: function complete(eventId) {
          this.updatePending(null, null);
          this.established = true;
          this.localObject._advanceLastEventId(eventId);
        }
      }, {
        key: "setSubscriptionState",
        value: function setSubscriptionState(newState) {
          this.localObject._setSubscriptionState(newState);
        }
      }]);
      return SubscribedEntity2;
    }();
    var Subscriptions = function() {
      function Subscriptions2(services) {
        var _this = this;
        _classCallCheck__default["default"](this, Subscriptions2);
        _defineProperty__default["default"](this, "isConnected", false);
        _defineProperty__default["default"](this, "maxBatchSize", 100);
        _defineProperty__default["default"](this, "subscriptionTtlTimer", null);
        _defineProperty__default["default"](this, "pendingPokeReason", null);
        this.services = services;
        this.subscriptions = /* @__PURE__ */ new Map();
        this.persisted = /* @__PURE__ */ new Map();
        this.latestPokeResponseArrivalTimestampByCorrelationId = /* @__PURE__ */ new Map();
        var defaultBackoffConfig = {
          randomisationFactor: 0.2,
          initialDelay: 100,
          maxDelay: 2 * 60 * 1e3
        };
        this.backoff = operationRetrier.Backoff.exponential(Object.assign(defaultBackoffConfig, this.services.config.backoffConfig));
        this.backoff.on("ready", function() {
          var _this$getSubscription = _this.getSubscriptionUpdateBatch(), action = _this$getSubscription.action, subscriptionRequests = _this$getSubscription.subscriptions;
          if (action) {
            _this.applyNewSubscriptionUpdateBatch(action, subscriptionRequests);
          } else {
            _this.backoff.reset();
            log$1.debug("All subscriptions resolved.");
          }
        });
      }
      _createClass__default["default"](Subscriptions2, [{
        key: "getSubscriptionUpdateBatch",
        value: function getSubscriptionUpdateBatch() {
          function subtract(these, those, action, limit) {
            var result = [];
            var _iterator = _createForOfIteratorHelper$3(these), _step;
            try {
              for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                var _step$value = _slicedToArray__default["default"](_step.value, 2), thisKey = _step$value[0], thisValue = _step$value[1];
                var otherValue = those.get(thisKey);
                if (!otherValue && action !== thisValue.pendingAction && !thisValue.rejectedWithError) {
                  result.push(thisValue);
                  if (limit && result.length >= limit) {
                    break;
                  }
                }
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
            return result;
          }
          var listToAdd = subtract(this.subscriptions, this.persisted, "establish", this.maxBatchSize);
          if (listToAdd.length > 0) {
            return {
              action: "establish",
              subscriptions: listToAdd
            };
          }
          var listToRemove = subtract(this.persisted, this.subscriptions, "cancel", this.maxBatchSize);
          if (listToRemove.length > 0) {
            return {
              action: "cancel",
              subscriptions: listToRemove
            };
          }
          return {
            action: null,
            subscriptions: null
          };
        }
      }, {
        key: "persist",
        value: function persist() {
          this.backoff.backoff();
        }
      }, {
        key: "applyNewSubscriptionUpdateBatch",
        value: function() {
          var _applyNewSubscriptionUpdateBatch = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee(action, requests) {
            var _this2 = this;
            var correlationId, _iterator2, _step2, subscribed, reason, response, newMaxBatchSize, subscriptionTtlInS, isNumeric, isValidTtl, estimatedDeliveryInMs, _isNumeric, isValidTimeout, _iterator3, _step3, attemptedSubscription;
            return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (this.isConnected) {
                      _context.next = 4;
                      break;
                    }
                    log$1.debug("Twilsock connection (required for subscription) not ready; waitingâ¦");
                    this.backoff.reset();
                    return _context.abrupt("return");
                  case 4:
                    requests = this.processLocalActions(action, requests);
                    correlationId = (/* @__PURE__ */ new Date()).getTime();
                    _iterator2 = _createForOfIteratorHelper$3(requests);
                    try {
                      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                        subscribed = _step2.value;
                        this.recordActionAttemptOn(subscribed, action, correlationId);
                      }
                    } catch (err) {
                      _iterator2.e(err);
                    } finally {
                      _iterator2.f();
                    }
                    reason = this.pendingPokeReason;
                    this.pendingPokeReason = null;
                    _context.prev = 10;
                    _context.next = 13;
                    return this.request(action, correlationId, reason, requests);
                  case 13:
                    response = _context.sent;
                    newMaxBatchSize = response.body.max_batch_size;
                    if (!isNaN(parseInt(newMaxBatchSize)) && isFinite(newMaxBatchSize) && newMaxBatchSize > 0) {
                      this.maxBatchSize = newMaxBatchSize;
                    }
                    if (!this.subscriptionTtlTimer) {
                      subscriptionTtlInS = response.body.ttl_in_s;
                      isNumeric = !isNaN(parseFloat(subscriptionTtlInS)) && isFinite(subscriptionTtlInS);
                      isValidTtl = isNumeric && subscriptionTtlInS > 0;
                      if (isValidTtl) {
                        this.subscriptionTtlTimer = setTimeout(function() {
                          return _this2.onSubscriptionTtlElapsed();
                        }, subscriptionTtlInS * 1e3);
                      }
                    }
                    if (action === "establish") {
                      estimatedDeliveryInMs = response.body.estimated_delivery_in_ms;
                      _isNumeric = !isNaN(parseFloat(estimatedDeliveryInMs)) && isFinite(estimatedDeliveryInMs);
                      isValidTimeout = _isNumeric && estimatedDeliveryInMs > 0;
                      if (isValidTimeout) {
                        setTimeout(function() {
                          return _this2.verifyPokeDelivery(correlationId, estimatedDeliveryInMs, requests);
                        }, estimatedDeliveryInMs);
                      } else {
                        log$1.error("Invalid timeout: ".concat(estimatedDeliveryInMs));
                      }
                      requests.filter(function(r) {
                        return r.pendingCorrelationId === correlationId;
                      }).forEach(function(r) {
                        return r.setSubscriptionState("response_in_flight");
                      });
                    }
                    this.backoff.reset();
                    _context.next = 26;
                    break;
                  case 21:
                    _context.prev = 21;
                    _context.t0 = _context["catch"](10);
                    _iterator3 = _createForOfIteratorHelper$3(requests);
                    try {
                      for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
                        attemptedSubscription = _step3.value;
                        this.recordActionFailureOn(attemptedSubscription, action);
                      }
                    } catch (err) {
                      _iterator3.e(err);
                    } finally {
                      _iterator3.f();
                    }
                    if (_context.t0 instanceof twilsock.TransportUnavailableError) {
                      log$1.debug("Twilsock connection (required for subscription) not ready (c:".concat(correlationId, "); waitingâ¦"));
                      this.backoff.reset();
                    } else {
                      log$1.debug("Failed an attempt to ".concat(action, " subscriptions (c:").concat(correlationId, "); retrying"), _context.t0);
                      this.persist();
                    }
                  case 26:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[10, 21]]);
          }));
          function applyNewSubscriptionUpdateBatch(_x, _x2) {
            return _applyNewSubscriptionUpdateBatch.apply(this, arguments);
          }
          return applyNewSubscriptionUpdateBatch;
        }()
      }, {
        key: "verifyPokeDelivery",
        value: function verifyPokeDelivery(correlationId, estimatedDeliveryInMs, requests) {
          var _this3 = this;
          var lastReceived = this.latestPokeResponseArrivalTimestampByCorrelationId.get(correlationId);
          var silencePeriod = lastReceived ? (/* @__PURE__ */ new Date()).getTime() - lastReceived : estimatedDeliveryInMs;
          if (silencePeriod >= estimatedDeliveryInMs) {
            requests.filter(function(r) {
              return r.pendingCorrelationId === correlationId;
            }).forEach(function(r) {
              r.updatePending(null, null);
              r.retryCount++;
              _this3.persisted.delete(r.sid);
            });
            this.persist();
            this.latestPokeResponseArrivalTimestampByCorrelationId.delete(correlationId);
          } else {
            var timeoutExtension = estimatedDeliveryInMs - silencePeriod;
            setTimeout(function() {
              return _this3.verifyPokeDelivery(correlationId, estimatedDeliveryInMs, requests);
            }, timeoutExtension);
          }
        }
      }, {
        key: "processLocalActions",
        value: function processLocalActions(action, requests) {
          if (action === "cancel") {
            return requests.filter(function(request) {
              return !request.rejectedWithError;
            });
          }
          return requests;
        }
      }, {
        key: "recordActionAttemptOn",
        value: function recordActionAttemptOn(attemptedSubscription, action, correlationId) {
          attemptedSubscription.setSubscriptionState("request_in_flight");
          if (action === "establish") {
            this.persisted.set(attemptedSubscription.sid, attemptedSubscription);
            attemptedSubscription.updatePending(action, correlationId);
          } else {
            var persistedSubscription = this.persisted.get(attemptedSubscription.sid);
            if (persistedSubscription) {
              persistedSubscription.updatePending(action, correlationId);
            }
          }
        }
      }, {
        key: "recordActionFailureOn",
        value: function recordActionFailureOn(attemptedSubscription, action) {
          attemptedSubscription.setSubscriptionState("none");
          attemptedSubscription.updatePending(null, null);
          if (action === "establish") {
            this.persisted.delete(attemptedSubscription.sid);
          }
        }
      }, {
        key: "request",
        value: function request(action, correlationId, reason, objects) {
          var requests = objects.map(function(object) {
            return {
              object_sid: object.sid,
              object_type: object.type,
              last_event_id: action === "establish" ? object.lastEventId : void 0,
              index_name: action === "establish" ? object.indexName : void 0,
              query_string: action === "establish" ? object.queryString : void 0
            };
          });
          var retriedRequests = objects.filter(function(a) {
            return a.retryCount > 0;
          }).length;
          log$1.debug("Attempting '".concat(action, "' request (c:").concat(correlationId, "):"), requests);
          var requestBody = {
            event_protocol_version: 4,
            action,
            correlation_id: correlationId,
            retried_requests: retriedRequests,
            ttl_in_s: -1,
            requests
          };
          if (reason === "ttl") {
            requestBody.reason = reason;
          }
          return this.services.network.post(this.services.config.subscriptionsUri, requestBody);
        }
        /**
         * Establishes intent to be subscribed to this entity. That subscription will be effected
         * asynchronously.
         * If subscription to the given sid already exists, it will be overwritten.
         *
         * @param {String} sid should be a well-formed SID, uniquely identifying a single instance of a Sync entity.
         * @param {Object} entity should represent the (singular) local representation of this entity.
         *      Incoming events and modifications to the entity will be directed at the _update() function
         *      of this provided reference.
         *
         * @return undefined
         */
      }, {
        key: "add",
        value: function add(sid, entity) {
          log$1.debug("Establishing intent to subscribe to ".concat(sid));
          var existingSubscription = this.subscriptions.get(sid);
          if (existingSubscription && entity && existingSubscription.lastEventId === entity.lastEventId) {
            return;
          }
          this.persisted.delete(sid);
          this.subscriptions.set(sid, new SubscribedEntity(entity));
          this.persist();
        }
        /**
         * Establishes the caller's intent to no longer be subscribed to this entity. Following this
         * call, no further events shall be routed to the local representation of the entity, even
         * though a server-side subscription may take more time to actually terminate.
         *
         * @param {string} sid should be any well-formed SID, uniquely identifying a Sync entity.
         *      This call only has meaningful effect if that entity is subscribed at the
         *      time of call. Otherwise does nothing.
         *
         * @return undefined
         */
      }, {
        key: "remove",
        value: function remove(sid) {
          log$1.debug("Establishing intent to unsubscribe from ".concat(sid));
          var removed = this.subscriptions.delete(sid);
          if (removed) {
            this.persist();
          }
        }
        /**
         * The point of ingestion for remote incoming messages (e.g. new data was written to a map
         * to which we are subscribed).
         *
         * @param {object} message is the full, unaltered body of the incoming notification.
         *
         * @return undefined
         */
      }, {
        key: "acceptMessage",
        value: function acceptMessage(message, isStrictlyOrdered) {
          log$1.trace("Subscriptions received", message);
          var eventType = message.event_type;
          var events = typeof message.events !== "undefined" ? message.events : [message.event];
          var correlationId = message.correlation_id;
          if (correlationId) {
            this.latestPokeResponseArrivalTimestampByCorrelationId.set(correlationId, (/* @__PURE__ */ new Date()).getTime());
          }
          var _iterator4 = _createForOfIteratorHelper$3(events), _step4;
          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
              var event = _step4.value;
              var matchedEventType = void 0;
              switch (message.event_type) {
                case "subscription_established":
                  this.applySubscriptionEstablishedMessage(event, correlationId);
                  break;
                case "subscription_canceled":
                  this.applySubscriptionCancelledMessage(event, correlationId);
                  break;
                case "subscription_failed":
                  this.applySubscriptionFailedMessage(event, correlationId);
                  break;
                case (matchedEventType = eventType.match(/^(?:map|list|document|stream|live_query)_/) || {}).input: {
                  var typedSid = void 0;
                  switch (matchedEventType[0]) {
                    case "map_":
                      typedSid = event.map_sid;
                      break;
                    case "list_":
                      typedSid = event.list_sid;
                      break;
                    case "document_":
                      typedSid = event.document_sid;
                      break;
                    case "stream_":
                      typedSid = event.stream_sid;
                      break;
                    case "live_query_":
                      typedSid = event.query_id;
                      isStrictlyOrdered = false;
                      if (message.strictly_ordered === true) {
                        isStrictlyOrdered = true;
                      }
                      break;
                    default:
                      typedSid = void 0;
                  }
                  this.applyEventToSubscribedEntity(typedSid, event, eventType, isStrictlyOrdered);
                  break;
                }
                default:
                  log$1.debug("Dropping unknown message type ".concat(eventType));
                  break;
              }
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }
        }
      }, {
        key: "applySubscriptionEstablishedMessage",
        value: function applySubscriptionEstablishedMessage(message, correlationId) {
          var sid = message.object_sid;
          var subscriptionIntent = this.persisted.get(message.object_sid);
          if (subscriptionIntent && subscriptionIntent.pendingCorrelationId === correlationId) {
            if (message.replay_status === "interrupted") {
              log$1.debug("Event Replay for subscription to ".concat(sid, " (c:").concat(correlationId, ") interrupted; continuing eagerly."));
              subscriptionIntent.updatePending(null, null);
              this.persisted.delete(subscriptionIntent.sid);
              this.backoff.reset();
            } else if (message.replay_status === "completed") {
              log$1.debug("Event Replay for subscription to ".concat(sid, " (c:").concat(correlationId, ") completed. Subscription is ready."));
              subscriptionIntent.complete(message.last_event_id);
              this.persisted.set(message.object_sid, subscriptionIntent);
              subscriptionIntent.setSubscriptionState("established");
              this.backoff.reset();
            }
          } else {
            log$1.debug("Late message for ".concat(message.object_sid, " (c:").concat(correlationId, ") dropped."));
          }
          this.persist();
        }
      }, {
        key: "applySubscriptionCancelledMessage",
        value: function applySubscriptionCancelledMessage(message, correlationId) {
          var persistedSubscription = this.persisted.get(message.object_sid);
          if (persistedSubscription && persistedSubscription.pendingCorrelationId === correlationId) {
            persistedSubscription.updatePending(null, null);
            persistedSubscription.setSubscriptionState("none");
            this.persisted.delete(message.object_sid);
          } else {
            log$1.debug("Late message for ".concat(message.object_sid, " (c:").concat(correlationId, ") dropped."));
          }
          this.persist();
        }
      }, {
        key: "applySubscriptionFailedMessage",
        value: function applySubscriptionFailedMessage(message, correlationId) {
          var sid = message.object_sid;
          var subscriptionIntent = this.subscriptions.get(sid);
          var subscription = this.persisted.get(sid);
          if (subscriptionIntent && subscription) {
            if (subscription.pendingCorrelationId === correlationId) {
              log$1.error("Failed to subscribe on ".concat(subscription.sid), message.error);
              subscription.markAsFailed(message);
              subscription.setSubscriptionState("none");
            }
          } else if (!subscriptionIntent && subscription) {
            this.persisted.delete(sid);
            subscription.setSubscriptionState("none");
          }
          this.persist();
        }
      }, {
        key: "applyEventToSubscribedEntity",
        value: function applyEventToSubscribedEntity(sid, event, eventType, isStrictlyOrdered) {
          var _this4 = this;
          if (!sid) {
            return;
          }
          isStrictlyOrdered = isStrictlyOrdered || function() {
            var subscription = _this4.persisted.get(sid);
            return subscription && subscription.isEstablished;
          }();
          var subscriptionIntent = this.subscriptions.get(sid);
          if (subscriptionIntent) {
            event.type = eventType;
            subscriptionIntent.update(event, isStrictlyOrdered);
          } else {
            log$1.debug("Message dropped for SID '".concat(sid, "', for which there is no subscription."));
          }
        }
      }, {
        key: "onConnectionStateChanged",
        value: function onConnectionStateChanged(isConnected) {
          this.isConnected = isConnected;
          if (isConnected) {
            this.poke("reconnect");
          }
        }
      }, {
        key: "onSubscriptionTtlElapsed",
        value: function onSubscriptionTtlElapsed() {
          if (this.isConnected) {
            this.poke("ttl");
          }
        }
        /**
         * Prompts a playback of any missed changes made to any subscribed object. This method
         * should be invoked whenever the connectivity layer has experienced cross-cutting
         * delivery failures that would affect the entire local sync set. Any tangible result
         * of this operation will result in calls to the _update() function of subscribed
         * Sync entities.
         */
      }, {
        key: "poke",
        value: function poke(reason) {
          log$1.debug("Triggering event replay for all subscriptions, reason=".concat(reason));
          this.pendingPokeReason = reason;
          if (this.subscriptionTtlTimer) {
            clearTimeout(this.subscriptionTtlTimer);
            this.subscriptionTtlTimer = null;
          }
          var failedSubscriptions = [];
          var _iterator5 = _createForOfIteratorHelper$3(this.persisted.values()), _step5;
          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
              var _it = _step5.value;
              _it.reset();
              if (_it.rejectedWithError) {
                failedSubscriptions.push(_it);
              }
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }
          this.persisted.clear();
          for (var _i = 0, _failedSubscriptions = failedSubscriptions; _i < _failedSubscriptions.length; _i++) {
            var it = _failedSubscriptions[_i];
            this.persisted.set(it.sid, it);
          }
          this.persist();
        }
        /**
         * Stops all communication, clears any subscription intent, and returns.
         */
      }, {
        key: "shutdown",
        value: function shutdown() {
          this.backoff.reset();
          this.subscriptions.clear();
        }
      }]);
      return Subscriptions2;
    }();
    var MINIMUM_RETRY_DELAY = 4e3;
    var MAXIMUM_RETRY_DELAY = 6e4;
    var MAXIMUM_ATTEMPTS_TIME = 9e4;
    var RETRY_DELAY_RANDOMNESS = 0.2;
    function messageFromErrorBody(transportError) {
      if (transportError.body) {
        if (transportError.body.message) {
          return transportError.body.message;
        }
      }
      switch (transportError.status) {
        case 429:
          return "Throttled by server";
        case 404:
          return "Not found from server";
        default:
          return "Error from server";
      }
    }
    function codeFromErrorBody(trasportError) {
      if (trasportError.body) {
        return trasportError.body.code;
      }
      return 0;
    }
    function mapTransportError(transportError) {
      if (transportError.status === 409) {
        return new SyncNetworkError(messageFromErrorBody(transportError), transportError.status, codeFromErrorBody(transportError), transportError.body);
      } else if (transportError.status) {
        return new SyncError(messageFromErrorBody(transportError), transportError.status, codeFromErrorBody(transportError));
      } else if (transportError instanceof twilsock.TransportUnavailableError) {
        return transportError;
      } else {
        return new SyncError(transportError.message, 0, 0);
      }
    }
    var NetworkService = function() {
      function NetworkService2(clientInfo, config, transport) {
        _classCallCheck__default["default"](this, NetworkService2);
        this.clientInfo = clientInfo;
        this.config = config;
        this.transport = transport;
      }
      _createClass__default["default"](NetworkService2, [{
        key: "createHeaders",
        value: function createHeaders() {
          return {
            "Content-Type": "application/json",
            "Twilio-Sync-Client-Info": JSON.stringify(this.clientInfo),
            "Twilio-Request-Id": "RQ" + uuid__namespace.v4().replace(/-/g, "")
          };
        }
      }, {
        key: "backoffConfig",
        value: function backoffConfig() {
          return Object.assign({
            min: MINIMUM_RETRY_DELAY,
            max: MAXIMUM_RETRY_DELAY,
            maxAttemptsTime: MAXIMUM_ATTEMPTS_TIME,
            randomness: RETRY_DELAY_RANDOMNESS
          }, this.config.backoffConfig);
        }
      }, {
        key: "executeWithRetry",
        value: function executeWithRetry(request) {
          var _this = this;
          var retryWhenThrottled = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          return new Promise(function(resolve, reject) {
            var codesToRetryOn = [502, 503, 504];
            if (retryWhenThrottled) {
              codesToRetryOn.push(429);
            }
            var retrier = new operationRetrier.Retrier(_this.backoffConfig());
            retrier.on("attempt", function() {
              request().then(function(result) {
                return retrier.succeeded(result);
              }).catch(function(err) {
                if (codesToRetryOn.includes(err.status)) {
                  var delayOverride = parseInt(err.headers ? err.headers["Retry-After"] : null);
                  retrier.failed(mapTransportError(err), isNaN(delayOverride) ? null : delayOverride * 1e3);
                } else if (err.message === "Twilsock disconnected") {
                  retrier.failed(mapTransportError(err));
                } else {
                  retrier.removeAllListeners();
                  retrier.cancel();
                  reject(mapTransportError(err));
                }
              });
            });
            retrier.on("succeeded", function(result) {
              resolve(result);
            });
            retrier.on("cancelled", function(err) {
              return reject(mapTransportError(err));
            });
            retrier.on("failed", function(err) {
              return reject(mapTransportError(err));
            });
            retrier.start();
          });
        }
        /**
         * Make a GET request by given URI
         * @Returns Promise<Response> Result of successful get request
         */
      }, {
        key: "get",
        value: function get(uri) {
          var _this2 = this;
          var headers = this.createHeaders();
          log$1.debug("GET", uri, "ID:", headers["Twilio-Request-Id"]);
          return this.executeWithRetry(function() {
            return _this2.transport.get(uri, headers, _this2.config.productId);
          }, true);
        }
      }, {
        key: "post",
        value: function post(uri, body, revision) {
          var _this3 = this;
          var retryWhenThrottled = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
          var headers = this.createHeaders();
          if (typeof revision !== "undefined" && revision !== null) {
            headers["If-Match"] = revision;
          }
          log$1.debug("POST", uri, "ID:", headers["Twilio-Request-Id"]);
          return this.executeWithRetry(function() {
            return _this3.transport.post(uri, headers, body, _this3.config.productId);
          }, retryWhenThrottled);
        }
      }, {
        key: "put",
        value: function put(uri, body, revision) {
          var _this4 = this;
          var headers = this.createHeaders();
          if (typeof revision !== "undefined" && revision !== null) {
            headers["If-Match"] = revision;
          }
          log$1.debug("PUT", uri, "ID:", headers["Twilio-Request-Id"]);
          return this.executeWithRetry(function() {
            return _this4.transport.put(uri, headers, body, _this4.config.productId);
          }, false);
        }
      }, {
        key: "delete",
        value: function _delete(uri) {
          var _this5 = this;
          var headers = this.createHeaders();
          log$1.debug("DELETE", uri, "ID:", headers["Twilio-Request-Id"]);
          return this.executeWithRetry(function() {
            return _this5.transport.delete(uri, headers, _this5.config.productId);
          }, false);
        }
      }]);
      return NetworkService2;
    }();
    var SessionStorage = function() {
      function SessionStorage2(config, storage) {
        _classCallCheck__default["default"](this, SessionStorage2);
        this.config = config;
        this.storageId = null;
        try {
          this.storage = storage || sessionStorage;
        } catch (e) {
        }
      }
      _createClass__default["default"](SessionStorage2, [{
        key: "storageKey",
        value: function storageKey(type, key) {
          return "".concat(this.storageId, "::").concat(type, "::").concat(key);
        }
      }, {
        key: "isReady",
        get: function get() {
          return this.config.sessionStorageEnabled && !!this.storageId;
        }
      }, {
        key: "updateStorageId",
        value: function updateStorageId(storageId) {
          this.storageId = storageId;
        }
      }, {
        key: "store",
        value: function store(type, id, value) {
          if (!this.isReady) {
            return null;
          }
          return this._store(this.storageKey(type, id), value);
        }
      }, {
        key: "read",
        value: function read(type, id) {
          if (!this.isReady) {
            return null;
          }
          return this._read(this.storageKey(type, id));
        }
      }, {
        key: "remove",
        value: function remove(type, sid, uniqueName) {
          if (!this.isReady) {
            return null;
          }
          try {
            this.storage.removeItem(this.storageKey(type, sid));
            if (uniqueName) {
              this.storage.removeItem(this.storageKey(type, uniqueName));
            }
          } catch (e) {
          }
        }
      }, {
        key: "update",
        value: function update(type, sid, uniqueName, patch) {
          if (!this.isReady) {
            return null;
          }
          this._apply(this.storageKey(type, sid), patch);
          if (uniqueName) {
            this._apply(this.storageKey(type, uniqueName), patch);
          }
        }
      }, {
        key: "_store",
        value: function _store(key, value) {
          try {
            this.storage.setItem(key, JSON.stringify(value));
          } catch (e) {
          }
        }
      }, {
        key: "_read",
        value: function _read(key) {
          try {
            var storedData = this.storage.getItem(key);
            if (storedData) {
              return JSON.parse(storedData);
            }
          } catch (e) {
          }
          return null;
        }
      }, {
        key: "_apply",
        value: function _apply(key, patch) {
          var value = this._read(key);
          if (!value) {
            return false;
          }
          this._store(key, Object.assign(value, patch));
        }
      }]);
      return SessionStorage2;
    }();
    function _createForOfIteratorHelper$2(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      } };
    }
    function _unsupportedIterableToArray$2(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray$2(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen);
    }
    function _arrayLikeToArray$2(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var SyncEntity = function() {
      function SyncEntity2(services, removalHandler) {
        _classCallCheck__default["default"](this, SyncEntity2);
        this.services = services;
        this.removalHandler = removalHandler;
        this.subscriptionState = "none";
        this._attachedListeners = /* @__PURE__ */ new Map();
      }
      _createClass__default["default"](SyncEntity2, [{
        key: "_advanceLastEventId",
        value: function _advanceLastEventId(eventId, revision) {
        }
      }, {
        key: "reportFailure",
        value: function reportFailure(err) {
          if (err.status === 404) {
            this.onRemoved(false);
          } else {
            this.broadcastEventToListeners("failure", err);
          }
        }
        /**
         * Subscribe to changes of data entity
         * @private
         */
      }, {
        key: "_subscribe",
        value: function _subscribe() {
          this.services.router._subscribe(this.sid, this);
        }
        /**
         * Unsubscribe from changes of current data entity
         * @private
         */
      }, {
        key: "_unsubscribe",
        value: function _unsubscribe() {
          this.services.router._unsubscribe(this.sid);
        }
      }, {
        key: "_setSubscriptionState",
        value: function _setSubscriptionState(newState) {
          this.subscriptionState = newState;
          this.broadcastEventToListeners("_subscriptionStateChanged", newState);
        }
        /**
         * @public
         */
      }, {
        key: "close",
        value: function close() {
          this._unsubscribe();
          if (this.removalHandler != null) {
            this.removalHandler(this.type, this.sid, this.uniqueName);
          }
        }
      }, {
        key: "attach",
        value: function attach(closeable) {
          var uuid2 = closeable.listenerUuid;
          var existingRecord = this._attachedListeners.get(uuid2);
          if (existingRecord) {
            return;
          }
          if (!this._attachedListeners.size) {
            this._subscribe();
          }
          this._attachedListeners.set(uuid2, closeable);
        }
      }, {
        key: "detach",
        value: function detach(listenerUuid) {
          this._attachedListeners.delete(listenerUuid);
          if (!this._attachedListeners.size) {
            this.close();
          }
        }
      }, {
        key: "broadcastEventToListeners",
        value: function broadcastEventToListeners(eventName, args) {
          var _iterator = _createForOfIteratorHelper$2(this._attachedListeners.values()), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var listener = _step.value;
              listener.emit(eventName, args);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      }]);
      return SyncEntity2;
    }();
    var MergingQueue = function() {
      function MergingQueue2(inputMergingFunction) {
        _classCallCheck__default["default"](this, MergingQueue2);
        _defineProperty__default["default"](this, "queuedRequests", []);
        _defineProperty__default["default"](this, "isRequestInFlight", false);
        this.inputMergingFunction = inputMergingFunction;
      }
      _createClass__default["default"](MergingQueue2, [{
        key: "add",
        value: function add(input, requestFunction) {
          var _this = this;
          var promise = new Promise(function(resolve, reject) {
            return _this.queuedRequests.push({
              input,
              requestFunction,
              resolve,
              reject
            });
          });
          this.wakeupQueue();
          return promise;
        }
      }, {
        key: "squashAndAdd",
        value: function squashAndAdd(input, requestFunction) {
          var queueToSquash = this.queuedRequests;
          this.queuedRequests = [];
          var reducedInput;
          if (queueToSquash.length > 0) {
            reducedInput = queueToSquash.map(function(r) {
              return r.input;
            }).reduce(this.inputMergingFunction);
            reducedInput = this.inputMergingFunction(reducedInput, input);
          } else {
            reducedInput = input;
          }
          var promise = this.add(reducedInput, requestFunction);
          queueToSquash.forEach(function(request) {
            return promise.then(request.resolve, request.reject);
          });
          return promise;
        }
      }, {
        key: "isEmpty",
        value: function isEmpty() {
          return this.queuedRequests.length === 0 && !this.isRequestInFlight;
        }
      }, {
        key: "wakeupQueue",
        value: function wakeupQueue() {
          var _this2 = this;
          if (this.queuedRequests.length === 0 || this.isRequestInFlight) {
            return;
          } else {
            var requestToExecute = this.queuedRequests.shift();
            this.isRequestInFlight = true;
            requestToExecute.requestFunction(requestToExecute.input).then(requestToExecute.resolve, requestToExecute.reject).then(function(__) {
              _this2.isRequestInFlight = false;
              _this2.wakeupQueue();
            });
          }
        }
      }]);
      return MergingQueue2;
    }();
    var NamespacedMergingQueue = function() {
      function NamespacedMergingQueue2(inputReducer) {
        _classCallCheck__default["default"](this, NamespacedMergingQueue2);
        _defineProperty__default["default"](this, "queueByNamespaceKey", /* @__PURE__ */ new Map());
        this.inputReducer = inputReducer;
      }
      _createClass__default["default"](NamespacedMergingQueue2, [{
        key: "add",
        value: function() {
          var _add = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee(namespaceKey, input, requestFunction) {
            return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    return _context.abrupt("return", this.invokeQueueMethod(namespaceKey, function(queue) {
                      return queue.add(input, requestFunction);
                    }));
                  case 1:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function add(_x, _x2, _x3) {
            return _add.apply(this, arguments);
          }
          return add;
        }()
      }, {
        key: "squashAndAdd",
        value: function() {
          var _squashAndAdd = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee2(namespaceKey, input, requestFunction) {
            return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    return _context2.abrupt("return", this.invokeQueueMethod(namespaceKey, function(queue) {
                      return queue.squashAndAdd(input, requestFunction);
                    }));
                  case 1:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function squashAndAdd(_x4, _x5, _x6) {
            return _squashAndAdd.apply(this, arguments);
          }
          return squashAndAdd;
        }()
      }, {
        key: "invokeQueueMethod",
        value: function() {
          var _invokeQueueMethod = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee3(namespaceKey, queueMethodInvoker) {
            var queue, result;
            return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    if (!this.queueByNamespaceKey.has(namespaceKey)) {
                      this.queueByNamespaceKey.set(namespaceKey, new MergingQueue(this.inputReducer));
                    }
                    queue = this.queueByNamespaceKey.get(namespaceKey);
                    result = queueMethodInvoker(queue);
                    if (this.queueByNamespaceKey.get(namespaceKey).isEmpty()) {
                      this.queueByNamespaceKey.delete(namespaceKey);
                    }
                    return _context3.abrupt("return", result);
                  case 5:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));
          function invokeQueueMethod(_x7, _x8) {
            return _invokeQueueMethod.apply(this, arguments);
          }
          return invokeQueueMethod;
        }()
      }]);
      return NamespacedMergingQueue2;
    }();
    function _createSuper$6(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$6();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$6() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var Closeable = function(_EventEmitter) {
      _inherits__default["default"](Closeable2, _EventEmitter);
      var _super = _createSuper$6(Closeable2);
      function Closeable2() {
        var _this;
        _classCallCheck__default["default"](this, Closeable2);
        _this = _super.call(this);
        _this.closed = false;
        _this.uuid = uuid.v4();
        return _this;
      }
      _createClass__default["default"](Closeable2, [{
        key: "listenerUuid",
        get: function get() {
          return this.uuid;
        }
      }, {
        key: "close",
        value: function close() {
          this.removeAllListeners();
          this.closed = true;
        }
      }, {
        key: "ensureNotClosed",
        value: function ensureNotClosed() {
          if (this.closed) {
            throw new Error("Invalid operation on closed object");
          }
        }
      }]);
      return Closeable2;
    }(EventEmitter);
    function _createSuper$5(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$5();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$5() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var SyncDocumentImpl = function(_SyncEntity) {
      _inherits__default["default"](SyncDocumentImpl2, _SyncEntity);
      var _super = _createSuper$5(SyncDocumentImpl2);
      function SyncDocumentImpl2(services, descriptor, removalHandler) {
        var _this;
        _classCallCheck__default["default"](this, SyncDocumentImpl2);
        _this = _super.call(this, services, removalHandler);
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "isDeleted", false);
        var updateRequestReducer = function updateRequestReducer2(acc, input) {
          return typeof input.ttl === "number" ? {
            ttl: input.ttl
          } : acc;
        };
        _this.updateMergingQueue = new MergingQueue(updateRequestReducer);
        _this.descriptor = descriptor;
        _this.descriptor.data = _this.descriptor.data || {};
        _this.descriptor.date_updated = new Date(_this.descriptor.date_updated);
        return _this;
      }
      _createClass__default["default"](SyncDocumentImpl2, [{
        key: "uri",
        get: function get() {
          return this.descriptor.url;
        }
      }, {
        key: "revision",
        get: function get() {
          return this.descriptor.revision;
        }
      }, {
        key: "lastEventId",
        get: function get() {
          return this.descriptor.last_event_id;
        }
      }, {
        key: "dateExpires",
        get: function get() {
          return this.descriptor.date_expires;
        }
      }, {
        key: "type",
        get: function get() {
          return "document";
        }
        // below properties are specific to Insights only
      }, {
        key: "indexName",
        get: function get() {
          return void 0;
        }
      }, {
        key: "queryString",
        get: function get() {
          return void 0;
        }
        // public props, documented along with class description
      }, {
        key: "sid",
        get: function get() {
          return this.descriptor.sid;
        }
      }, {
        key: "data",
        get: function get() {
          return this.descriptor.data;
        }
      }, {
        key: "dateUpdated",
        get: function get() {
          return this.descriptor.date_updated;
        }
      }, {
        key: "uniqueName",
        get: function get() {
          return this.descriptor.unique_name || null;
        }
        /**
         * Update data entity with new data
         * @private
         */
      }, {
        key: "_update",
        value: function _update(update) {
          update.date_created = new Date(update.date_created);
          switch (update.type) {
            case "document_updated":
              if (update.id <= this.lastEventId) {
                log$1.trace("Document update skipped, current:", this.lastEventId, ", remote:", update.id);
                break;
              }
              var previousData = this.descriptor.data !== void 0 ? deepClone(this.descriptor.data) : null;
              this.descriptor.last_event_id = update.id;
              this.descriptor.revision = update.document_revision;
              this.descriptor.date_updated = update.date_created;
              this.descriptor.data = update.document_data;
              this.broadcastEventToListeners("updated", {
                data: update.document_data,
                isLocal: false,
                previousData
              });
              this.services.storage.update(this.type, this.sid, this.uniqueName, {
                last_event_id: update.id,
                revision: update.document_revision,
                date_updated: update.date_created,
                data: update.document_data
              });
              break;
            case "document_removed":
              this.onRemoved(false);
              break;
          }
        }
      }, {
        key: "set",
        value: function() {
          var _set = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee(value, metadataUpdates) {
            var _this2 = this;
            var input;
            return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    input = metadataUpdates || {};
                    return _context.abrupt("return", this.updateMergingQueue.squashAndAdd(input, function(input2) {
                      return _this2._setUnconditionally(value, input2.ttl);
                    }));
                  case 2:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function set(_x, _x2) {
            return _set.apply(this, arguments);
          }
          return set;
        }()
      }, {
        key: "mutate",
        value: function() {
          var _mutate = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee2(mutator, metadataUpdates) {
            var _this3 = this;
            var input;
            return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    input = metadataUpdates || {};
                    return _context2.abrupt("return", this.updateMergingQueue.add(input, function(input2) {
                      return _this3._setWithIfMatch(mutator, input2.ttl);
                    }));
                  case 2:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function mutate(_x3, _x4) {
            return _mutate.apply(this, arguments);
          }
          return mutate;
        }()
      }, {
        key: "update",
        value: function() {
          var _update2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee3(obj, metadataUpdates) {
            return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    return _context3.abrupt("return", this.mutate(function(remote) {
                      return Object.assign(remote, obj);
                    }, metadataUpdates));
                  case 1:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));
          function update(_x5, _x6) {
            return _update2.apply(this, arguments);
          }
          return update;
        }()
      }, {
        key: "setTtl",
        value: function() {
          var _setTtl = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee4(ttl) {
            var response;
            return _regeneratorRuntime__default["default"].wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    _context4.next = 2;
                    return this._postUpdateToServer({
                      ttl
                    });
                  case 2:
                    response = _context4.sent;
                    this.descriptor.date_expires = response.date_expires;
                  case 4:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));
          function setTtl(_x7) {
            return _setTtl.apply(this, arguments);
          }
          return setTtl;
        }()
        /**
         * @private
         */
      }, {
        key: "_setUnconditionally",
        value: function() {
          var _setUnconditionally2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee5(value, ttl) {
            var result;
            return _regeneratorRuntime__default["default"].wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    _context5.next = 2;
                    return this._postUpdateToServer({
                      data: value,
                      revision: void 0,
                      ttl
                    });
                  case 2:
                    result = _context5.sent;
                    this._handleSuccessfulUpdateResult(result);
                    return _context5.abrupt("return", this.descriptor.data);
                  case 5:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));
          function _setUnconditionally(_x8, _x9) {
            return _setUnconditionally2.apply(this, arguments);
          }
          return _setUnconditionally;
        }()
        /**
         * @private
         */
      }, {
        key: "_setWithIfMatch",
        value: function() {
          var _setWithIfMatch2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee6(mutatorFunction, ttl) {
            var data, revision, result;
            return _regeneratorRuntime__default["default"].wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    data = mutatorFunction(deepClone(this.descriptor.data));
                    if (!data) {
                      _context6.next = 22;
                      break;
                    }
                    revision = this.revision;
                    _context6.prev = 3;
                    _context6.next = 6;
                    return this._postUpdateToServer({
                      data,
                      revision,
                      ttl
                    });
                  case 6:
                    result = _context6.sent;
                    this._handleSuccessfulUpdateResult(result);
                    return _context6.abrupt("return", this.descriptor.data);
                  case 11:
                    _context6.prev = 11;
                    _context6.t0 = _context6["catch"](3);
                    if (!(_context6.t0.status === 412)) {
                      _context6.next = 19;
                      break;
                    }
                    _context6.next = 16;
                    return this._softSync();
                  case 16:
                    return _context6.abrupt("return", this._setWithIfMatch(mutatorFunction));
                  case 19:
                    throw _context6.t0;
                  case 20:
                    _context6.next = 23;
                    break;
                  case 22:
                    return _context6.abrupt("return", this.descriptor.data);
                  case 23:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, this, [[3, 11]]);
          }));
          function _setWithIfMatch(_x10, _x11) {
            return _setWithIfMatch2.apply(this, arguments);
          }
          return _setWithIfMatch;
        }()
        /**
         * @private
         */
      }, {
        key: "_handleSuccessfulUpdateResult",
        value: function _handleSuccessfulUpdateResult(result) {
          if (result.last_event_id <= this.descriptor.last_event_id) {
            return;
          }
          var previousData = this.descriptor.data !== void 0 ? deepClone(this.descriptor.data) : null;
          this.descriptor.revision = result.revision;
          this.descriptor.data = result.data;
          this.descriptor.last_event_id = result.last_event_id;
          this.descriptor.date_expires = result.date_expires;
          this.descriptor.date_updated = new Date(result.date_updated);
          this.services.storage.update(this.type, this.sid, this.uniqueName, {
            last_event_id: result.last_event_id,
            revision: result.revision,
            date_updated: result.date_updated,
            data: result.data
          });
          this.broadcastEventToListeners("updated", {
            data: this.descriptor.data,
            isLocal: true,
            previousData
          });
        }
        /**
         * @private
         */
      }, {
        key: "_postUpdateToServer",
        value: function() {
          var _postUpdateToServer2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee7(request) {
            var requestBody, ifMatch, response;
            return _regeneratorRuntime__default["default"].wrap(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    if (this.isDeleted) {
                      _context7.next = 17;
                      break;
                    }
                    requestBody = {
                      data: request.data
                    };
                    if (request.ttl !== void 0) {
                      requestBody.ttl = request.ttl;
                    }
                    ifMatch = request.revision;
                    _context7.prev = 4;
                    _context7.next = 7;
                    return this.services.network.post(this.uri, requestBody, ifMatch);
                  case 7:
                    response = _context7.sent;
                    return _context7.abrupt("return", {
                      revision: response.body.revision,
                      data: request.data,
                      last_event_id: response.body.last_event_id,
                      date_updated: response.body.date_updated,
                      date_expires: response.body.date_expires
                    });
                  case 11:
                    _context7.prev = 11;
                    _context7.t0 = _context7["catch"](4);
                    if (_context7.t0.status === 404) {
                      this.onRemoved(false);
                    }
                    throw _context7.t0;
                  case 15:
                    _context7.next = 18;
                    break;
                  case 17:
                    return _context7.abrupt("return", Promise.reject(new SyncError("The Document has been removed", 404, 54100)));
                  case 18:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee7, this, [[4, 11]]);
          }));
          function _postUpdateToServer(_x12) {
            return _postUpdateToServer2.apply(this, arguments);
          }
          return _postUpdateToServer;
        }()
        /**
         * Get new data from server
         * @private
         */
      }, {
        key: "_softSync",
        value: function() {
          var _softSync2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee8() {
            var _this4 = this;
            return _regeneratorRuntime__default["default"].wrap(function _callee8$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    return _context8.abrupt("return", this.services.network.get(this.uri).then(function(response) {
                      var event = {
                        type: "document_updated",
                        id: response.body.last_event_id,
                        document_revision: response.body.revision,
                        document_data: response.body.data,
                        date_created: response.body.date_updated
                      };
                      _this4._update(event);
                      return _this4;
                    }).catch(function(err) {
                      if (err.status === 404) {
                        _this4.onRemoved(false);
                      } else {
                        log$1.error("Can't get updates for ".concat(_this4.sid, ":"), err);
                      }
                    }));
                  case 1:
                  case "end":
                    return _context8.stop();
                }
              }
            }, _callee8, this);
          }));
          function _softSync() {
            return _softSync2.apply(this, arguments);
          }
          return _softSync;
        }()
      }, {
        key: "onRemoved",
        value: function onRemoved(locally) {
          if (this.isDeleted) {
            return;
          }
          var previousData = this.descriptor.data !== void 0 ? deepClone(this.descriptor.data) : null;
          this.isDeleted = true;
          this._unsubscribe();
          this.removalHandler(this.type, this.sid, this.uniqueName);
          this.broadcastEventToListeners("removed", {
            isLocal: locally,
            previousData
          });
        }
      }, {
        key: "removeDocument",
        value: function() {
          var _removeDocument = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee9() {
            return _regeneratorRuntime__default["default"].wrap(function _callee9$(_context9) {
              while (1) {
                switch (_context9.prev = _context9.next) {
                  case 0:
                    if (this.isDeleted) {
                      _context9.next = 6;
                      break;
                    }
                    _context9.next = 3;
                    return this.services.network.delete(this.uri);
                  case 3:
                    this.onRemoved(true);
                    _context9.next = 7;
                    break;
                  case 6:
                    return _context9.abrupt("return", Promise.reject(new SyncError("The Document has been removed", 404, 54100)));
                  case 7:
                  case "end":
                    return _context9.stop();
                }
              }
            }, _callee9, this);
          }));
          function removeDocument() {
            return _removeDocument.apply(this, arguments);
          }
          return removeDocument;
        }()
      }], [{
        key: "type",
        get: function get() {
          return "document";
        }
      }]);
      return SyncDocumentImpl2;
    }(SyncEntity);
    var SyncDocument = function(_Closeable) {
      _inherits__default["default"](SyncDocument2, _Closeable);
      var _super2 = _createSuper$5(SyncDocument2);
      function SyncDocument2(syncDocumentImpl) {
        var _this5;
        _classCallCheck__default["default"](this, SyncDocument2);
        _this5 = _super2.call(this);
        _this5.syncDocumentImpl = syncDocumentImpl;
        _this5.syncDocumentImpl.attach(_assertThisInitialized__default["default"](_this5));
        return _this5;
      }
      _createClass__default["default"](SyncDocument2, [{
        key: "uri",
        get: (
          // private props
          function get() {
            return this.syncDocumentImpl.uri;
          }
        )
      }, {
        key: "revision",
        get: function get() {
          return this.syncDocumentImpl.revision;
        }
      }, {
        key: "lastEventId",
        get: function get() {
          return this.syncDocumentImpl.lastEventId;
        }
      }, {
        key: "dateExpires",
        get: function get() {
          return this.syncDocumentImpl.dateExpires;
        }
      }, {
        key: "type",
        get: function get() {
          return SyncDocumentImpl.type;
        }
        /**
         * The immutable identifier of this document, assigned by the system.
         */
      }, {
        key: "sid",
        get: function get() {
          return this.syncDocumentImpl.sid;
        }
        /**
         * The contents of this document.
         */
      }, {
        key: "data",
        get: function get() {
          return this.syncDocumentImpl.data;
        }
        /**
         * Date when the document was last updated.
         */
      }, {
        key: "dateUpdated",
        get: function get() {
          return this.syncDocumentImpl.dateUpdated;
        }
        /**
         * An optional immutable identifier that may be assigned by the programmer
         * to this document during creation. Globally unique among other documents.
         */
      }, {
        key: "uniqueName",
        get: function get() {
          return this.syncDocumentImpl.uniqueName;
        }
      }, {
        key: "set",
        value: (
          /**
           * Assign new contents to this document. The current data will be overwritten.
           * @param data The new contents to assign.
           * @param metadataUpdates New document metadata.
           * @return A promise resolving to the new data of the document.
           * @example
           * ```typescript
           * // Say, the Document data is `{ name: 'John Smith', age: 34 }`
           * document.set({ name: 'Barbara Oaks' }, { ttl: 86400 })
           *   .then((newValue) => {
           *     // Now the Document data is `{ name: 'Barbara Oaks' }`
           *     console.log('Document set() successful, new data:', newValue);
           *   })
           *   .catch((error) => {
           *     console.error('Document set() failed', error);
           *   });
           * ```
           */
          function() {
            var _set2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee10(data, metadataUpdates) {
              return _regeneratorRuntime__default["default"].wrap(function _callee10$(_context10) {
                while (1) {
                  switch (_context10.prev = _context10.next) {
                    case 0:
                      this.ensureNotClosed();
                      return _context10.abrupt("return", this.syncDocumentImpl.set(data, metadataUpdates));
                    case 2:
                    case "end":
                      return _context10.stop();
                  }
                }
              }, _callee10, this);
            }));
            function set(_x13, _x14) {
              return _set2.apply(this, arguments);
            }
            return set;
          }()
        )
        /**
         * Schedules a modification to this document that will apply a mutation function.
         * @param mutator A function that outputs new data based on the existing data.
         * May be called multiple times, particularly if this document is modified concurrently by remote code.
         * If the mutation ultimately succeeds, the document will have made the particular transition described
         * by this function.
         * @param metadataUpdates New document metadata.
         * @return Resolves with the most recent Document state, whether the output of a
         * successful mutation or a state that prompted graceful cancellation (mutator returned `null`).
         * @example
         * ```typescript
         * const mutatorFunction = (currentValue) => {
         *     currentValue.viewCount = (currentValue.viewCount ?? 0) + 1;
         *     return currentValue;
         * };
         * document.mutate(mutatorFunction, { ttl: 86400 }))
         *   .then((newValue) => {
         *     console.log('Document mutate() successful, new data:', newValue);
         *   })
         *   .catch((error) => {
         *     console.error('Document mutate() failed', error);
         *   });
         * ```
         */
      }, {
        key: "mutate",
        value: function() {
          var _mutate2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee11(mutator, metadataUpdates) {
            return _regeneratorRuntime__default["default"].wrap(function _callee11$(_context11) {
              while (1) {
                switch (_context11.prev = _context11.next) {
                  case 0:
                    this.ensureNotClosed();
                    return _context11.abrupt("return", this.syncDocumentImpl.mutate(mutator, metadataUpdates));
                  case 2:
                  case "end":
                    return _context11.stop();
                }
              }
            }, _callee11, this);
          }));
          function mutate(_x15, _x16) {
            return _mutate2.apply(this, arguments);
          }
          return mutate;
        }()
        /**
         * Modify a document by appending new fields (or by overwriting existing ones) with the values from the provided Object.
         * This is equivalent to:
         * ```typescript
         * document.mutate((currentValue) => Object.assign(currentValue, obj));
         * ```
         * @param obj Specifies the particular (top-level) attributes that will receive new values.
         * @param metadataUpdates New document metadata.
         * @return A promise resolving to the new data of the document.
         * @example
         * ```typescript
         * // Say, the Document data is `{ name: 'John Smith' }`
         * document.update({ age: 34 }, { ttl: 86400 })
         *   .then((newValue) => {
         *     // Now the Document data is `{ name: 'John Smith', age: 34 }`
         *     console.log('Document update() successful, new data:', newValue);
         *   })
         *   .catch((error) => {
         *     console.error('Document update() failed', error);
         *   });
         * ```
         */
      }, {
        key: "update",
        value: function() {
          var _update3 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee12(obj, metadataUpdates) {
            return _regeneratorRuntime__default["default"].wrap(function _callee12$(_context12) {
              while (1) {
                switch (_context12.prev = _context12.next) {
                  case 0:
                    this.ensureNotClosed();
                    return _context12.abrupt("return", this.syncDocumentImpl.update(obj, metadataUpdates));
                  case 2:
                  case "end":
                    return _context12.stop();
                }
              }
            }, _callee12, this);
          }));
          function update(_x17, _x18) {
            return _update3.apply(this, arguments);
          }
          return update;
        }()
        /**
         * Update the time-to-live of the document.
         * @param ttl Specifies the time-to-live in seconds after which the document is subject to automatic deletion. The value 0 means infinity.
         * @return A promise that resolves after the TTL update was successful.
         * @example
         * ```typescript
         * document.setTtl(3600)
         *   .then(() => {
         *     console.log('Document setTtl() successful');
         *   })
         *   .catch((error) => {
         *     console.error('Document setTtl() failed', error);
         *   });
         * ```
         */
      }, {
        key: "setTtl",
        value: function() {
          var _setTtl2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee13(ttl) {
            return _regeneratorRuntime__default["default"].wrap(function _callee13$(_context13) {
              while (1) {
                switch (_context13.prev = _context13.next) {
                  case 0:
                    this.ensureNotClosed();
                    return _context13.abrupt("return", this.syncDocumentImpl.setTtl(ttl));
                  case 2:
                  case "end":
                    return _context13.stop();
                }
              }
            }, _callee13, this);
          }));
          function setTtl(_x19) {
            return _setTtl2.apply(this, arguments);
          }
          return setTtl;
        }()
        /**
         * Delete a document.
         * @return A promise which resolves if (and only if) the document is ultimately deleted.
         * @example
         * ```typescript
         * document.removeDocument()
         *   .then(() => {
         *     console.log('Document removeDocument() successful');
         *   })
         *   .catch((error) => {
         *     console.error('Document removeDocument() failed', error);
         *   });
         * ```
         */
      }, {
        key: "removeDocument",
        value: function() {
          var _removeDocument2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee14() {
            return _regeneratorRuntime__default["default"].wrap(function _callee14$(_context14) {
              while (1) {
                switch (_context14.prev = _context14.next) {
                  case 0:
                    this.ensureNotClosed();
                    return _context14.abrupt("return", this.syncDocumentImpl.removeDocument());
                  case 2:
                  case "end":
                    return _context14.stop();
                }
              }
            }, _callee14, this);
          }));
          function removeDocument() {
            return _removeDocument2.apply(this, arguments);
          }
          return removeDocument;
        }()
        /**
         * Conclude work with the document instance and remove all event listeners attached to it.
         * Any subsequent operation on this object will be rejected with error.
         * Other local copies of this document will continue operating and receiving events normally.
         * @example
         * ```typescript
         * document.close();
         * ```
         */
      }, {
        key: "close",
        value: function close() {
          _get__default["default"](_getPrototypeOf__default["default"](SyncDocument2.prototype), "close", this).call(this);
          this.syncDocumentImpl.detach(this.listenerUuid);
        }
      }], [{
        key: "type",
        get: function get() {
          return SyncDocumentImpl.type;
        }
      }]);
      return SyncDocument2;
    }(Closeable);
    _defineProperty__default["default"](SyncDocument, "removed", "removed");
    _defineProperty__default["default"](SyncDocument, "updated", "updated");
    __decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.pureObject, ["undefined", declarativeTypeValidator.objectSchema("document metadata", {
      ttl: [declarativeTypeValidator.nonNegativeInteger, "undefined"]
    })]), __metadata("design:type", Function), __metadata("design:paramtypes", [Object, Object]), __metadata("design:returntype", Promise)], SyncDocument.prototype, "set", null);
    __decorate([declarativeTypeValidator.validateTypesAsync("function", ["undefined", declarativeTypeValidator.objectSchema("document metadata", {
      ttl: [declarativeTypeValidator.nonNegativeInteger, "undefined"]
    })]), __metadata("design:type", Function), __metadata("design:paramtypes", [Function, Object]), __metadata("design:returntype", Promise)], SyncDocument.prototype, "mutate", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.pureObject, ["undefined", declarativeTypeValidator.objectSchema("document metadata", {
      ttl: [declarativeTypeValidator.nonNegativeInteger, "undefined"]
    })]), __metadata("design:type", Function), __metadata("design:paramtypes", [Object, Object]), __metadata("design:returntype", Promise)], SyncDocument.prototype, "update", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger), __metadata("design:type", Function), __metadata("design:paramtypes", [Number]), __metadata("design:returntype", Promise)], SyncDocument.prototype, "setTtl", null);
    var SyncListItem = function() {
      function SyncListItem2(descriptor) {
        _classCallCheck__default["default"](this, SyncListItem2);
        this.descriptor = descriptor;
      }
      _createClass__default["default"](SyncListItem2, [{
        key: "uri",
        get: function get() {
          return this.descriptor.uri;
        }
      }, {
        key: "revision",
        get: function get() {
          return this.descriptor.revision;
        }
      }, {
        key: "lastEventId",
        get: function get() {
          return this.descriptor.lastEventId;
        }
        /**
         * Date when the list item was last updated.
         */
      }, {
        key: "dateUpdated",
        get: function get() {
          return this.descriptor.dateUpdated;
        }
      }, {
        key: "dateExpires",
        get: function get() {
          return this.descriptor.dateExpires;
        }
        /**
         * The index, within the containing list, of this item. This index is stable;
         * even if lower-indexed items are removed, this index will remain as is.
         */
      }, {
        key: "index",
        get: function get() {
          return this.descriptor.index;
        }
        /**
         * The contents of the item.
         */
      }, {
        key: "data",
        get: function get() {
          return this.descriptor.data;
        }
        /**
         * @internal
         */
      }, {
        key: "update",
        value: function update(eventId, revision, data, dateUpdated) {
          this.descriptor.lastEventId = eventId;
          this.descriptor.revision = revision;
          this.descriptor.data = data;
          this.descriptor.dateUpdated = dateUpdated;
          return this;
        }
        /**
         * @internal
         */
      }, {
        key: "updateDateExpires",
        value: function updateDateExpires(dateExpires) {
          this.descriptor.dateExpires = dateExpires;
        }
      }]);
      return SyncListItem2;
    }();
    var Paginator = function() {
      function Paginator2(items, source, prevToken, nextToken) {
        _classCallCheck__default["default"](this, Paginator2);
        this.prevToken = prevToken;
        this.nextToken = nextToken;
        this.items = items;
        this.source = source;
      }
      _createClass__default["default"](Paginator2, [{
        key: "hasNextPage",
        get: function get() {
          return !!this.nextToken;
        }
        /**
         * Indicates the existence of the previous page.
         */
      }, {
        key: "hasPrevPage",
        get: function get() {
          return !!this.prevToken;
        }
        /**
         * Request next page.
         * Does not modify existing object.
         */
      }, {
        key: "nextPage",
        value: function() {
          var _nextPage = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee() {
            return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (this.hasNextPage) {
                      _context.next = 2;
                      break;
                    }
                    throw new Error("No next page");
                  case 2:
                    return _context.abrupt("return", this.source(this.nextToken));
                  case 3:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function nextPage() {
            return _nextPage.apply(this, arguments);
          }
          return nextPage;
        }()
        /**
         * Request previous page.
         * Does not modify existing object.
         */
      }, {
        key: "prevPage",
        value: function() {
          var _prevPage = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee2() {
            return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    if (this.hasPrevPage) {
                      _context2.next = 2;
                      break;
                    }
                    throw new Error("No previous page");
                  case 2:
                    return _context2.abrupt("return", this.source(this.prevToken));
                  case 3:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function prevPage() {
            return _prevPage.apply(this, arguments);
          }
          return prevPage;
        }()
      }]);
      return Paginator2;
    }();
    function _createForOfIteratorHelper$1(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      } };
    }
    function _unsupportedIterableToArray$1(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
    }
    function _arrayLikeToArray$1(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var Node = function() {
      function Node2(key, value) {
        _classCallCheck__default["default"](this, Node2);
        this.balanceFactor = 0;
        this.key = key;
        this.value = value;
        this.parent = null;
        this.left = null;
        this.right = null;
      }
      _createClass__default["default"](Node2, [{
        key: "isRoot",
        get: function get() {
          return this.parent === null;
        }
      }, {
        key: "isLeaf",
        get: function get() {
          return this.left === null && this.right === null;
        }
      }, {
        key: "isLeftChild",
        get: function get() {
          return this.parent.left === this;
        }
      }, {
        key: "update",
        value: function update(value) {
          this.value = value;
        }
      }, {
        key: "replace",
        value: function replace(target, replacement) {
          if (!target) {
            return;
          }
          if (this.left === replacement) {
            this.left = replacement;
          } else if (this.right === replacement) {
            this.right = replacement;
          }
        }
      }]);
      return Node2;
    }();
    var TreeMap = function() {
      function TreeMap2(less, equal) {
        _classCallCheck__default["default"](this, TreeMap2);
        this.isLessThan = less || function(x, y) {
          return x < y;
        };
        this.isEqual = equal || function(x, y) {
          return x === y;
        };
        this.root = null;
        this.count = null;
      }
      _createClass__default["default"](TreeMap2, [{
        key: "size",
        get: function get() {
          return this.count;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.root = null;
          this.count = 0;
        }
      }, {
        key: "set",
        value: function set(key, value) {
          var node = this.getNode(key);
          if (node) {
            node.update(value);
          } else {
            this.insert(key, value);
          }
        }
      }, {
        key: "insert",
        value: function insert(key, value) {
          var node = new Node(key, value);
          this.count++;
          if (!this.root) {
            this.root = node;
            return;
          }
          var currNode = this.root;
          for (; ; ) {
            if (this.isLessThan(key, currNode.key)) {
              if (currNode.left) {
                currNode = currNode.left;
              } else {
                currNode.left = node;
                break;
              }
            } else {
              if (currNode.right) {
                currNode = currNode.right;
              } else {
                currNode.right = node;
                break;
              }
            }
          }
          node.parent = currNode;
          currNode = node;
          while (currNode.parent) {
            var parent = currNode.parent;
            var prevBalanceFactor = parent.balanceFactor;
            if (currNode.isLeftChild) {
              parent.balanceFactor++;
            } else {
              parent.balanceFactor--;
            }
            if (Math.abs(parent.balanceFactor) < Math.abs(prevBalanceFactor)) {
              break;
            }
            if (parent.balanceFactor < -1 || parent.balanceFactor > 1) {
              this.rebalance(parent);
              break;
            }
            currNode = parent;
          }
        }
      }, {
        key: "get",
        value: function get(key) {
          var currentNode = this.root;
          while (currentNode) {
            if (this.isEqual(key, currentNode.key)) {
              return currentNode.value;
            }
            if (this.isLessThan(key, currentNode.key)) {
              currentNode = currentNode.left;
            } else {
              currentNode = currentNode.right;
            }
          }
          return null;
        }
      }, {
        key: "delete",
        value: function _delete(key) {
          var node = this.getNode(key);
          if (!node || node.key !== key) {
            return null;
          }
          var parent = node.parent;
          var left = node.left;
          var right = node.right;
          if (!!left !== !!right) {
            var child = left || right;
            if (!parent && !child) {
              this.root = null;
            } else if (parent && !child) {
              this.root = child;
            } else {
              parent.replace(node, null);
              this.rebalance(parent);
            }
          } else {
            var maxLeft = node.left;
            while (maxLeft.right) {
              maxLeft = maxLeft.right;
            }
            if (node.left === maxLeft) {
              if (node.isRoot) {
                this.root = maxLeft;
                maxLeft.parent = null;
              } else {
                if (node.isLeftChild) {
                  node.parent.left = maxLeft;
                } else {
                  node.parent.right = maxLeft;
                }
                maxLeft.parent = node.parent;
              }
              maxLeft.right = node.right;
              maxLeft.right.parent = maxLeft;
              maxLeft.balanceFactor = node.balanceFactor;
              node = {
                parent: maxLeft,
                isLeftChild: true
              };
            } else {
              var mlParent = maxLeft.parent;
              var mlLeft = maxLeft.left;
              mlParent.right = mlLeft;
              if (mlLeft) {
                mlLeft.parent = mlParent;
              }
              if (node.isRoot) {
                this.root = maxLeft;
                maxLeft.parent = null;
              } else {
                if (node.isLeftChild) {
                  node.parent.left = maxLeft;
                } else {
                  node.parent.right = maxLeft;
                }
                maxLeft.parent = node.parent;
              }
              maxLeft.right = node.right;
              maxLeft.right.parent = maxLeft;
              maxLeft.left = node.left;
              maxLeft.left.parent = maxLeft;
              maxLeft.balanceFactor = node.balanceFactor;
              node = {
                parent: mlParent,
                isLeftChild: false
              };
            }
          }
          this.count--;
          while (node.parent) {
            var _parent = node.parent;
            var prevBalanceFactor = _parent.balanceFactor;
            if (node.isLeftChild) {
              _parent.balanceFactor -= 1;
            } else {
              _parent.balanceFactor += 1;
            }
            if (Math.abs(_parent.balanceFactor) > Math.abs(prevBalanceFactor)) {
              if (_parent.balanceFactor < -1 || _parent.balanceFactor > 1) {
                this.rebalance(_parent);
                if (_parent.parent.balanceFactor === 0) {
                  node = _parent.parent;
                } else {
                  break;
                }
              } else {
                break;
              }
            } else {
              node = _parent;
            }
          }
          return null;
        }
      }, {
        key: "getNode",
        value: function getNode(key) {
          var currentNode = this.root;
          while (currentNode) {
            if (this.isEqual(key, currentNode.key)) {
              return currentNode;
            }
            if (this.isLessThan(key, currentNode.key)) {
              currentNode = currentNode.left;
            } else {
              currentNode = currentNode.right;
            }
          }
          return null;
        }
      }, {
        key: "rebalance",
        value: function rebalance(node) {
          if (node.balanceFactor < 0) {
            if (node.right.balanceFactor > 0) {
              this.rotateRight(node.right);
              this.rotateLeft(node);
            } else {
              this.rotateLeft(node);
            }
          } else if (node.balanceFactor > 0) {
            if (node.left.balanceFactor < 0) {
              this.rotateLeft(node.left);
              this.rotateRight(node);
            } else {
              this.rotateRight(node);
            }
          }
        }
      }, {
        key: "rotateLeft",
        value: function rotateLeft(pivot) {
          var root = pivot.right;
          pivot.right = root.left;
          if (root.left !== null) {
            root.left.parent = pivot;
          }
          root.parent = pivot.parent;
          if (root.parent === null) {
            this.root = root;
          } else if (pivot.isLeftChild) {
            root.parent.left = root;
          } else {
            root.parent.right = root;
          }
          root.left = pivot;
          pivot.parent = root;
          pivot.balanceFactor = pivot.balanceFactor + 1 - Math.min(root.balanceFactor, 0);
          root.balanceFactor = root.balanceFactor + 1 - Math.max(pivot.balanceFactor, 0);
        }
      }, {
        key: "rotateRight",
        value: function rotateRight(pivot) {
          var root = pivot.left;
          pivot.left = root.right;
          if (root.right !== null) {
            root.right.parent = pivot;
          }
          root.parent = pivot.parent;
          if (root.parent === null) {
            this.root = root;
          } else if (pivot.isLeftChild) {
            root.parent.left = root;
          } else {
            root.parent.right = root;
          }
          root.right = pivot;
          pivot.parent = root;
          pivot.balanceFactor = pivot.balanceFactor - 1 - Math.min(root.balanceFactor, 0);
          root.balanceFactor = root.balanceFactor - 1 - Math.max(pivot.balanceFactor, 0);
        }
      }, {
        key: Symbol.iterator,
        value: _regeneratorRuntime__default["default"].mark(function value() {
          var _iterator, _step, iter;
          return _regeneratorRuntime__default["default"].wrap(function value$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _iterator = _createForOfIteratorHelper$1(this.getIterator());
                  _context.prev = 1;
                  _iterator.s();
                case 3:
                  if ((_step = _iterator.n()).done) {
                    _context.next = 9;
                    break;
                  }
                  iter = _step.value;
                  _context.next = 7;
                  return iter;
                case 7:
                  _context.next = 3;
                  break;
                case 9:
                  _context.next = 14;
                  break;
                case 11:
                  _context.prev = 11;
                  _context.t0 = _context["catch"](1);
                  _iterator.e(_context.t0);
                case 14:
                  _context.prev = 14;
                  _iterator.f();
                  return _context.finish(14);
                case 17:
                case "end":
                  return _context.stop();
              }
            }
          }, value, this, [[1, 11, 14, 17]]);
        })
      }, {
        key: "getIterator",
        value: _regeneratorRuntime__default["default"].mark(function getIterator() {
          var key, currentNode, fromleft, _args2 = arguments;
          return _regeneratorRuntime__default["default"].wrap(function getIterator$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  key = _args2.length > 0 && _args2[0] !== void 0 ? _args2[0] : null;
                  currentNode = this.root;
                case 2:
                  if (!currentNode) {
                    _context2.next = 8;
                    break;
                  }
                  if (!(this.isEqual(key, currentNode.key) || key === null && !currentNode.left)) {
                    _context2.next = 5;
                    break;
                  }
                  return _context2.abrupt("break", 8);
                case 5:
                  if (this.isLessThan(key, currentNode.key) || key === null) {
                    currentNode = currentNode.left;
                  } else {
                    currentNode = currentNode.right;
                  }
                  _context2.next = 2;
                  break;
                case 8:
                  if (currentNode) {
                    _context2.next = 10;
                    break;
                  }
                  return _context2.abrupt("return", null);
                case 10:
                  fromleft = true;
                case 11:
                  if (!fromleft) {
                    _context2.next = 29;
                    break;
                  }
                  _context2.next = 14;
                  return [currentNode.key, currentNode.value];
                case 14:
                  fromleft = false;
                  if (!currentNode.right) {
                    _context2.next = 21;
                    break;
                  }
                  currentNode = currentNode.right;
                  while (currentNode.left) {
                    currentNode = currentNode.left;
                  }
                  fromleft = true;
                  _context2.next = 27;
                  break;
                case 21:
                  if (!currentNode.parent) {
                    _context2.next = 26;
                    break;
                  }
                  fromleft = currentNode.parent.left === currentNode;
                  currentNode = currentNode.parent;
                  _context2.next = 27;
                  break;
                case 26:
                  return _context2.abrupt("break", 37);
                case 27:
                  _context2.next = 35;
                  break;
                case 29:
                  if (!currentNode.parent) {
                    _context2.next = 34;
                    break;
                  }
                  fromleft = currentNode.parent.left === currentNode;
                  currentNode = currentNode.parent;
                  _context2.next = 35;
                  break;
                case 34:
                  return _context2.abrupt("break", 37);
                case 35:
                  _context2.next = 11;
                  break;
                case 37:
                  return _context2.abrupt("return", null);
                case 38:
                case "end":
                  return _context2.stop();
              }
            }
          }, getIterator, this);
        })
      }, {
        key: "getReverseIterator",
        value: _regeneratorRuntime__default["default"].mark(function getReverseIterator() {
          var key, currentNode, fromright, _args3 = arguments;
          return _regeneratorRuntime__default["default"].wrap(function getReverseIterator$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  key = _args3.length > 0 && _args3[0] !== void 0 ? _args3[0] : null;
                  currentNode = this.root;
                case 2:
                  if (!currentNode) {
                    _context3.next = 8;
                    break;
                  }
                  if (!(this.isEqual(key, currentNode.key) || key === null && !currentNode.right)) {
                    _context3.next = 5;
                    break;
                  }
                  return _context3.abrupt("break", 8);
                case 5:
                  if (!this.isLessThan(key, currentNode.key) || key === null) {
                    currentNode = currentNode.right;
                  } else {
                    currentNode = currentNode.left;
                  }
                  _context3.next = 2;
                  break;
                case 8:
                  if (currentNode) {
                    _context3.next = 10;
                    break;
                  }
                  return _context3.abrupt("return", null);
                case 10:
                  fromright = true;
                case 11:
                  if (!fromright) {
                    _context3.next = 29;
                    break;
                  }
                  _context3.next = 14;
                  return [currentNode.key, currentNode.value];
                case 14:
                  fromright = false;
                  if (!currentNode.left) {
                    _context3.next = 21;
                    break;
                  }
                  currentNode = currentNode.left;
                  while (currentNode.right) {
                    currentNode = currentNode.right;
                  }
                  fromright = true;
                  _context3.next = 27;
                  break;
                case 21:
                  if (!currentNode.parent) {
                    _context3.next = 26;
                    break;
                  }
                  fromright = currentNode.parent.right === currentNode;
                  currentNode = currentNode.parent;
                  _context3.next = 27;
                  break;
                case 26:
                  return _context3.abrupt("break", 37);
                case 27:
                  _context3.next = 35;
                  break;
                case 29:
                  if (!currentNode.parent) {
                    _context3.next = 34;
                    break;
                  }
                  fromright = currentNode.parent.right === currentNode;
                  currentNode = currentNode.parent;
                  _context3.next = 35;
                  break;
                case 34:
                  return _context3.abrupt("break", 37);
                case 35:
                  _context3.next = 11;
                  break;
                case 37:
                  return _context3.abrupt("return", null);
                case 38:
                case "end":
                  return _context3.stop();
              }
            }
          }, getReverseIterator, this);
        })
      }]);
      return TreeMap2;
    }();
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var Entry = function() {
      function Entry2(value, revision) {
        _classCallCheck__default["default"](this, Entry2);
        this.value = value;
        this.revision = revision || 0;
      }
      _createClass__default["default"](Entry2, [{
        key: "isValid",
        get: function get() {
          return true;
        }
      }]);
      return Entry2;
    }();
    var Tombstone = function() {
      function Tombstone2(revision) {
        _classCallCheck__default["default"](this, Tombstone2);
        this.revision = revision;
      }
      _createClass__default["default"](Tombstone2, [{
        key: "isValid",
        get: function get() {
          return false;
        }
      }]);
      return Tombstone2;
    }();
    var Cache = function() {
      function Cache2() {
        _classCallCheck__default["default"](this, Cache2);
        this.items = new TreeMap();
      }
      _createClass__default["default"](Cache2, [{
        key: "store",
        value: function store(key, value, revision) {
          var entry = this.items.get(key);
          if (entry && entry.revision > revision) {
            if (entry.isValid) {
              return entry.value;
            }
            return null;
          }
          this.items.set(key, new Entry(value, revision));
          return value;
        }
      }, {
        key: "delete",
        value: function _delete(key, revision) {
          var force = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          var curr = this.items.get(key);
          if (!curr || curr.revision < revision || curr && force === true) {
            this.items.set(key, new Tombstone(revision));
          }
        }
      }, {
        key: "isKnown",
        value: function isKnown(key, revision) {
          var curr = this.items.get(key);
          return curr && curr.revision >= revision;
        }
      }, {
        key: "get",
        value: function get(key) {
          var entry = this.items.get(key);
          if (entry && entry.isValid) {
            return entry.value;
          }
          return null;
        }
      }, {
        key: "has",
        value: function has(key) {
          var entry = this.items.get(key);
          return entry && entry.isValid;
        }
      }, {
        key: "forEach",
        value: function forEach(callbackfn) {
          if (this.items) {
            var _iterator = _createForOfIteratorHelper(this.items), _step;
            try {
              for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                var _step$value = _slicedToArray__default["default"](_step.value, 2), key = _step$value[0], entry = _step$value[1];
                if (entry.isValid) {
                  callbackfn(key, entry.value);
                }
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
          }
        }
      }]);
      return Cache2;
    }();
    function _createSuper$4(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$4();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$4() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var SyncListImpl = function(_SyncEntity) {
      _inherits__default["default"](SyncListImpl2, _SyncEntity);
      var _super = _createSuper$4(SyncListImpl2);
      function SyncListImpl2(services, descriptor, removalHandler) {
        var _this;
        _classCallCheck__default["default"](this, SyncListImpl2);
        _this = _super.call(this, services, removalHandler);
        var updateRequestReducer = function updateRequestReducer2(acc, input) {
          return typeof input.ttl === "number" ? {
            ttl: input.ttl
          } : acc;
        };
        _this.updateMergingQueue = new NamespacedMergingQueue(updateRequestReducer);
        _this.cache = new Cache();
        _this.descriptor = descriptor;
        _this.descriptor.date_updated = new Date(_this.descriptor.date_updated);
        return _this;
      }
      _createClass__default["default"](SyncListImpl2, [{
        key: "uri",
        get: function get() {
          return this.descriptor.url;
        }
      }, {
        key: "revision",
        get: function get() {
          return this.descriptor.revision;
        }
      }, {
        key: "lastEventId",
        get: function get() {
          return this.descriptor.last_event_id;
        }
      }, {
        key: "links",
        get: function get() {
          return this.descriptor.links;
        }
      }, {
        key: "dateExpires",
        get: function get() {
          return this.descriptor.date_expires;
        }
      }, {
        key: "type",
        get: function get() {
          return "list";
        }
        // below properties are specific to Insights only
      }, {
        key: "indexName",
        get: function get() {
          return void 0;
        }
      }, {
        key: "queryString",
        get: function get() {
          return void 0;
        }
        // public props, documented along with class description
      }, {
        key: "sid",
        get: function get() {
          return this.descriptor.sid;
        }
      }, {
        key: "uniqueName",
        get: function get() {
          return this.descriptor.unique_name || null;
        }
      }, {
        key: "dateUpdated",
        get: function get() {
          return this.descriptor.date_updated;
        }
      }, {
        key: "_addOrUpdateItemOnServer",
        value: function() {
          var _addOrUpdateItemOnServer2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee(url, data, ifMatch, ttl) {
            var requestBody, response;
            return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    requestBody = {
                      data
                    };
                    if (ttl !== void 0) {
                      requestBody.ttl = ttl;
                    }
                    _context.next = 4;
                    return this.services.network.post(url, requestBody, ifMatch);
                  case 4:
                    response = _context.sent;
                    response.body.data = data;
                    response.body.date_updated = new Date(response.body.date_updated);
                    return _context.abrupt("return", response.body);
                  case 8:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function _addOrUpdateItemOnServer(_x, _x2, _x3, _x4) {
            return _addOrUpdateItemOnServer2.apply(this, arguments);
          }
          return _addOrUpdateItemOnServer;
        }()
      }, {
        key: "push",
        value: function() {
          var _push = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee2(value, itemMetadata) {
            var ttl, item, index;
            return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    ttl = (itemMetadata || {}).ttl;
                    _context2.next = 3;
                    return this._addOrUpdateItemOnServer(this.links.items, value, void 0, ttl);
                  case 3:
                    item = _context2.sent;
                    index = Number(item.index);
                    this._handleItemMutated(index, item.url, item.last_event_id, item.revision, value, item.date_updated, item.date_expires, true, false);
                    return _context2.abrupt("return", this.cache.get(index));
                  case 7:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function push(_x5, _x6) {
            return _push.apply(this, arguments);
          }
          return push;
        }()
      }, {
        key: "set",
        value: function() {
          var _set = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee3(index, value, itemMetadataUpdates) {
            var _this2 = this;
            var input;
            return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    input = itemMetadataUpdates || {};
                    return _context3.abrupt("return", this.updateMergingQueue.squashAndAdd(index, input, function(input2) {
                      return _this2._updateItemUnconditionally(index, value, input2.ttl);
                    }));
                  case 2:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));
          function set(_x7, _x8, _x9) {
            return _set.apply(this, arguments);
          }
          return set;
        }()
      }, {
        key: "_updateItemUnconditionally",
        value: function() {
          var _updateItemUnconditionally2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee4(index, data, ttl) {
            var existingItem, itemDescriptor;
            return _regeneratorRuntime__default["default"].wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    _context4.next = 2;
                    return this.get(index);
                  case 2:
                    existingItem = _context4.sent;
                    _context4.next = 5;
                    return this._addOrUpdateItemOnServer(existingItem.uri, data, void 0, ttl);
                  case 5:
                    itemDescriptor = _context4.sent;
                    this._handleItemMutated(index, itemDescriptor.url, itemDescriptor.last_event_id, itemDescriptor.revision, itemDescriptor.data, itemDescriptor.date_updated, itemDescriptor.date_expires, false, false);
                    return _context4.abrupt("return", this.cache.get(index));
                  case 8:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));
          function _updateItemUnconditionally(_x10, _x11, _x12) {
            return _updateItemUnconditionally2.apply(this, arguments);
          }
          return _updateItemUnconditionally;
        }()
      }, {
        key: "_updateItemWithIfMatch",
        value: function() {
          var _updateItemWithIfMatch2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee5(index, mutatorFunction, ttl) {
            var existingItem, data, ifMatch, itemDescriptor;
            return _regeneratorRuntime__default["default"].wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    _context5.next = 2;
                    return this.get(index);
                  case 2:
                    existingItem = _context5.sent;
                    data = mutatorFunction(deepClone(existingItem.data));
                    if (!data) {
                      _context5.next = 25;
                      break;
                    }
                    ifMatch = existingItem.revision;
                    _context5.prev = 6;
                    _context5.next = 9;
                    return this._addOrUpdateItemOnServer(existingItem.uri, data, ifMatch, ttl);
                  case 9:
                    itemDescriptor = _context5.sent;
                    this._handleItemMutated(index, itemDescriptor.url, itemDescriptor.last_event_id, itemDescriptor.revision, itemDescriptor.data, itemDescriptor.date_updated, itemDescriptor.date_expires, false, false);
                    return _context5.abrupt("return", this.cache.get(index));
                  case 14:
                    _context5.prev = 14;
                    _context5.t0 = _context5["catch"](6);
                    if (!(_context5.t0.status === 412)) {
                      _context5.next = 22;
                      break;
                    }
                    _context5.next = 19;
                    return this._getItemFromServer(index);
                  case 19:
                    return _context5.abrupt("return", this._updateItemWithIfMatch(index, mutatorFunction, ttl));
                  case 22:
                    throw _context5.t0;
                  case 23:
                    _context5.next = 26;
                    break;
                  case 25:
                    return _context5.abrupt("return", existingItem);
                  case 26:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this, [[6, 14]]);
          }));
          function _updateItemWithIfMatch(_x13, _x14, _x15) {
            return _updateItemWithIfMatch2.apply(this, arguments);
          }
          return _updateItemWithIfMatch;
        }()
      }, {
        key: "mutate",
        value: function() {
          var _mutate = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee6(index, mutator, itemMetadataUpdates) {
            var _this3 = this;
            var input;
            return _regeneratorRuntime__default["default"].wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    input = itemMetadataUpdates || {};
                    return _context6.abrupt("return", this.updateMergingQueue.add(index, input, function(input2) {
                      return _this3._updateItemWithIfMatch(index, mutator, input2.ttl);
                    }));
                  case 2:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, this);
          }));
          function mutate(_x16, _x17, _x18) {
            return _mutate.apply(this, arguments);
          }
          return mutate;
        }()
      }, {
        key: "update",
        value: function() {
          var _update2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee7(index, obj, itemMetadataUpdates) {
            return _regeneratorRuntime__default["default"].wrap(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    return _context7.abrupt("return", this.mutate(index, function(remote) {
                      return Object.assign(remote, obj);
                    }, itemMetadataUpdates));
                  case 1:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee7, this);
          }));
          function update(_x19, _x20, _x21) {
            return _update2.apply(this, arguments);
          }
          return update;
        }()
      }, {
        key: "remove",
        value: function() {
          var _remove = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee8(index) {
            var item, previousItemData, response;
            return _regeneratorRuntime__default["default"].wrap(function _callee8$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    _context8.next = 2;
                    return this.get(index);
                  case 2:
                    item = _context8.sent;
                    previousItemData = deepClone(item.data);
                    _context8.next = 6;
                    return this.services.network.delete(item.uri);
                  case 6:
                    response = _context8.sent;
                    this._handleItemRemoved(index, response.body.last_event_id, previousItemData, new Date(response.body.date_updated), false);
                  case 8:
                  case "end":
                    return _context8.stop();
                }
              }
            }, _callee8, this);
          }));
          function remove(_x22) {
            return _remove.apply(this, arguments);
          }
          return remove;
        }()
      }, {
        key: "get",
        value: function() {
          var _get2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee9(index) {
            var cachedItem;
            return _regeneratorRuntime__default["default"].wrap(function _callee9$(_context9) {
              while (1) {
                switch (_context9.prev = _context9.next) {
                  case 0:
                    cachedItem = this.cache.get(index);
                    if (!cachedItem) {
                      _context9.next = 5;
                      break;
                    }
                    return _context9.abrupt("return", cachedItem);
                  case 5:
                    return _context9.abrupt("return", this._getItemFromServer(index));
                  case 6:
                  case "end":
                    return _context9.stop();
                }
              }
            }, _callee9, this);
          }));
          function get(_x23) {
            return _get2.apply(this, arguments);
          }
          return get;
        }()
      }, {
        key: "_getItemFromServer",
        value: function() {
          var _getItemFromServer2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee10(index) {
            var result;
            return _regeneratorRuntime__default["default"].wrap(function _callee10$(_context10) {
              while (1) {
                switch (_context10.prev = _context10.next) {
                  case 0:
                    _context10.next = 2;
                    return this.queryItems({
                      index
                    });
                  case 2:
                    result = _context10.sent;
                    if (!(result.items.length < 1)) {
                      _context10.next = 7;
                      break;
                    }
                    throw new SyncError("No item with index ".concat(index, " found"), 404, 54151);
                  case 7:
                    return _context10.abrupt("return", result.items[0]);
                  case 8:
                  case "end":
                    return _context10.stop();
                }
              }
            }, _callee10, this);
          }));
          function _getItemFromServer(_x24) {
            return _getItemFromServer2.apply(this, arguments);
          }
          return _getItemFromServer;
        }()
        /**
         * Query items from the List
         * @private
         */
      }, {
        key: "queryItems",
        value: function() {
          var _queryItems2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee11(arg) {
            var _this4 = this;
            var url, response, items, meta;
            return _regeneratorRuntime__default["default"].wrap(function _callee11$(_context11) {
              while (1) {
                switch (_context11.prev = _context11.next) {
                  case 0:
                    arg = arg || {};
                    url = new UriBuilder(this.links.items).queryParam("From", arg.from).queryParam("PageSize", arg.limit).queryParam("Index", arg.index).queryParam("PageToken", arg.pageToken).queryParam("Order", arg.order).build();
                    _context11.next = 4;
                    return this.services.network.get(url);
                  case 4:
                    response = _context11.sent;
                    items = response.body.items.map(function(el) {
                      el.date_updated = new Date(el.date_updated);
                      var itemInCache = _this4.cache.get(el.index);
                      if (itemInCache) {
                        _this4._handleItemMutated(el.index, el.url, el.last_event_id, el.revision, el.data, el.date_updated, el.date_expires, false, true);
                      } else {
                        _this4.cache.store(Number(el.index), new SyncListItem({
                          index: Number(el.index),
                          uri: el.url,
                          revision: el.revision,
                          lastEventId: el.last_event_id,
                          dateUpdated: el.date_updated,
                          dateExpires: el.date_expires,
                          data: el.data
                        }), el.last_event_id);
                      }
                      return _this4.cache.get(el.index);
                    });
                    meta = response.body.meta;
                    return _context11.abrupt("return", new Paginator(items, function(pageToken) {
                      return _this4.queryItems({
                        pageToken
                      });
                    }, meta.previous_token, meta.next_token));
                  case 8:
                  case "end":
                    return _context11.stop();
                }
              }
            }, _callee11, this);
          }));
          function queryItems2(_x25) {
            return _queryItems2.apply(this, arguments);
          }
          return queryItems2;
        }()
      }, {
        key: "getItems",
        value: function() {
          var _getItems = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee12(args) {
            return _regeneratorRuntime__default["default"].wrap(function _callee12$(_context12) {
              while (1) {
                switch (_context12.prev = _context12.next) {
                  case 0:
                    args = args || {};
                    validatePageSize(args.pageSize);
                    args.limit = args.pageSize || args.limit || 50;
                    args.order = args.order || "asc";
                    return _context12.abrupt("return", this.queryItems(args));
                  case 5:
                  case "end":
                    return _context12.stop();
                }
              }
            }, _callee12, this);
          }));
          function getItems(_x26) {
            return _getItems.apply(this, arguments);
          }
          return getItems;
        }()
        /**
         * @return {Promise<Object>} Context of List
         * @private
         */
      }, {
        key: "getContext",
        value: function() {
          var _getContext = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee13() {
            var response;
            return _regeneratorRuntime__default["default"].wrap(function _callee13$(_context13) {
              while (1) {
                switch (_context13.prev = _context13.next) {
                  case 0:
                    if (this.context) {
                      _context13.next = 5;
                      break;
                    }
                    _context13.next = 3;
                    return this.services.network.get(this.links.context);
                  case 3:
                    response = _context13.sent;
                    this._updateContextIfRequired(response.body.data, response.body.last_event_id);
                  case 5:
                    return _context13.abrupt("return", this.context);
                  case 6:
                  case "end":
                    return _context13.stop();
                }
              }
            }, _callee13, this);
          }));
          function getContext() {
            return _getContext.apply(this, arguments);
          }
          return getContext;
        }()
      }, {
        key: "setTtl",
        value: function() {
          var _setTtl = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee14(ttl) {
            var requestBody, response;
            return _regeneratorRuntime__default["default"].wrap(function _callee14$(_context14) {
              while (1) {
                switch (_context14.prev = _context14.next) {
                  case 0:
                    _context14.prev = 0;
                    requestBody = {
                      ttl
                    };
                    _context14.next = 4;
                    return this.services.network.post(this.uri, requestBody);
                  case 4:
                    response = _context14.sent;
                    this.descriptor.date_expires = response.body.date_expires;
                    _context14.next = 12;
                    break;
                  case 8:
                    _context14.prev = 8;
                    _context14.t0 = _context14["catch"](0);
                    if (_context14.t0.status === 404) {
                      this.onRemoved(false);
                    }
                    throw _context14.t0;
                  case 12:
                  case "end":
                    return _context14.stop();
                }
              }
            }, _callee14, this, [[0, 8]]);
          }));
          function setTtl(_x27) {
            return _setTtl.apply(this, arguments);
          }
          return setTtl;
        }()
      }, {
        key: "setItemTtl",
        value: function() {
          var _setItemTtl = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee15(index, ttl) {
            var existingItem, requestBody, response;
            return _regeneratorRuntime__default["default"].wrap(function _callee15$(_context15) {
              while (1) {
                switch (_context15.prev = _context15.next) {
                  case 0:
                    _context15.next = 2;
                    return this.get(index);
                  case 2:
                    existingItem = _context15.sent;
                    requestBody = {
                      ttl
                    };
                    _context15.next = 6;
                    return this.services.network.post(existingItem.uri, requestBody);
                  case 6:
                    response = _context15.sent;
                    existingItem.updateDateExpires(response.body.date_expires);
                  case 8:
                  case "end":
                    return _context15.stop();
                }
              }
            }, _callee15, this);
          }));
          function setItemTtl(_x28, _x29) {
            return _setItemTtl.apply(this, arguments);
          }
          return setItemTtl;
        }()
      }, {
        key: "removeList",
        value: function() {
          var _removeList = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee16() {
            return _regeneratorRuntime__default["default"].wrap(function _callee16$(_context16) {
              while (1) {
                switch (_context16.prev = _context16.next) {
                  case 0:
                    _context16.next = 2;
                    return this.services.network.delete(this.uri);
                  case 2:
                    this.onRemoved(true);
                  case 3:
                  case "end":
                    return _context16.stop();
                }
              }
            }, _callee16, this);
          }));
          function removeList() {
            return _removeList.apply(this, arguments);
          }
          return removeList;
        }()
      }, {
        key: "onRemoved",
        value: function onRemoved(locally) {
          this._unsubscribe();
          this.removalHandler(this.type, this.sid, this.uniqueName);
          this.broadcastEventToListeners("removed", {
            isLocal: locally
          });
        }
      }, {
        key: "shouldIgnoreEvent",
        value: function shouldIgnoreEvent(key, eventId) {
          return this.cache.isKnown(key, eventId);
        }
        /**
         * Handle update, which came from the server.
         * @private
         */
      }, {
        key: "_update",
        value: function _update(update, isStrictlyOrdered) {
          var itemIndex = Number(update.item_index);
          update.date_created = new Date(update.date_created);
          switch (update.type) {
            case "list_item_added":
            case "list_item_updated":
              {
                this._handleItemMutated(
                  itemIndex,
                  update.item_url,
                  update.id,
                  update.item_revision,
                  update.item_data,
                  update.date_created,
                  void 0,
                  // orchestration does not include date_expires  -- @todo  it does now?
                  update.type === "list_item_added",
                  true
                );
              }
              break;
            case "list_item_removed":
              {
                this._handleItemRemoved(itemIndex, update.id, update.item_data, update.date_created, true);
              }
              break;
            case "list_context_updated":
              {
                this._handleContextUpdate(update.context_data, update.id, update.date_created);
              }
              break;
            case "list_removed":
              {
                this.onRemoved(false);
              }
              break;
          }
          if (isStrictlyOrdered) {
            this._advanceLastEventId(update.id, update.list_revision);
          }
        }
      }, {
        key: "_advanceLastEventId",
        value: function _advanceLastEventId(eventId, revision) {
          if (this.lastEventId < eventId) {
            this.descriptor.last_event_id = eventId;
            if (revision) {
              this.descriptor.revision = revision;
            }
          }
        }
      }, {
        key: "_updateRootDateUpdated",
        value: function _updateRootDateUpdated(dateUpdated) {
          if (!this.descriptor.date_updated || dateUpdated.getTime() > this.descriptor.date_updated.getTime()) {
            this.descriptor.date_updated = dateUpdated;
            this.services.storage.update(this.type, this.sid, this.uniqueName, {
              date_updated: dateUpdated
            });
          }
        }
      }, {
        key: "_handleItemMutated",
        value: function _handleItemMutated(index, uri, lastEventId, revision, data, dateUpdated, dateExpires, added, remote) {
          if (this.shouldIgnoreEvent(index, lastEventId)) {
            log$1.trace("Item ".concat(index, " update skipped, current: ").concat(this.lastEventId, ", remote: ").concat(lastEventId));
            return;
          }
          this._updateRootDateUpdated(dateUpdated);
          var item = this.cache.get(index);
          if (!item) {
            var newItem = new SyncListItem({
              index,
              uri,
              lastEventId,
              revision,
              data,
              dateUpdated,
              dateExpires
            });
            this.cache.store(index, newItem, lastEventId);
            this.emitItemMutationEvent(newItem, remote, added);
            return;
          }
          var previousItemData = deepClone(item.data);
          item.update(lastEventId, revision, data, dateUpdated);
          this.cache.store(index, item, lastEventId);
          if (dateExpires !== void 0) {
            item.updateDateExpires(dateExpires);
          }
          this.emitItemMutationEvent(item, remote, false, previousItemData);
        }
        /**
         * @private
         */
      }, {
        key: "emitItemMutationEvent",
        value: function emitItemMutationEvent(item, remote, added) {
          var previousItemData = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
          var eventName = added ? "itemAdded" : "itemUpdated";
          var args = {
            item,
            isLocal: !remote
          };
          if (!added) {
            args.previousItemData = previousItemData;
          }
          this.broadcastEventToListeners(eventName, args);
        }
        /**
         * @private
         */
      }, {
        key: "_handleItemRemoved",
        value: function _handleItemRemoved(index, eventId, oldData, dateUpdated, remote) {
          this._updateRootDateUpdated(dateUpdated);
          this.cache.delete(index, eventId);
          this.broadcastEventToListeners("itemRemoved", {
            index,
            isLocal: !remote,
            previousItemData: oldData
          });
        }
        /**
         * @private
         */
      }, {
        key: "_handleContextUpdate",
        value: function _handleContextUpdate(data, eventId, dateUpdated) {
          this._updateRootDateUpdated(dateUpdated);
          if (this._updateContextIfRequired(data, eventId)) {
            this.broadcastEventToListeners("contextUpdated", {
              context: data,
              isLocal: false
            });
          }
        }
        /**
         * @private
         */
      }, {
        key: "_updateContextIfRequired",
        value: function _updateContextIfRequired(data, eventId) {
          if (!this.contextEventId || eventId > this.contextEventId) {
            this.context = data;
            this.contextEventId = eventId;
            return true;
          } else {
            log$1.trace("Context update skipped, current:", this.lastEventId, ", remote:", eventId);
            return false;
          }
        }
      }], [{
        key: "type",
        get: function get() {
          return "list";
        }
      }]);
      return SyncListImpl2;
    }(SyncEntity);
    var SyncList = function(_Closeable) {
      _inherits__default["default"](SyncList2, _Closeable);
      var _super2 = _createSuper$4(SyncList2);
      function SyncList2(syncListImpl) {
        var _this5;
        _classCallCheck__default["default"](this, SyncList2);
        _this5 = _super2.call(this);
        _this5.syncListImpl = syncListImpl;
        _this5.syncListImpl.attach(_assertThisInitialized__default["default"](_this5));
        return _this5;
      }
      _createClass__default["default"](SyncList2, [{
        key: "uri",
        get: (
          // private props
          function get() {
            return this.syncListImpl.uri;
          }
        )
      }, {
        key: "revision",
        get: function get() {
          return this.syncListImpl.revision;
        }
      }, {
        key: "lastEventId",
        get: function get() {
          return this.syncListImpl.lastEventId;
        }
      }, {
        key: "links",
        get: function get() {
          return this.syncListImpl.links;
        }
      }, {
        key: "dateExpires",
        get: function get() {
          return this.syncListImpl.dateExpires;
        }
      }, {
        key: "type",
        get: function get() {
          return SyncListImpl.type;
        }
        /**
         * Unique ID of the list, immutable identifier assigned by the system.
         */
      }, {
        key: "sid",
        get: function get() {
          return this.syncListImpl.sid;
        }
        /**
         * Unique name of the list, immutable identifier that can be assigned to the list during creation.
         */
      }, {
        key: "uniqueName",
        get: function get() {
          return this.syncListImpl.uniqueName;
        }
        /**
         * Date when the list was last updated, given in UTC ISO 8601 format (e.g., '2018-04-26T15:23:19.732Z').
         */
      }, {
        key: "dateUpdated",
        get: function get() {
          return this.syncListImpl.dateUpdated;
        }
      }, {
        key: "push",
        value: (
          /**
           * Add a new item to the list.
           * @param data Data to be added.
           * @param itemMetadata Item metadata.
           * @return The newly added item.
           * @example
           * ```typescript
           * list.push({ name: 'John Smith' }, { ttl: 86400 })
           *   .then((item) => {
           *     console.log(`List Item push() successful, item index: ${item.index}, data:`, item.data)
           *   })
           *   .catch((error) => {
           *     console.error('List Item push() failed', error);
           *   });
           * ```
           */
          function() {
            var _push2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee17(data, itemMetadata) {
              return _regeneratorRuntime__default["default"].wrap(function _callee17$(_context17) {
                while (1) {
                  switch (_context17.prev = _context17.next) {
                    case 0:
                      this.ensureNotClosed();
                      return _context17.abrupt("return", this.syncListImpl.push(data, itemMetadata));
                    case 2:
                    case "end":
                      return _context17.stop();
                  }
                }
              }, _callee17, this);
            }));
            function push(_x30, _x31) {
              return _push2.apply(this, arguments);
            }
            return push;
          }()
        )
        /**
         * Assign new data to an existing item, given its index.
         * @param index Index of the item to be updated.
         * @param value New data to be assigned to an item.
         * @param itemMetadataUpdates New item metadata.
         * @return A promise with the updated item containing latest known data.
         * The promise will be rejected if the item does not exist.
         * @example
         * ```typescript
         * list.set(42, { name: 'John Smith' }, { ttl: 86400 })
         *   .then((item) => {
         *     console.log('List Item set() successful, item data:', item.data)
         *   })
         *   .catch((error) => {
         *     console.error('List Item set() failed', error);
         *   });
         * ```
         */
      }, {
        key: "set",
        value: function() {
          var _set2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee18(index, value, itemMetadataUpdates) {
            return _regeneratorRuntime__default["default"].wrap(function _callee18$(_context18) {
              while (1) {
                switch (_context18.prev = _context18.next) {
                  case 0:
                    this.ensureNotClosed();
                    return _context18.abrupt("return", this.syncListImpl.set(index, value, itemMetadataUpdates));
                  case 2:
                  case "end":
                    return _context18.stop();
                }
              }
            }, _callee18, this);
          }));
          function set(_x32, _x33, _x34) {
            return _set2.apply(this, arguments);
          }
          return set;
        }()
        /**
         * Modify an existing item by applying a mutation function to it.
         * @param index Index of the item to be changed.
         * @param mutator A function that outputs a new data based on the existing data.
         * @param itemMetadataUpdates New item metadata.
         * @return Resolves with the most recent item state, the output of a successful
         * mutation or a state that prompted graceful cancellation (mutator returned `null`). This promise
         * will be rejected if the indicated item does not already exist.
         * @example
         * ```typescript
         * const mutatorFunction = (currentValue) => {
         *     currentValue.viewCount = (currentValue.viewCount || 0) + 1;
         *     return currentValue;
         * };
         * list.mutate(42, mutatorFunction, { ttl: 86400 })
         *   .then((item) => {
         *     console.log('List Item mutate() successful, new data:', item.data)
         *   })
         *   .catch((error) => {
         *     console.error('List Item mutate() failed', error);
         *   });
         * ```
         */
      }, {
        key: "mutate",
        value: function() {
          var _mutate2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee19(index, mutator, itemMetadataUpdates) {
            return _regeneratorRuntime__default["default"].wrap(function _callee19$(_context19) {
              while (1) {
                switch (_context19.prev = _context19.next) {
                  case 0:
                    this.ensureNotClosed();
                    return _context19.abrupt("return", this.syncListImpl.mutate(index, mutator, itemMetadataUpdates));
                  case 2:
                  case "end":
                    return _context19.stop();
                }
              }
            }, _callee19, this);
          }));
          function mutate(_x35, _x36, _x37) {
            return _mutate2.apply(this, arguments);
          }
          return mutate;
        }()
        /**
         * Modify an existing item by appending new fields (or overwriting existing ones) with the values from the object.
         * This is equivalent to
         * ```typescript
         * list.mutate(42, (currentValue) => Object.assign(currentValue, obj));
         * ```
         * @param index Index of an item to be changed.
         * @param obj Set of fields to update.
         * @param itemMetadataUpdates New item metadata.
         * @return A promise with a modified item containing latest known data.
         * The promise will be rejected if the item was not found.
         * @example
         * ```typescript
         * // Say, the List Item (index: 42) data is `{ name: 'John Smith' }`
         * list.update(42, { age: 34 }, { ttl: 86400 })
         *   .then((item) => {
         *     // Now the List Item data is `{ name: 'John Smith', age: 34 }`
         *     console.log('List Item update() successful, new data:', item.data);
         *   })
         *   .catch((error) => {
         *     console.error('List Item update() failed', error);
         *   });
         * ```
         */
      }, {
        key: "update",
        value: function() {
          var _update3 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee20(index, obj, itemMetadataUpdates) {
            return _regeneratorRuntime__default["default"].wrap(function _callee20$(_context20) {
              while (1) {
                switch (_context20.prev = _context20.next) {
                  case 0:
                    this.ensureNotClosed();
                    return _context20.abrupt("return", this.syncListImpl.update(index, obj, itemMetadataUpdates));
                  case 2:
                  case "end":
                    return _context20.stop();
                }
              }
            }, _callee20, this);
          }));
          function update(_x38, _x39, _x40) {
            return _update3.apply(this, arguments);
          }
          return update;
        }()
        /**
         * Delete an item given its index.
         * @param index Index of the item to be removed.
         * @return A promise to remove the item.
         * The promise will be rejected if the item was not found.
         * @example
         * ```typescript
         * list.remove(42)
         *   .then(() => {
         *     console.log('List Item remove() successful');
         *   })
         *   .catch((error) => {
         *     console.error('List Item remove() failed', error);
         *   });
         * ```
         */
      }, {
        key: "remove",
        value: function() {
          var _remove2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee21(index) {
            return _regeneratorRuntime__default["default"].wrap(function _callee21$(_context21) {
              while (1) {
                switch (_context21.prev = _context21.next) {
                  case 0:
                    this.ensureNotClosed();
                    return _context21.abrupt("return", this.syncListImpl.remove(index));
                  case 2:
                  case "end":
                    return _context21.stop();
                }
              }
            }, _callee21, this);
          }));
          function remove(_x41) {
            return _remove2.apply(this, arguments);
          }
          return remove;
        }()
        /**
         * Retrieve an item by List index.
         * @param index Item index in the list.
         * @return A promise with the item containing latest known data.
         * The promise will be rejected if the item was not found.
         * @example
         * ```typescript
         * list.get(42)
         *   .then((item) => {
         *     console.log('List Item get() successful, item data:', item.data)
         *   })
         *   .catch((error) => {
         *     console.error('List Item get() failed', error);
         *   });
         * ```
         */
      }, {
        key: "get",
        value: function() {
          var _get3 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee22(index) {
            return _regeneratorRuntime__default["default"].wrap(function _callee22$(_context22) {
              while (1) {
                switch (_context22.prev = _context22.next) {
                  case 0:
                    this.ensureNotClosed();
                    return _context22.abrupt("return", this.syncListImpl.get(index));
                  case 2:
                  case "end":
                    return _context22.stop();
                }
              }
            }, _callee22, this);
          }));
          function get(_x42) {
            return _get3.apply(this, arguments);
          }
          return get;
        }()
        /**
         * Retrieve a list context
         * @return A promise with the list's context
         * @internal
         */
      }, {
        key: "getContext",
        value: function() {
          var _getContext2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee23() {
            return _regeneratorRuntime__default["default"].wrap(function _callee23$(_context23) {
              while (1) {
                switch (_context23.prev = _context23.next) {
                  case 0:
                    this.ensureNotClosed();
                    return _context23.abrupt("return", this.syncListImpl.getContext());
                  case 2:
                  case "end":
                    return _context23.stop();
                }
              }
            }, _callee23, this);
          }));
          function getContext() {
            return _getContext2.apply(this, arguments);
          }
          return getContext;
        }()
        /**
         * Query a list of items from collection.
         * Information about the query limits can be found {@link https://www.twilio.com/docs/sync/limits|here}.
         * @param queryOptions Query options.
         * @example
         * ```typescript
         * const pageHandler = (paginator) => {
         *   paginator.items.forEach((item) => {
         *     console.log(`Item ${item.index}:`, item.data);
         *   });
         *   return paginator.hasNextPage
         *     ? paginator.nextPage().then(pageHandler)
         *     : null;
         * };
         * list.getItems({ from: 0, order: 'asc' })
         *   .then(pageHandler)
         *   .catch((error) => {
         *     console.error('List getItems() failed', error);
         *   });
         * ```
         */
      }, {
        key: "getItems",
        value: function() {
          var _getItems2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee24(queryOptions) {
            return _regeneratorRuntime__default["default"].wrap(function _callee24$(_context24) {
              while (1) {
                switch (_context24.prev = _context24.next) {
                  case 0:
                    this.ensureNotClosed();
                    return _context24.abrupt("return", this.syncListImpl.getItems(queryOptions));
                  case 2:
                  case "end":
                    return _context24.stop();
                }
              }
            }, _callee24, this);
          }));
          function getItems(_x43) {
            return _getItems2.apply(this, arguments);
          }
          return getItems;
        }()
        /**
         * Update the time-to-live of the list.
         * @param ttl Specifies the TTL in seconds after which the list is subject to automatic deletion. The value 0 means infinity.
         * @return A promise that resolves after the TTL update was successful.
         * @example
         * ```typescript
         * list.setTtl(3600)
         *   .then(() => {
         *     console.log('List setTtl() successful');
         *   })
         *   .catch((error) => {
         *     console.error('List setTtl() failed', error);
         *   });
         * ```
         */
      }, {
        key: "setTtl",
        value: function() {
          var _setTtl2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee25(ttl) {
            return _regeneratorRuntime__default["default"].wrap(function _callee25$(_context25) {
              while (1) {
                switch (_context25.prev = _context25.next) {
                  case 0:
                    this.ensureNotClosed();
                    return _context25.abrupt("return", this.syncListImpl.setTtl(ttl));
                  case 2:
                  case "end":
                    return _context25.stop();
                }
              }
            }, _callee25, this);
          }));
          function setTtl(_x44) {
            return _setTtl2.apply(this, arguments);
          }
          return setTtl;
        }()
        /**
         * Update the time-to-live of a list item.
         * @param index Item index.
         * @param ttl Specifies the TTL in seconds after which the list item is subject to automatic deletion. The value 0 means infinity.
         * @return A promise that resolves after the TTL update was successful.
         * @example
         * ```typescript
         * list.setItemTtl(42, 86400)
         *   .then(() => {
         *     console.log('List setItemTtl() successful');
         *   })
         *   .catch((error) => {
         *     console.error('List setItemTtl() failed', error);
         *   });
         * ```
         */
      }, {
        key: "setItemTtl",
        value: function() {
          var _setItemTtl2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee26(index, ttl) {
            return _regeneratorRuntime__default["default"].wrap(function _callee26$(_context26) {
              while (1) {
                switch (_context26.prev = _context26.next) {
                  case 0:
                    this.ensureNotClosed();
                    return _context26.abrupt("return", this.syncListImpl.setItemTtl(index, ttl));
                  case 2:
                  case "end":
                    return _context26.stop();
                }
              }
            }, _callee26, this);
          }));
          function setItemTtl(_x45, _x46) {
            return _setItemTtl2.apply(this, arguments);
          }
          return setItemTtl;
        }()
        /**
         * Delete this list. It will be impossible to restore it.
         * @return A promise that resolves when the list has been deleted.
         * @example
         * list.removeList()
         *   .then(() => {
         *     console.log('List removeList() successful');
         *   })
         *   .catch((error) => {
         *     console.error('List removeList() failed', error);
         *   });
         */
      }, {
        key: "removeList",
        value: function() {
          var _removeList2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee27() {
            return _regeneratorRuntime__default["default"].wrap(function _callee27$(_context27) {
              while (1) {
                switch (_context27.prev = _context27.next) {
                  case 0:
                    this.ensureNotClosed();
                    return _context27.abrupt("return", this.syncListImpl.removeList());
                  case 2:
                  case "end":
                    return _context27.stop();
                }
              }
            }, _callee27, this);
          }));
          function removeList() {
            return _removeList2.apply(this, arguments);
          }
          return removeList;
        }()
        /**
         * Conclude work with the list instance and remove all event listeners attached to it.
         * Any subsequent operation on this object will be rejected with error.
         * Other local copies of this list will continue operating and receiving events normally.
         * @example
         * ```typescript
         * list.close();
         * ```
         */
      }, {
        key: "close",
        value: function close() {
          _get__default["default"](_getPrototypeOf__default["default"](SyncList2.prototype), "close", this).call(this);
          this.syncListImpl.detach(this.listenerUuid);
        }
      }], [{
        key: "type",
        get: function get() {
          return SyncListImpl.type;
        }
      }]);
      return SyncList2;
    }(Closeable);
    _defineProperty__default["default"](SyncList, "itemAdded", "itemAdded");
    _defineProperty__default["default"](SyncList, "itemUpdated", "itemUpdated");
    _defineProperty__default["default"](SyncList, "itemRemoved", "itemRemoved");
    _defineProperty__default["default"](SyncList, "removed", "removed");
    __decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.pureObject, ["undefined", declarativeTypeValidator.objectSchema("item metadata", {
      ttl: [declarativeTypeValidator.nonNegativeInteger, "undefined"]
    })]), __metadata("design:type", Function), __metadata("design:paramtypes", [Object, Object]), __metadata("design:returntype", Promise)], SyncList.prototype, "push", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger, declarativeTypeValidator.pureObject, ["undefined", declarativeTypeValidator.objectSchema("item metadata", {
      ttl: [declarativeTypeValidator.nonNegativeInteger, "undefined"]
    })]), __metadata("design:type", Function), __metadata("design:paramtypes", [Number, Object, Object]), __metadata("design:returntype", Promise)], SyncList.prototype, "set", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger, "function", ["undefined", declarativeTypeValidator.objectSchema("item metadata", {
      ttl: [declarativeTypeValidator.nonNegativeInteger, "undefined"]
    })]), __metadata("design:type", Function), __metadata("design:paramtypes", [Number, Function, Object]), __metadata("design:returntype", Promise)], SyncList.prototype, "mutate", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger, declarativeTypeValidator.pureObject, ["undefined", declarativeTypeValidator.objectSchema("item metadata", {
      ttl: [declarativeTypeValidator.nonNegativeInteger, "undefined"]
    })]), __metadata("design:type", Function), __metadata("design:paramtypes", [Number, Object, Object]), __metadata("design:returntype", Promise)], SyncList.prototype, "update", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger), __metadata("design:type", Function), __metadata("design:paramtypes", [Number]), __metadata("design:returntype", Promise)], SyncList.prototype, "remove", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger), __metadata("design:type", Function), __metadata("design:paramtypes", [Number]), __metadata("design:returntype", Promise)], SyncList.prototype, "get", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(["undefined", declarativeTypeValidator.objectSchema("query options", {
      from: [declarativeTypeValidator.nonNegativeInteger, "undefined"],
      pageSize: [declarativeTypeValidator.custom(function(value) {
        return [isPositiveInteger(value), "a positive integer"];
      }), "undefined"]
    })]), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", Promise)], SyncList.prototype, "getItems", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger), __metadata("design:type", Function), __metadata("design:paramtypes", [Number]), __metadata("design:returntype", Promise)], SyncList.prototype, "setTtl", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger, declarativeTypeValidator.nonNegativeInteger), __metadata("design:type", Function), __metadata("design:paramtypes", [Number, Number]), __metadata("design:returntype", Promise)], SyncList.prototype, "setItemTtl", null);
    var SyncMapItem = function() {
      function SyncMapItem2(descriptor) {
        _classCallCheck__default["default"](this, SyncMapItem2);
        this.descriptor = descriptor;
      }
      _createClass__default["default"](SyncMapItem2, [{
        key: "uri",
        get: function get() {
          return this.descriptor.url;
        }
      }, {
        key: "revision",
        get: function get() {
          return this.descriptor.revision;
        }
      }, {
        key: "lastEventId",
        get: function get() {
          return this.descriptor.last_event_id;
        }
      }, {
        key: "dateExpires",
        get: function get() {
          return this.descriptor.date_expires;
        }
        /**
         * The identifier that maps to this item within the containing Map.
         */
      }, {
        key: "key",
        get: function get() {
          return this.descriptor.key;
        }
        /**
         * The contents of the item.
         */
      }, {
        key: "data",
        get: function get() {
          return this.descriptor.data;
        }
        /**
         * Date when the map item was last updated.
         */
      }, {
        key: "dateUpdated",
        get: function get() {
          return this.descriptor.date_updated;
        }
        /**
         * @internal
         */
      }, {
        key: "update",
        value: function update(eventId, revision, value, dateUpdated) {
          this.descriptor.last_event_id = eventId;
          this.descriptor.revision = revision;
          this.descriptor.data = value;
          this.descriptor.date_updated = dateUpdated;
          return this;
        }
        /**
         * @internal
         */
      }, {
        key: "updateDateExpires",
        value: function updateDateExpires(dateExpires) {
          this.descriptor.date_expires = dateExpires;
        }
      }]);
      return SyncMapItem2;
    }();
    function _createSuper$3(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$3() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var SyncMapImpl = function(_SyncEntity) {
      _inherits__default["default"](SyncMapImpl2, _SyncEntity);
      var _super = _createSuper$3(SyncMapImpl2);
      function SyncMapImpl2(services, descriptor, removalHandler) {
        var _this;
        _classCallCheck__default["default"](this, SyncMapImpl2);
        _this = _super.call(this, services, removalHandler);
        var updateRequestReducer = function updateRequestReducer2(acc, input) {
          return typeof input.ttl === "number" ? {
            ttl: input.ttl
          } : acc;
        };
        _this.updateMergingQueue = new NamespacedMergingQueue(updateRequestReducer);
        _this.cache = new Cache();
        _this.descriptor = descriptor;
        _this.descriptor.date_updated = new Date(_this.descriptor.date_updated);
        if (descriptor.items) {
          descriptor.items.forEach(function(itemDescriptor) {
            itemDescriptor.date_updated = new Date(itemDescriptor.date_updated);
            _this.cache.store(itemDescriptor.key, new SyncMapItem(itemDescriptor), itemDescriptor.last_event_id);
          });
        }
        return _this;
      }
      _createClass__default["default"](SyncMapImpl2, [{
        key: "uri",
        get: function get() {
          return this.descriptor.url;
        }
      }, {
        key: "links",
        get: function get() {
          return this.descriptor.links;
        }
      }, {
        key: "revision",
        get: function get() {
          return this.descriptor.revision;
        }
      }, {
        key: "lastEventId",
        get: function get() {
          return this.descriptor.last_event_id;
        }
      }, {
        key: "dateExpires",
        get: function get() {
          return this.descriptor.date_expires;
        }
      }, {
        key: "type",
        get: function get() {
          return "map";
        }
        // below properties are specific to Insights only
      }, {
        key: "indexName",
        get: function get() {
          return void 0;
        }
      }, {
        key: "queryString",
        get: function get() {
          return void 0;
        }
        // public props, documented along with class description
      }, {
        key: "sid",
        get: function get() {
          return this.descriptor.sid;
        }
      }, {
        key: "uniqueName",
        get: function get() {
          return this.descriptor.unique_name || null;
        }
      }, {
        key: "dateUpdated",
        get: function get() {
          return this.descriptor.date_updated;
        }
      }, {
        key: "set",
        value: function() {
          var _set = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee(key, value, itemMetadataUpdates) {
            var _this2 = this;
            var input;
            return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    input = itemMetadataUpdates || {};
                    return _context.abrupt("return", this.updateMergingQueue.squashAndAdd(key, input, function(input2) {
                      return _this2._putItemUnconditionally(key, value, input2.ttl);
                    }));
                  case 2:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function set(_x, _x2, _x3) {
            return _set.apply(this, arguments);
          }
          return set;
        }()
      }, {
        key: "get",
        value: function() {
          var _get2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee2(key) {
            return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    if (!(key === null || key === void 0)) {
                      _context2.next = 2;
                      break;
                    }
                    throw new SyncError("SyncMapItem key may not be empty", 400, 54209);
                  case 2:
                    if (!this.cache.has(key)) {
                      _context2.next = 6;
                      break;
                    }
                    return _context2.abrupt("return", this.cache.get(key));
                  case 6:
                    return _context2.abrupt("return", this._getItemFromServer(key));
                  case 7:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function get(_x4) {
            return _get2.apply(this, arguments);
          }
          return get;
        }()
      }, {
        key: "_getItemFromServer",
        value: function() {
          var _getItemFromServer2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee3(key) {
            var result;
            return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    _context3.next = 2;
                    return this.queryItems({
                      key
                    });
                  case 2:
                    result = _context3.sent;
                    if (!(result.items.length < 1)) {
                      _context3.next = 7;
                      break;
                    }
                    throw new SyncError("The specified Map Item does not exist", 404, 54201);
                  case 7:
                    return _context3.abrupt("return", result.items[0]);
                  case 8:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));
          function _getItemFromServer(_x5) {
            return _getItemFromServer2.apply(this, arguments);
          }
          return _getItemFromServer;
        }()
      }, {
        key: "mutate",
        value: function() {
          var _mutate = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee4(key, mutator, itemMetadataUpdates) {
            var _this3 = this;
            var input;
            return _regeneratorRuntime__default["default"].wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    input = itemMetadataUpdates || {};
                    return _context4.abrupt("return", this.updateMergingQueue.add(key, input, function(input2) {
                      return _this3._putItemWithIfMatch(key, mutator, input2.ttl);
                    }));
                  case 2:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));
          function mutate(_x6, _x7, _x8) {
            return _mutate.apply(this, arguments);
          }
          return mutate;
        }()
      }, {
        key: "update",
        value: function() {
          var _update2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee5(key, obj, itemMetadataUpdates) {
            return _regeneratorRuntime__default["default"].wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    return _context5.abrupt("return", this.mutate(key, function(remote) {
                      return Object.assign(remote, obj);
                    }, itemMetadataUpdates));
                  case 1:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));
          function update(_x9, _x10, _x11) {
            return _update2.apply(this, arguments);
          }
          return update;
        }()
      }, {
        key: "_putItemUnconditionally",
        value: function() {
          var _putItemUnconditionally2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee6(key, data, ttl) {
            var result, item;
            return _regeneratorRuntime__default["default"].wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    _context6.next = 2;
                    return this._putItemToServer(key, data, void 0, ttl);
                  case 2:
                    result = _context6.sent;
                    item = result.item;
                    this._handleItemMutated(item.key, item.url, item.last_event_id, item.revision, item.data, item.date_updated, item.date_expires, result.added, false);
                    return _context6.abrupt("return", this.cache.get(item.key));
                  case 6:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, this);
          }));
          function _putItemUnconditionally(_x12, _x13, _x14) {
            return _putItemUnconditionally2.apply(this, arguments);
          }
          return _putItemUnconditionally;
        }()
      }, {
        key: "_putItemWithIfMatch",
        value: function() {
          var _putItemWithIfMatch2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee7(key, mutatorFunction, ttl) {
            var currentItem, data, ifMatch, result, item;
            return _regeneratorRuntime__default["default"].wrap(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    _context7.next = 2;
                    return this.get(key).catch(function(error) {
                      if (error.status === 404) {
                        return new SyncMapItem({
                          key,
                          data: {},
                          last_event_id: -1,
                          revision: "-1",
                          url: null,
                          date_updated: null,
                          date_expires: null
                        });
                      } else {
                        throw error;
                      }
                    });
                  case 2:
                    currentItem = _context7.sent;
                    data = mutatorFunction(deepClone(currentItem.data));
                    if (!data) {
                      _context7.next = 26;
                      break;
                    }
                    ifMatch = currentItem.revision;
                    _context7.prev = 6;
                    _context7.next = 9;
                    return this._putItemToServer(key, data, ifMatch, ttl);
                  case 9:
                    result = _context7.sent;
                    item = result.item;
                    this._handleItemMutated(item.key, item.url, item.last_event_id, item.revision, item.data, item.date_updated, item.date_expires, result.added, false);
                    return _context7.abrupt("return", this.cache.get(item.key));
                  case 15:
                    _context7.prev = 15;
                    _context7.t0 = _context7["catch"](6);
                    if (!(_context7.t0.status === 412)) {
                      _context7.next = 23;
                      break;
                    }
                    _context7.next = 20;
                    return this._getItemFromServer(key);
                  case 20:
                    return _context7.abrupt("return", this._putItemWithIfMatch(key, mutatorFunction, ttl));
                  case 23:
                    throw _context7.t0;
                  case 24:
                    _context7.next = 27;
                    break;
                  case 26:
                    return _context7.abrupt("return", currentItem);
                  case 27:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee7, this, [[6, 15]]);
          }));
          function _putItemWithIfMatch(_x15, _x16, _x17) {
            return _putItemWithIfMatch2.apply(this, arguments);
          }
          return _putItemWithIfMatch;
        }()
      }, {
        key: "_putItemToServer",
        value: function() {
          var _putItemToServer2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee8(key, data, ifMatch, ttl) {
            var url, requestBody, response, mapItemDescriptor, added;
            return _regeneratorRuntime__default["default"].wrap(function _callee8$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    url = new UriBuilder(this.links.items).pathSegment(key).build();
                    requestBody = {
                      data
                    };
                    if (ttl !== void 0) {
                      requestBody.ttl = ttl;
                    }
                    _context8.prev = 3;
                    _context8.next = 6;
                    return this.services.network.put(url, requestBody, ifMatch);
                  case 6:
                    response = _context8.sent;
                    mapItemDescriptor = response.body;
                    mapItemDescriptor.data = data;
                    mapItemDescriptor.date_updated = new Date(mapItemDescriptor.date_updated);
                    added = response.status.code === 201;
                    return _context8.abrupt("return", {
                      added,
                      item: mapItemDescriptor
                    });
                  case 14:
                    _context8.prev = 14;
                    _context8.t0 = _context8["catch"](3);
                    if (_context8.t0.status === 404) {
                      this.onRemoved(false);
                    }
                    throw _context8.t0;
                  case 18:
                  case "end":
                    return _context8.stop();
                }
              }
            }, _callee8, this, [[3, 14]]);
          }));
          function _putItemToServer(_x18, _x19, _x20, _x21) {
            return _putItemToServer2.apply(this, arguments);
          }
          return _putItemToServer;
        }()
      }, {
        key: "remove",
        value: function() {
          var _remove = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee9(key) {
            var item, previousItemData, response;
            return _regeneratorRuntime__default["default"].wrap(function _callee9$(_context9) {
              while (1) {
                switch (_context9.prev = _context9.next) {
                  case 0:
                    _context9.next = 2;
                    return this.get(key);
                  case 2:
                    item = _context9.sent;
                    previousItemData = deepClone(item.data);
                    _context9.next = 6;
                    return this.services.network.delete(item.uri);
                  case 6:
                    response = _context9.sent;
                    this._handleItemRemoved(key, response.body.last_event_id, previousItemData, new Date(response.body.date_updated), false);
                  case 8:
                  case "end":
                    return _context9.stop();
                }
              }
            }, _callee9, this);
          }));
          function remove(_x22) {
            return _remove.apply(this, arguments);
          }
          return remove;
        }()
        /**
         * @private
         */
      }, {
        key: "queryItems",
        value: function() {
          var _queryItems2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee10(args) {
            var _this4 = this;
            var uri, response, items, meta;
            return _regeneratorRuntime__default["default"].wrap(function _callee10$(_context10) {
              while (1) {
                switch (_context10.prev = _context10.next) {
                  case 0:
                    args = args || {};
                    uri = new UriBuilder(this.links.items).queryParam("From", args.from).queryParam("PageSize", args.limit).queryParam("Key", args.key).queryParam("PageToken", args.pageToken).queryParam("Order", args.order).build();
                    _context10.next = 4;
                    return this.services.network.get(uri);
                  case 4:
                    response = _context10.sent;
                    items = response.body.items.map(function(el) {
                      el.date_updated = new Date(el.date_updated);
                      var itemInCache = _this4.cache.get(el.key);
                      if (itemInCache) {
                        _this4._handleItemMutated(el.key, el.url, el.last_event_id, el.revision, el.data, el.date_updated, el.date_expires, false, true);
                      } else {
                        _this4.cache.store(el.key, new SyncMapItem(el), el.last_event_id);
                      }
                      return _this4.cache.get(el.key);
                    });
                    meta = response.body.meta;
                    return _context10.abrupt("return", new Paginator(items, function(pageToken) {
                      return _this4.queryItems({
                        pageToken
                      });
                    }, meta.previous_token, meta.next_token));
                  case 8:
                  case "end":
                    return _context10.stop();
                }
              }
            }, _callee10, this);
          }));
          function queryItems2(_x23) {
            return _queryItems2.apply(this, arguments);
          }
          return queryItems2;
        }()
      }, {
        key: "getItems",
        value: function() {
          var _getItems = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee11(args) {
            return _regeneratorRuntime__default["default"].wrap(function _callee11$(_context11) {
              while (1) {
                switch (_context11.prev = _context11.next) {
                  case 0:
                    args = args || {};
                    validatePageSize(args.pageSize);
                    args.limit = args.pageSize || args.limit || 50;
                    args.order = args.order || "asc";
                    return _context11.abrupt("return", this.queryItems(args));
                  case 5:
                  case "end":
                    return _context11.stop();
                }
              }
            }, _callee11, this);
          }));
          function getItems(_x24) {
            return _getItems.apply(this, arguments);
          }
          return getItems;
        }()
      }, {
        key: "shouldIgnoreEvent",
        value: function shouldIgnoreEvent(key, eventId) {
          return this.cache.isKnown(key, eventId);
        }
        /**
         * Handle update from the server
         * @private
         */
      }, {
        key: "_update",
        value: function _update(update, isStrictlyOrdered) {
          update.date_created = new Date(update.date_created);
          switch (update.type) {
            case "map_item_added":
            case "map_item_updated":
              {
                this._handleItemMutated(
                  update.item_key,
                  update.item_url,
                  update.id,
                  update.item_revision,
                  update.item_data,
                  update.date_created,
                  void 0,
                  // orchestration events do not include date_expires
                  update.type === "map_item_added",
                  true
                );
              }
              break;
            case "map_item_removed":
              {
                this._handleItemRemoved(update.item_key, update.id, update.item_data, update.date_created, true);
              }
              break;
            case "map_removed":
              {
                this.onRemoved(false);
              }
              break;
          }
          if (isStrictlyOrdered) {
            this._advanceLastEventId(update.id, update.map_revision);
          }
        }
      }, {
        key: "_advanceLastEventId",
        value: function _advanceLastEventId(eventId, revision) {
          if (this.lastEventId < eventId) {
            this.descriptor.last_event_id = eventId;
            if (revision) {
              this.descriptor.revision = revision;
            }
          }
        }
      }, {
        key: "_updateRootDateUpdated",
        value: function _updateRootDateUpdated(dateUpdated) {
          if (!this.descriptor.date_updated || dateUpdated.getTime() > this.descriptor.date_updated.getTime()) {
            this.descriptor.date_updated = dateUpdated;
            this.services.storage.update(this.type, this.sid, this.uniqueName, {
              date_updated: dateUpdated
            });
          }
        }
      }, {
        key: "_handleItemMutated",
        value: function _handleItemMutated(key, url, lastEventId, revision, data, dateUpdated, dateExpires, added, remote) {
          if (this.shouldIgnoreEvent(key, lastEventId)) {
            log$1.trace("SyncMapItem ", key, " update skipped, current:", this.lastEventId, ", remote:", lastEventId);
            return;
          }
          this._updateRootDateUpdated(dateUpdated);
          var item = this.cache.get(key);
          if (!item) {
            var newItem = new SyncMapItem({
              key,
              url,
              last_event_id: lastEventId,
              revision,
              data,
              date_updated: dateUpdated,
              date_expires: dateExpires
            });
            this.cache.store(key, newItem, lastEventId);
            this.emitItemMutationEvent(newItem, remote, added);
            return;
          }
          var previousItemData = deepClone(item.data);
          item.update(lastEventId, revision, data, dateUpdated);
          this.cache.store(key, item, lastEventId);
          if (dateExpires !== void 0) {
            item.updateDateExpires(dateExpires);
          }
          this.emitItemMutationEvent(item, remote, false, previousItemData);
        }
      }, {
        key: "emitItemMutationEvent",
        value: function emitItemMutationEvent(item, remote, added) {
          var previousItemData = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
          var eventName = added ? "itemAdded" : "itemUpdated";
          var args = {
            item,
            isLocal: !remote
          };
          if (!added) {
            args.previousItemData = previousItemData;
          }
          this.broadcastEventToListeners(eventName, args);
        }
        /**
         * @private
         */
      }, {
        key: "_handleItemRemoved",
        value: function _handleItemRemoved(key, eventId, oldData, dateUpdated, remote) {
          this._updateRootDateUpdated(dateUpdated);
          this.cache.delete(key, eventId);
          this.broadcastEventToListeners("itemRemoved", {
            key,
            isLocal: !remote,
            previousItemData: oldData
          });
        }
      }, {
        key: "onRemoved",
        value: function onRemoved(locally) {
          this._unsubscribe();
          this.removalHandler(this.type, this.sid, this.uniqueName);
          this.broadcastEventToListeners("removed", {
            isLocal: locally
          });
        }
      }, {
        key: "setTtl",
        value: function() {
          var _setTtl = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee12(ttl) {
            var requestBody, response;
            return _regeneratorRuntime__default["default"].wrap(function _callee12$(_context12) {
              while (1) {
                switch (_context12.prev = _context12.next) {
                  case 0:
                    _context12.prev = 0;
                    requestBody = {
                      ttl
                    };
                    _context12.next = 4;
                    return this.services.network.post(this.uri, requestBody);
                  case 4:
                    response = _context12.sent;
                    this.descriptor.date_expires = response.body.date_expires;
                    _context12.next = 12;
                    break;
                  case 8:
                    _context12.prev = 8;
                    _context12.t0 = _context12["catch"](0);
                    if (_context12.t0.status === 404) {
                      this.onRemoved(false);
                    }
                    throw _context12.t0;
                  case 12:
                  case "end":
                    return _context12.stop();
                }
              }
            }, _callee12, this, [[0, 8]]);
          }));
          function setTtl(_x25) {
            return _setTtl.apply(this, arguments);
          }
          return setTtl;
        }()
      }, {
        key: "setItemTtl",
        value: function() {
          var _setItemTtl = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee13(key, ttl) {
            var existingItem, requestBody, response;
            return _regeneratorRuntime__default["default"].wrap(function _callee13$(_context13) {
              while (1) {
                switch (_context13.prev = _context13.next) {
                  case 0:
                    _context13.next = 2;
                    return this.get(key);
                  case 2:
                    existingItem = _context13.sent;
                    requestBody = {
                      ttl
                    };
                    _context13.next = 6;
                    return this.services.network.post(existingItem.uri, requestBody);
                  case 6:
                    response = _context13.sent;
                    existingItem.updateDateExpires(response.body.date_expires);
                  case 8:
                  case "end":
                    return _context13.stop();
                }
              }
            }, _callee13, this);
          }));
          function setItemTtl(_x26, _x27) {
            return _setItemTtl.apply(this, arguments);
          }
          return setItemTtl;
        }()
      }, {
        key: "removeMap",
        value: function() {
          var _removeMap = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee14() {
            return _regeneratorRuntime__default["default"].wrap(function _callee14$(_context14) {
              while (1) {
                switch (_context14.prev = _context14.next) {
                  case 0:
                    _context14.next = 2;
                    return this.services.network.delete(this.uri);
                  case 2:
                    this.onRemoved(true);
                  case 3:
                  case "end":
                    return _context14.stop();
                }
              }
            }, _callee14, this);
          }));
          function removeMap() {
            return _removeMap.apply(this, arguments);
          }
          return removeMap;
        }()
      }], [{
        key: "type",
        get: function get() {
          return "map";
        }
      }]);
      return SyncMapImpl2;
    }(SyncEntity);
    var SyncMap = function(_Closeable) {
      _inherits__default["default"](SyncMap2, _Closeable);
      var _super2 = _createSuper$3(SyncMap2);
      function SyncMap2(syncMapImpl) {
        var _this5;
        _classCallCheck__default["default"](this, SyncMap2);
        _this5 = _super2.call(this);
        _this5.syncMapImpl = syncMapImpl;
        _this5.syncMapImpl.attach(_assertThisInitialized__default["default"](_this5));
        return _this5;
      }
      _createClass__default["default"](SyncMap2, [{
        key: "uri",
        get: (
          // private props
          function get() {
            return this.syncMapImpl.uri;
          }
        )
      }, {
        key: "links",
        get: function get() {
          return this.syncMapImpl.links;
        }
      }, {
        key: "revision",
        get: function get() {
          return this.syncMapImpl.revision;
        }
      }, {
        key: "lastEventId",
        get: function get() {
          return this.syncMapImpl.lastEventId;
        }
      }, {
        key: "dateExpires",
        get: function get() {
          return this.syncMapImpl.dateExpires;
        }
      }, {
        key: "type",
        get: function get() {
          return SyncMapImpl.type;
        }
        /**
         * An immutable identifier (a SID) assigned by the system on creation.
         */
      }, {
        key: "sid",
        get: function get() {
          return this.syncMapImpl.sid;
        }
        /**
         * An optional immutable identifier that may be assigned by the
         * programmer to this map on creation. Unique among other Maps.
         */
      }, {
        key: "uniqueName",
        get: function get() {
          return this.syncMapImpl.uniqueName;
        }
        /**
         * Date when the map was last updated.
         */
      }, {
        key: "dateUpdated",
        get: function get() {
          return this.syncMapImpl.dateUpdated;
        }
      }, {
        key: "set",
        value: (
          /**
           * Add a new item to the map with the given key-value pair. Overwrites any data that might already exist with that key.
           * @param key Unique item identifier.
           * @param data Data to be set.
           * @param itemMetadataUpdates New item metadata.
           * @return Newly added item, or modified one if already exists, with the latest known data.
           * @example
           * ```typescript
           * map.set('myKey', { name: 'John Smith' }, { ttl: 86400 })
           *   .then((item) => {
           *     console.log('Map SyncMapItem set() successful, item data:', item.data);
           *   })
           *   .catch((error) => {
           *     console.error('Map SyncMapItem set() failed', error);
           *   });
           * ```
           */
          function() {
            var _set2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee15(key, data, itemMetadataUpdates) {
              return _regeneratorRuntime__default["default"].wrap(function _callee15$(_context15) {
                while (1) {
                  switch (_context15.prev = _context15.next) {
                    case 0:
                      this.ensureNotClosed();
                      return _context15.abrupt("return", this.syncMapImpl.set(key, data, itemMetadataUpdates));
                    case 2:
                    case "end":
                      return _context15.stop();
                  }
                }
              }, _callee15, this);
            }));
            function set(_x28, _x29, _x30) {
              return _set2.apply(this, arguments);
            }
            return set;
          }()
        )
        /**
         * Retrieve an item by key.
         * @param key Identifies the desired item.
         * @return A promise that resolves when the item has been fetched.
         * This promise will be rejected if item was not found.
         * @example
         * ```typescript
         * map.get('myKey')
         *   .then((item) => {
         *     console.log('Map SyncMapItem get() successful, item data:', item.data)
         *   })
         *   .catch((error) => {
         *     console.error('Map SyncMapItem get() failed', error);
         *   });
         * ```
         */
      }, {
        key: "get",
        value: function() {
          var _get3 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee16(key) {
            return _regeneratorRuntime__default["default"].wrap(function _callee16$(_context16) {
              while (1) {
                switch (_context16.prev = _context16.next) {
                  case 0:
                    this.ensureNotClosed();
                    return _context16.abrupt("return", this.syncMapImpl.get(key));
                  case 2:
                  case "end":
                    return _context16.stop();
                }
              }
            }, _callee16, this);
          }));
          function get(_x31) {
            return _get3.apply(this, arguments);
          }
          return get;
        }()
        /**
         * Schedules a modification to this Map SyncMapItem that will apply a mutation function.
         * If no SyncMapItem with the given key exists, it will first be created, having the default data (`{}`).
         * @param key Selects the map item to be mutated.
         * @param mutator A function that outputs a new data based on the existing data.
         * May be called multiple times, particularly if this Map SyncMapItem is modified concurrently by remote code.
         * If the mutation ultimately succeeds, the Map SyncMapItem will have made the particular transition described
         * by this function.
         * @param itemMetadataUpdates New item metadata.
         * @return Resolves with the most recent item state, the output of a successful
         * mutation or a state that prompted graceful cancellation (mutator returned `null`).
         * @example
         * ```typescript
         * const mutatorFunction = (currentData) => {
         *     currentData.viewCount = (currentData.viewCount || 0) + 1;
         *     return currentData;
         * };
         * map.mutate('myKey', mutatorFunction, { ttl: 86400 })
         *   .then((item) => {
         *     console.log('Map SyncMapItem mutate() successful, new data:', item.data)
         *   })
         *   .catch((error) => {
         *     console.error('Map SyncMapItem mutate() failed', error);
         *   });
         * ```
         */
      }, {
        key: "mutate",
        value: function() {
          var _mutate2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee17(key, mutator, itemMetadataUpdates) {
            return _regeneratorRuntime__default["default"].wrap(function _callee17$(_context17) {
              while (1) {
                switch (_context17.prev = _context17.next) {
                  case 0:
                    this.ensureNotClosed();
                    return _context17.abrupt("return", this.syncMapImpl.mutate(key, mutator, itemMetadataUpdates));
                  case 2:
                  case "end":
                    return _context17.stop();
                }
              }
            }, _callee17, this);
          }));
          function mutate(_x32, _x33, _x34) {
            return _mutate2.apply(this, arguments);
          }
          return mutate;
        }()
        /**
         * Modify a map item by appending new fields (or by overwriting existing ones) with the values from
         * the provided Object. Creates a new item if no item by this key exists, copying all given fields and values
         * into it.
         * This is equivalent to
         * ```typescript
         * map.mutate('myKey', (currentData) => Object.assign(currentData, obj));
         * ```
         * @param key Selects the map item to update.
         * @param obj Specifies the particular (top-level) attributes that will receive new values.
         * @param itemMetadataUpdates New item metadata.
         * @return A promise resolving to the modified item in its new state.
         * @example
         * ```typescript
         * // Say, the Map SyncMapItem (key: `'myKey'`) data is `{ name: 'John Smith' }`
         * map.update('myKey', { age: 34 }, { ttl: 86400 })
         *   .then((item) => {
         *     // Now the Map SyncMapItem data is `{ name: 'John Smith', age: 34 }`
         *     console.log('Map SyncMapItem update() successful, new data:', item.data);
         *   })
         *   .catch((error) => {
         *     console.error('Map SyncMapItem update() failed', error);
         *   });
         * ```
         */
      }, {
        key: "update",
        value: function() {
          var _update3 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee18(key, obj, itemMetadataUpdates) {
            return _regeneratorRuntime__default["default"].wrap(function _callee18$(_context18) {
              while (1) {
                switch (_context18.prev = _context18.next) {
                  case 0:
                    this.ensureNotClosed();
                    return _context18.abrupt("return", this.syncMapImpl.update(key, obj, itemMetadataUpdates));
                  case 2:
                  case "end":
                    return _context18.stop();
                }
              }
            }, _callee18, this);
          }));
          function update(_x35, _x36, _x37) {
            return _update3.apply(this, arguments);
          }
          return update;
        }()
        /**
         * Delete an item, given its key.
         * @param key Selects the item to delete.
         * @return A promise to remove an item.
         * The promise will be rejected if 'key' is undefined or an item was not found.
         * @example
         * ```typescript
         * map.remove('myKey')
         *   .then(() => {
         *     console.log('Map SyncMapItem remove() successful');
         *   })
         *   .catch((error) => {
         *     console.error('Map SyncMapItem remove() failed', error);
         *   });
         * ```
         */
      }, {
        key: "remove",
        value: function() {
          var _remove2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee19(key) {
            return _regeneratorRuntime__default["default"].wrap(function _callee19$(_context19) {
              while (1) {
                switch (_context19.prev = _context19.next) {
                  case 0:
                    this.ensureNotClosed();
                    return _context19.abrupt("return", this.syncMapImpl.remove(key));
                  case 2:
                  case "end":
                    return _context19.stop();
                }
              }
            }, _callee19, this);
          }));
          function remove(_x38) {
            return _remove2.apply(this, arguments);
          }
          return remove;
        }()
        /**
         * Get a complete list of items from the map.
         * Information about the query limits can be found [here](https://www.twilio.com/docs/sync/limits).
         * @param queryOptions Query options.
         * @example
         * ```typescript
         * const pageHandler = (paginator) => {
         *   paginator.items.forEach((item) => {
         *     console.log(`SyncMapItem ${item.key}: `, item.data);
         *   });
         *   return paginator.hasNextPage
         *     ? paginator.nextPage().then(pageHandler)
         *     : null;
         * };
         * map.getItems({ from: 'myKey', order: 'asc' })
         *   .then(pageHandler)
         *   .catch((error) => {
         *     console.error('Map getItems() failed', error);
         *   });
         * ```
         */
      }, {
        key: "getItems",
        value: function() {
          var _getItems2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee20(queryOptions) {
            return _regeneratorRuntime__default["default"].wrap(function _callee20$(_context20) {
              while (1) {
                switch (_context20.prev = _context20.next) {
                  case 0:
                    this.ensureNotClosed();
                    return _context20.abrupt("return", this.syncMapImpl.getItems(queryOptions));
                  case 2:
                  case "end":
                    return _context20.stop();
                }
              }
            }, _callee20, this);
          }));
          function getItems(_x39) {
            return _getItems2.apply(this, arguments);
          }
          return getItems;
        }()
        /**
         * Update the time-to-live of the map.
         * @param ttl Specifies the TTL in seconds after which the map is subject to automatic deletion. The value 0 means infinity.
         * @return A promise that resolves after the TTL update was successful.
         * @example
         * ```typescript
         * map.setTtl(3600)
         *   .then(() => {
         *     console.log('Map setTtl() successful');
         *   })
         *   .catch((error) => {
         *     console.error('Map setTtl() failed', error);
         *   });
         * ```
         */
      }, {
        key: "setTtl",
        value: function() {
          var _setTtl2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee21(ttl) {
            return _regeneratorRuntime__default["default"].wrap(function _callee21$(_context21) {
              while (1) {
                switch (_context21.prev = _context21.next) {
                  case 0:
                    this.ensureNotClosed();
                    return _context21.abrupt("return", this.syncMapImpl.setTtl(ttl));
                  case 2:
                  case "end":
                    return _context21.stop();
                }
              }
            }, _callee21, this);
          }));
          function setTtl(_x40) {
            return _setTtl2.apply(this, arguments);
          }
          return setTtl;
        }()
        /**
         * Update the time-to-live of a map item.
         * @param key SyncMapItem key.
         * @param ttl Specifies the TTL in seconds after which the map item is subject to automatic deletion. The value 0 means infinity.
         * @return A promise that resolves after the TTL update was successful.
         * @example
         * ```typescript
         * map.setItemTtl('myKey', 86400)
         *   .then(() => {
         *     console.log('Map setItemTtl() successful');
         *   })
         *   .catch((error) => {
         *     console.error('Map setItemTtl() failed', error);
         *   });
         * ```
         */
      }, {
        key: "setItemTtl",
        value: function() {
          var _setItemTtl2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee22(key, ttl) {
            return _regeneratorRuntime__default["default"].wrap(function _callee22$(_context22) {
              while (1) {
                switch (_context22.prev = _context22.next) {
                  case 0:
                    this.ensureNotClosed();
                    return _context22.abrupt("return", this.syncMapImpl.setItemTtl(key, ttl));
                  case 2:
                  case "end":
                    return _context22.stop();
                }
              }
            }, _callee22, this);
          }));
          function setItemTtl(_x41, _x42) {
            return _setItemTtl2.apply(this, arguments);
          }
          return setItemTtl;
        }()
        /**
         * Delete this map. It will be impossible to restore it.
         * @return A promise that resolves when the map has been deleted.
         * @example
         * ```typescript
         * map.removeMap()
         *   .then(() => {
         *     console.log('Map removeMap() successful');
         *   })
         *   .catch((error) => {
         *     console.error('Map removeMap() failed', error);
         *   });
         * ```
         */
      }, {
        key: "removeMap",
        value: function() {
          var _removeMap2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee23() {
            return _regeneratorRuntime__default["default"].wrap(function _callee23$(_context23) {
              while (1) {
                switch (_context23.prev = _context23.next) {
                  case 0:
                    this.ensureNotClosed();
                    _context23.next = 3;
                    return this.syncMapImpl.removeMap();
                  case 3:
                  case "end":
                    return _context23.stop();
                }
              }
            }, _callee23, this);
          }));
          function removeMap() {
            return _removeMap2.apply(this, arguments);
          }
          return removeMap;
        }()
        /**
         * Conclude work with the map instance and remove all event listeners attached to it.
         * Any subsequent operation on this object will be rejected with error.
         * Other local copies of this map will continue operating and receiving events normally.
         * @example
         * ```typescript
         * map.close();
         * ````
         */
      }, {
        key: "close",
        value: function close() {
          _get__default["default"](_getPrototypeOf__default["default"](SyncMap2.prototype), "close", this).call(this);
          this.syncMapImpl.detach(this.listenerUuid);
        }
      }], [{
        key: "type",
        get: function get() {
          return SyncMapImpl.type;
        }
      }]);
      return SyncMap2;
    }(Closeable);
    _defineProperty__default["default"](SyncMap, "itemAdded", "itemAdded");
    _defineProperty__default["default"](SyncMap, "itemUpdated", "itemUpdated");
    _defineProperty__default["default"](SyncMap, "itemRemoved", "itemRemoved");
    _defineProperty__default["default"](SyncMap, "removed", "removed");
    __decorate([declarativeTypeValidator.validateTypesAsync("string", declarativeTypeValidator.pureObject, ["undefined", declarativeTypeValidator.objectSchema("item metadata", {
      ttl: [declarativeTypeValidator.nonNegativeInteger, "undefined"]
    })]), __metadata("design:type", Function), __metadata("design:paramtypes", [String, Object, Object]), __metadata("design:returntype", Promise)], SyncMap.prototype, "set", null);
    __decorate([declarativeTypeValidator.validateTypesAsync("string"), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", Promise)], SyncMap.prototype, "get", null);
    __decorate([declarativeTypeValidator.validateTypesAsync("string", "function", ["undefined", declarativeTypeValidator.objectSchema("item metadata", {
      ttl: [declarativeTypeValidator.nonNegativeInteger, "undefined"]
    })]), __metadata("design:type", Function), __metadata("design:paramtypes", [String, Function, Object]), __metadata("design:returntype", Promise)], SyncMap.prototype, "mutate", null);
    __decorate([declarativeTypeValidator.validateTypesAsync("string", declarativeTypeValidator.pureObject, ["undefined", declarativeTypeValidator.objectSchema("item metadata", {
      ttl: [declarativeTypeValidator.nonNegativeInteger, "undefined"]
    })]), __metadata("design:type", Function), __metadata("design:paramtypes", [String, Object, Object]), __metadata("design:returntype", Promise)], SyncMap.prototype, "update", null);
    __decorate([declarativeTypeValidator.validateTypesAsync("string"), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", Promise)], SyncMap.prototype, "remove", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(["undefined", declarativeTypeValidator.objectSchema("query options", {
      from: ["string", "undefined"],
      pageSize: [declarativeTypeValidator.custom(function(value) {
        return [isPositiveInteger(value), "a positive integer"];
      }), "undefined"]
    })]), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", Promise)], SyncMap.prototype, "getItems", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger), __metadata("design:type", Function), __metadata("design:paramtypes", [Number]), __metadata("design:returntype", Promise)], SyncMap.prototype, "setTtl", null);
    __decorate([declarativeTypeValidator.validateTypesAsync("string", declarativeTypeValidator.nonNegativeInteger), __metadata("design:type", Function), __metadata("design:paramtypes", [String, Number]), __metadata("design:returntype", Promise)], SyncMap.prototype, "setItemTtl", null);
    function _createSuper$2(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$2() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var SyncStreamImpl = function(_SyncEntity) {
      _inherits__default["default"](SyncStreamImpl2, _SyncEntity);
      var _super = _createSuper$2(SyncStreamImpl2);
      function SyncStreamImpl2(services, descriptor, removalHandler) {
        var _this;
        _classCallCheck__default["default"](this, SyncStreamImpl2);
        _this = _super.call(this, services, removalHandler);
        _this.descriptor = descriptor;
        return _this;
      }
      _createClass__default["default"](SyncStreamImpl2, [{
        key: "uri",
        get: function get() {
          return this.descriptor.url;
        }
      }, {
        key: "links",
        get: function get() {
          return this.descriptor.links;
        }
      }, {
        key: "dateExpires",
        get: function get() {
          return this.descriptor.date_expires;
        }
      }, {
        key: "type",
        get: function get() {
          return "stream";
        }
      }, {
        key: "lastEventId",
        get: function get() {
          return null;
        }
        // below properties are specific to Insights only
      }, {
        key: "indexName",
        get: function get() {
          return void 0;
        }
      }, {
        key: "queryString",
        get: function get() {
          return void 0;
        }
        // public props, documented along with class description
      }, {
        key: "sid",
        get: function get() {
          return this.descriptor.sid;
        }
      }, {
        key: "uniqueName",
        get: function get() {
          return this.descriptor.unique_name || null;
        }
      }, {
        key: "publishMessage",
        value: function() {
          var _publishMessage = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee(data) {
            var requestBody, response, responseBody, event;
            return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    requestBody = {
                      data
                    };
                    _context.next = 3;
                    return this.services.network.post(this.links.messages, requestBody);
                  case 3:
                    response = _context.sent;
                    responseBody = response.body;
                    event = this._handleMessagePublished(responseBody.sid, data, false);
                    return _context.abrupt("return", event);
                  case 7:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function publishMessage(_x) {
            return _publishMessage.apply(this, arguments);
          }
          return publishMessage;
        }()
      }, {
        key: "setTtl",
        value: function() {
          var _setTtl = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee2(ttl) {
            var requestBody, response;
            return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.prev = 0;
                    requestBody = {
                      ttl
                    };
                    _context2.next = 4;
                    return this.services.network.post(this.uri, requestBody);
                  case 4:
                    response = _context2.sent;
                    this.descriptor.date_expires = response.body.date_expires;
                    _context2.next = 12;
                    break;
                  case 8:
                    _context2.prev = 8;
                    _context2.t0 = _context2["catch"](0);
                    if (_context2.t0.status === 404) {
                      this.onRemoved(false);
                    }
                    throw _context2.t0;
                  case 12:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this, [[0, 8]]);
          }));
          function setTtl(_x2) {
            return _setTtl.apply(this, arguments);
          }
          return setTtl;
        }()
      }, {
        key: "removeStream",
        value: function() {
          var _removeStream = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee3() {
            return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    _context3.next = 2;
                    return this.services.network.delete(this.uri);
                  case 2:
                    this.onRemoved(true);
                  case 3:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));
          function removeStream() {
            return _removeStream.apply(this, arguments);
          }
          return removeStream;
        }()
        /**
         * Handle event from the server
         * @private
         */
      }, {
        key: "_update",
        value: function _update(update) {
          switch (update.type) {
            case "stream_message_published": {
              this._handleMessagePublished(update.message_sid, update.message_data, true);
              break;
            }
            case "stream_removed": {
              this.onRemoved(false);
              break;
            }
          }
        }
      }, {
        key: "_handleMessagePublished",
        value: function _handleMessagePublished(sid, data, remote) {
          var event = {
            sid,
            data
          };
          this.broadcastEventToListeners("messagePublished", {
            message: event,
            isLocal: !remote
          });
          return event;
        }
      }, {
        key: "onRemoved",
        value: function onRemoved(isLocal) {
          this._unsubscribe();
          this.removalHandler(this.type, this.sid, this.uniqueName);
          this.broadcastEventToListeners("removed", {
            isLocal
          });
        }
      }], [{
        key: "type",
        get: function get() {
          return "stream";
        }
      }]);
      return SyncStreamImpl2;
    }(SyncEntity);
    __decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.pureObject), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", Promise)], SyncStreamImpl.prototype, "publishMessage", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger), __metadata("design:type", Function), __metadata("design:paramtypes", [Number]), __metadata("design:returntype", Promise)], SyncStreamImpl.prototype, "setTtl", null);
    var SyncStream = function(_Closeable) {
      _inherits__default["default"](SyncStream2, _Closeable);
      var _super2 = _createSuper$2(SyncStream2);
      function SyncStream2(syncStreamImpl) {
        var _this2;
        _classCallCheck__default["default"](this, SyncStream2);
        _this2 = _super2.call(this);
        _this2.syncStreamImpl = syncStreamImpl;
        _this2.syncStreamImpl.attach(_assertThisInitialized__default["default"](_this2));
        return _this2;
      }
      _createClass__default["default"](SyncStream2, [{
        key: "uri",
        get: (
          // private props
          function get() {
            return this.syncStreamImpl.uri;
          }
        )
      }, {
        key: "links",
        get: function get() {
          return this.syncStreamImpl.links;
        }
      }, {
        key: "dateExpires",
        get: function get() {
          return this.syncStreamImpl.dateExpires;
        }
      }, {
        key: "type",
        get: function get() {
          return SyncStreamImpl.type;
        }
      }, {
        key: "lastEventId",
        get: function get() {
          return null;
        }
        /**
         * The immutable system-assigned identifier of this stream. Never null.
         */
      }, {
        key: "sid",
        get: function get() {
          return this.syncStreamImpl.sid;
        }
        /**
         * A unique identifier optionally assigned to the stream on creation.
         */
      }, {
        key: "uniqueName",
        get: function get() {
          return this.syncStreamImpl.uniqueName;
        }
      }, {
        key: "publishMessage",
        value: (
          /**
           * Publish a message to the stream. The system will attempt delivery to all online subscribers.
           * @param data The body of the dispatched message. Maximum size in serialized JSON: 4KB.
           * A rate limit applies to this operation, refer to the [Sync API documentation](https://www.twilio.com/docs/api/sync) for details.
           * @return A promise which resolves after the message is successfully published
           * to the Sync service. Resolves irrespective of ultimate delivery to any subscribers.
           * @example
           * ```typescript
           * stream.publishMessage({ x: 42, y: 123 })
           *   .then((message) => {
           *     console.log('Stream publishMessage() successful, message SID:', message.sid);
           *   })
           *   .catch((error) => {
           *     console.error('Stream publishMessage() failed', error);
           *   });
           * ```
           */
          function() {
            var _publishMessage2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee4(data) {
              return _regeneratorRuntime__default["default"].wrap(function _callee4$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      this.ensureNotClosed();
                      return _context4.abrupt("return", this.syncStreamImpl.publishMessage(data));
                    case 2:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4, this);
            }));
            function publishMessage(_x3) {
              return _publishMessage2.apply(this, arguments);
            }
            return publishMessage;
          }()
        )
        /**
         * Update the time-to-live of the stream.
         * @param ttl Specifies the TTL in seconds after which the stream is subject to automatic deletion. The value 0 means infinity.
         * @return A promise that resolves after the TTL update was successful.
         * @example
         * ```typescript
         * stream.setTtl(3600)
         *   .then(() => {
         *     console.log('Stream setTtl() successful');
         *   })
         *   .catch((error) => {
         *     console.error('Stream setTtl() failed', error);
         *   });
         * ```
         */
      }, {
        key: "setTtl",
        value: function() {
          var _setTtl2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee5(ttl) {
            return _regeneratorRuntime__default["default"].wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    this.ensureNotClosed();
                    return _context5.abrupt("return", this.syncStreamImpl.setTtl(ttl));
                  case 2:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));
          function setTtl(_x4) {
            return _setTtl2.apply(this, arguments);
          }
          return setTtl;
        }()
        /**
         * Permanently delete this Stream.
         * @return A promise which resolves after the Stream is successfully deleted.
         * @example
         * ```typescript
         * stream.removeStream()
         *   .then(() => {
         *     console.log('Stream removeStream() successful');
         *   })
         *   .catch((error) => {
         *     console.error('Stream removeStream() failed', error);
         *   });
         * ```
         */
      }, {
        key: "removeStream",
        value: function() {
          var _removeStream2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee6() {
            return _regeneratorRuntime__default["default"].wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    this.ensureNotClosed();
                    return _context6.abrupt("return", this.syncStreamImpl.removeStream());
                  case 2:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, this);
          }));
          function removeStream() {
            return _removeStream2.apply(this, arguments);
          }
          return removeStream;
        }()
        /**
         * Conclude work with the stream instance and remove all event listeners attached to it.
         * Any subsequent operation on this object will be rejected with error.
         * Other local copies of this stream will continue operating and receiving events normally.
         * @example
         * ```typescript
         * stream.close();
         * ```
         */
      }, {
        key: "close",
        value: function close() {
          _get__default["default"](_getPrototypeOf__default["default"](SyncStream2.prototype), "close", this).call(this);
          this.syncStreamImpl.detach(this.listenerUuid);
        }
      }], [{
        key: "type",
        get: function get() {
          return SyncStreamImpl.type;
        }
      }]);
      return SyncStream2;
    }(Closeable);
    _defineProperty__default["default"](SyncStream, "messagePublished", "messagePublished");
    _defineProperty__default["default"](SyncStream, "removed", "removed");
    __decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.pureObject), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", Promise)], SyncStream.prototype, "publishMessage", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger), __metadata("design:type", Function), __metadata("design:paramtypes", [Number]), __metadata("design:returntype", Promise)], SyncStream.prototype, "setTtl", null);
    var ClientInfo = function ClientInfo2(version2) {
      _classCallCheck__default["default"](this, ClientInfo2);
      this.sdk = "js";
      this.sdkVer = version2;
      this.os = platform__namespace.os.family;
      this.osVer = platform__namespace.os.version;
      this.pl = platform__namespace.name;
      this.plVer = platform__namespace.version;
    };
    var EntitiesCache = function() {
      function EntitiesCache2() {
        _classCallCheck__default["default"](this, EntitiesCache2);
        this.names = /* @__PURE__ */ new Map();
        this.entities = /* @__PURE__ */ new Map();
      }
      _createClass__default["default"](EntitiesCache2, [{
        key: "store",
        value: function store(entity) {
          var stored = this.entities.get(entity.sid);
          if (stored) {
            return stored;
          }
          this.entities.set(entity.sid, entity);
          if (entity.uniqueName) {
            this.names.set(entity.type + "::" + entity.uniqueName, entity.sid);
          }
          return entity;
        }
      }, {
        key: "getResolved",
        value: function getResolved(id, type) {
          var resolvedSid = this.names.get(type + "::" + id);
          return resolvedSid ? this.entities.get(resolvedSid) : null;
        }
      }, {
        key: "get",
        value: function get(id, type) {
          return this.entities.get(id) || this.getResolved(id, type) || null;
        }
      }, {
        key: "remove",
        value: function remove(sid) {
          var cached = this.entities.get(sid);
          if (cached) {
            this.entities.delete(sid);
            if (cached.uniqueName) {
              this.names.delete(cached.type + "::" + cached.uniqueName);
            }
          }
        }
      }]);
      return EntitiesCache2;
    }();
    function _createSuper$1(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$1() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var InsightsItem = (
      /**
       * @internal
       */
      function InsightsItem2() {
        _classCallCheck__default["default"](this, InsightsItem2);
      }
    );
    var LiveQueryImpl = function(_SyncEntity) {
      _inherits__default["default"](LiveQueryImpl2, _SyncEntity);
      var _super = _createSuper$1(LiveQueryImpl2);
      function LiveQueryImpl2(descriptor, services, removalHandler, items) {
        var _this;
        _classCallCheck__default["default"](this, LiveQueryImpl2);
        _this = _super.call(this, services, removalHandler);
        _this.descriptor = descriptor;
        _this.cache = new Cache();
        if (items) {
          items.forEach(function(item) {
            _this.cache.store(item.key, {
              key: item.key,
              value: item.data
            }, item.revision);
          });
        }
        return _this;
      }
      _createClass__default["default"](LiveQueryImpl2, [{
        key: "sid",
        get: function get() {
          return this.descriptor.sid;
        }
        // private extension of SyncEntity
      }, {
        key: "uniqueName",
        get: function get() {
          return null;
        }
      }, {
        key: "type",
        get: function get() {
          return LiveQueryImpl2.type;
        }
      }, {
        key: "lastEventId",
        get: function get() {
          return this.descriptor.last_event_id;
        }
      }, {
        key: "indexName",
        get: function get() {
          return this.descriptor.indexName;
        }
      }, {
        key: "queryString",
        get: function get() {
          return this.descriptor.queryExpression;
        }
        // custom private props
      }, {
        key: "queryUri",
        get: function get() {
          return this.descriptor.queryUri;
        }
      }, {
        key: "liveQueryDescriptor",
        get: function get() {
          return this.descriptor;
        }
        // dummy stub from iface
      }, {
        key: "onRemoved",
        value: function onRemoved() {
        }
      }, {
        key: "getItems",
        value: function getItems() {
          var dataByKey = {};
          this.cache.forEach(function(key, item) {
            dataByKey[key] = item.value;
          });
          return dataByKey;
        }
        /**
         * @internal
         */
      }, {
        key: "_update",
        value: function _update(message, isStrictlyOrdered) {
          switch (message.type) {
            case "live_query_item_updated":
              this.handleItemMutated(message.item_key, message.item_data, message.item_revision);
              break;
            case "live_query_item_removed":
              this.handleItemRemoved(message.item_key, message.item_revision);
              break;
            case "live_query_updated":
              this.handleBatchUpdate(message.items);
              break;
          }
          if (isStrictlyOrdered) {
            this._advanceLastEventId(message.last_event_id);
          }
        }
      }, {
        key: "handleItemMutated",
        value: function handleItemMutated(key, value, revision) {
          if (this.shouldIgnoreEvent(key, revision)) {
            log$1.trace("Item ".concat(key, " update skipped, revision: ").concat(revision));
          } else {
            var newItem = {
              key,
              value
            };
            this.cache.store(key, newItem, revision);
            this.broadcastEventToListeners("itemUpdated", newItem);
          }
        }
      }, {
        key: "handleItemRemoved",
        value: function handleItemRemoved(key, revision) {
          var force = revision === null;
          if (this.shouldIgnoreEvent(key, revision)) {
            log$1.trace("Item ".concat(key, " delete skipped, revision: ").concat(revision));
          } else {
            this.cache.delete(key, revision, force);
            this.broadcastEventToListeners("itemRemoved", {
              key
            });
          }
        }
      }, {
        key: "handleBatchUpdate",
        value: function handleBatchUpdate(items) {
          var _this2 = this;
          var newItems = {};
          if (items != null) {
            items.forEach(function(item) {
              newItems[item.key] = {
                data: item.data,
                revision: item.revision
              };
            });
          }
          this.cache.forEach(function(key2, item) {
            var newItem = newItems[key2];
            if (newItem != null) {
              _this2.handleItemMutated(key2, newItem.data, newItem.revision);
            } else {
              _this2.handleItemRemoved(key2, null);
            }
            delete newItems[key2];
          });
          for (var key in newItems) {
            this.handleItemMutated(key, newItems[key].data, newItems[key].revision);
          }
        }
      }, {
        key: "shouldIgnoreEvent",
        value: function shouldIgnoreEvent(key, eventId) {
          return key != null && eventId != null && this.cache.isKnown(key, eventId);
        }
        /**
         * @internal
         */
      }, {
        key: "_advanceLastEventId",
        value: function _advanceLastEventId(eventId, revision) {
          if (this.lastEventId < eventId) {
            this.descriptor.last_event_id = eventId;
          }
        }
      }], [{
        key: "type",
        get: function get() {
          return "live_query";
        }
      }]);
      return LiveQueryImpl2;
    }(SyncEntity);
    function queryItems(_x) {
      return _queryItems.apply(this, arguments);
    }
    function _queryItems() {
      _queryItems = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee3(params) {
        var network, queryString, uri, type, liveQueryRequestBody, response;
        return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                network = params.network, queryString = params.queryString, uri = params.uri, type = params.type;
                if (!(queryString == null)) {
                  _context3.next = 3;
                  break;
                }
                throw new SyncError("Invalid query", 400, 54507);
              case 3:
                liveQueryRequestBody = {
                  query_string: queryString
                  // raw query string (like `key == "value" AND key2 != "value2"`)
                };
                if (type === LiveQuery.type) {
                  liveQueryRequestBody.type = type;
                }
                _context3.next = 7;
                return network.post(uri, liveQueryRequestBody, void 0, true);
              case 7:
                response = _context3.sent;
                return _context3.abrupt("return", response.body);
              case 9:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));
      return _queryItems.apply(this, arguments);
    }
    var LiveQuery = function(_Closeable) {
      _inherits__default["default"](LiveQuery2, _Closeable);
      var _super2 = _createSuper$1(LiveQuery2);
      function LiveQuery2(liveQueryImpl) {
        var _this3;
        _classCallCheck__default["default"](this, LiveQuery2);
        _this3 = _super2.call(this);
        _this3.liveQueryImpl = liveQueryImpl;
        _this3.liveQueryImpl.attach(_assertThisInitialized__default["default"](_this3));
        return _this3;
      }
      _createClass__default["default"](LiveQuery2, [{
        key: "type",
        get: function get() {
          return LiveQueryImpl.type;
        }
      }, {
        key: "lastEventId",
        get: function get() {
          return this.liveQueryImpl.lastEventId;
        }
        /**
         * The immutable identifier of this query object, assigned by the system.
         */
      }, {
        key: "sid",
        get: function get() {
          return this.liveQueryImpl.sid;
        }
      }, {
        key: "close",
        value: (
          /**
           * Closes this query instance and unsubscribes from further service events.
           * This will eventually stop the physical inflow of updates over the network, when all other instances of this query are closed as well.
           */
          function close() {
            _get__default["default"](_getPrototypeOf__default["default"](LiveQuery2.prototype), "close", this).call(this);
            this.liveQueryImpl.detach(this.listenerUuid);
          }
        )
        /**
         * @return A snapshot of items matching the current query expression.
         */
      }, {
        key: "getItems",
        value: function getItems() {
          this.ensureNotClosed();
          return this.liveQueryImpl.getItems();
        }
      }], [{
        key: "type",
        get: (
          // private props
          function get() {
            return LiveQueryImpl.type;
          }
        )
      }]);
      return LiveQuery2;
    }(Closeable);
    _defineProperty__default["default"](LiveQuery, "itemUpdated", "itemUpdated");
    _defineProperty__default["default"](LiveQuery, "itemRemoved", "itemRemoved");
    var InstantQuery = function(_EventEmitter) {
      _inherits__default["default"](InstantQuery2, _EventEmitter);
      var _super3 = _createSuper$1(InstantQuery2);
      function InstantQuery2(params) {
        var _this4;
        _classCallCheck__default["default"](this, InstantQuery2);
        _this4 = _super3.call(this);
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this4), "queryExpression", null);
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this4), "items", {});
        Object.assign(_assertThisInitialized__default["default"](_this4), params);
        _this4.updateIndexName(params.indexName);
        return _this4;
      }
      _createClass__default["default"](InstantQuery2, [{
        key: "type",
        get: function get() {
          return InstantQuery2.type;
        }
      }, {
        key: "search",
        value: (
          /**
           * Spawns a new search request. The result will be provided asynchronously via the {@link InstantQuery.searchResult}
           * event.
           * @param queryExpression A query expression to be executed against the given data index. For more information
           * on the syntax read {@link SyncClient.liveQuery}.
           * @return A promise that resolves when query result has been received.
           */
          function() {
            var _search = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee(queryExpression) {
              var _this5 = this;
              return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      this.items = {};
                      return _context.abrupt("return", queryItems({
                        network: this.network,
                        uri: this.queryUri,
                        queryString: queryExpression
                      }).then(function(response) {
                        _this5.queryExpression = queryExpression;
                        if (response.items) {
                          response.items.forEach(function(item) {
                            _this5.items[item.key] = item.data;
                          });
                        }
                        _this5.emit("searchResult", _this5.getItems());
                      }).catch(function(err) {
                        log$1.error("Error '".concat(err.message, "' while executing query '").concat(queryExpression, "'"));
                        _this5.queryExpression = null;
                        throw err;
                      }));
                    case 2:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, this);
            }));
            function search(_x2) {
              return _search.apply(this, arguments);
            }
            return search;
          }()
        )
        /**
         * Instantiates a LiveQuery object based on the last known query expression that was passed to the
         * {@link InstantQuery.search} method. This LiveQuery will start receiving updates with new results,
         * while current object can be still used to execute repetitive searches.
         * @return A promise which resolves when the LiveQuery object is ready.
         */
      }, {
        key: "subscribe",
        value: function() {
          var _subscribe = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee2() {
            return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    if (!(this.queryExpression == null)) {
                      _context2.next = 2;
                      break;
                    }
                    return _context2.abrupt("return", Promise.reject(new SyncError("Invalid query", 400, 54507)));
                  case 2:
                    return _context2.abrupt("return", this.liveQueryCreator(this.indexName, this.queryExpression));
                  case 3:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function subscribe() {
            return _subscribe.apply(this, arguments);
          }
          return subscribe;
        }()
        /**
         * @return A snapshot of items matching current query expression.
         */
      }, {
        key: "getItems",
        value: function getItems() {
          return this.items;
        }
        /**
         * Set new index name
         * @param indexName New index name to set
         */
      }, {
        key: "updateIndexName",
        value: function updateIndexName(indexName) {
          this.indexName = indexName;
          this.queryUri = this.generateQueryUri(this.indexName);
        }
      }, {
        key: "generateQueryUri",
        value: function generateQueryUri(indexName) {
          return new UriBuilder(this.insightsUri).pathSegment(indexName).pathSegment("Items").build();
        }
      }], [{
        key: "type",
        get: (
          // private props
          function get() {
            return "instant_query";
          }
        )
      }]);
      return InstantQuery2;
    }(EventEmitter);
    _defineProperty__default["default"](InstantQuery, "searchResult", "searchResult");
    __decorate([declarativeTypeValidator.validateTypesAsync("string"), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", Promise)], InstantQuery.prototype, "search", null);
    __decorate([declarativeTypeValidator.validateTypes(declarativeTypeValidator.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", void 0)], InstantQuery.prototype, "updateIndexName", null);
    var version = "3.1.0";
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        }
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty__default["default"](target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    var SYNC_PRODUCT_ID = "data_sync";
    var SDK_VERSION = version;
    function decompose(arg) {
      if (!arg) {
        return {
          mode: "create_new"
        };
      } else if (typeof arg === "string") {
        return {
          id: arg,
          mode: "open_or_create"
        };
      } else {
        var mode = arg.mode || (arg.id ? "open_or_create" : "create_new");
        return _objectSpread(_objectSpread({}, arg), {}, {
          mode
        });
      }
    }
    var SYNC_DOCUMENT_NOTIFICATION_TYPE = "com.twilio.rtd.cds.document";
    var SYNC_LIST_NOTIFICATION_TYPE = "com.twilio.rtd.cds.list";
    var SYNC_MAP_NOTIFICATION_TYPE = "com.twilio.rtd.cds.map";
    var SYNC_NOTIFICATION_TYPE = "twilio.sync.event";
    var Client = function(_EventEmitter) {
      _inherits__default["default"](Client2, _EventEmitter);
      var _super = _createSuper(Client2);
      function Client2(fpaToken) {
        var _this;
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        _classCallCheck__default["default"](this, Client2);
        _this = _super.call(this);
        if (!fpaToken) {
          throw new Error("Sync library needs a valid Twilio token to be passed");
        }
        if (options.hasOwnProperty("logLevel")) {
          log$1.setLevel(options.logLevel);
        } else {
          log$1.setLevel("silent");
        }
        var productId = options.productId = options.productId || SYNC_PRODUCT_ID;
        options.clientMetadata = options.clientMetadata || {};
        if (!options.clientMetadata.hasOwnProperty("type")) {
          options.clientMetadata.type = "sync";
        }
        if (!options.clientMetadata.hasOwnProperty("sdk")) {
          options.clientMetadata.sdk = "JS";
          options.clientMetadata.sdkv = SDK_VERSION;
        }
        var startTwilsock = !options.twilsockClient;
        if (!options.initRegistrations) {
          var initRegistration = new twilsock.InitRegistration(productId);
          Client2.populateInitRegistrations(initRegistration);
          options.initRegistrations = [initRegistration];
        }
        var twilsock$1 = options.twilsockClient = options.twilsockClient || new twilsock.Twilsock(fpaToken, productId, options);
        twilsock$1.on("tokenAboutToExpire", function(ttl) {
          return _this.emit("tokenAboutToExpire", ttl);
        });
        twilsock$1.on("tokenExpired", function() {
          return _this.emit("tokenExpired");
        });
        twilsock$1.on("connectionError", function(err) {
          return _this.emit("connectionError", err);
        });
        twilsock$1.on("stateChanged", function(state) {
          _this.emit("connectionStateChanged", state);
          _this.services.subscriptions.onConnectionStateChanged(state === "connected");
        });
        twilsock$1.on("message", function(messageType, payload) {
          return _this._routeMessage(messageType, payload);
        });
        var config = new Configuration(options);
        var network = new NetworkService(new ClientInfo(SDK_VERSION), config, twilsock$1);
        var storage = new SessionStorage(config);
        _this.services = {
          config,
          twilsock: twilsock$1,
          network,
          storage,
          router: _assertThisInitialized__default["default"](_this),
          subscriptions: null
        };
        _this.services.subscriptions = new Subscriptions(_this.services);
        _this.entities = new EntitiesCache();
        if (startTwilsock) {
          twilsock$1.connect();
        }
        return _this;
      }
      _createClass__default["default"](Client2, [{
        key: "_routeMessage",
        value: (
          /**
           * Entry point for all the incoming messages (Router).
           *
           * @param type Type of the incoming message
           * @param message Message to route
           * @internal
           */
          function _routeMessage(type, message) {
            log$1.trace("Notification type:", type, "content:", message);
            switch (type) {
              case SYNC_DOCUMENT_NOTIFICATION_TYPE:
              case SYNC_LIST_NOTIFICATION_TYPE:
              case SYNC_MAP_NOTIFICATION_TYPE:
                this.services.subscriptions.acceptMessage(message, false);
                break;
              case SYNC_NOTIFICATION_TYPE:
                this.services.subscriptions.acceptMessage(message, true);
                break;
            }
          }
        )
        /**
         * Subscribe for events (Router)
         *
         * @internal
         */
      }, {
        key: "_subscribe",
        value: function _subscribe(sid, entity) {
          this.services.subscriptions.add(sid, entity);
        }
        /**
         * Unsubscribe from events (Router)
         *
         * @internal
         */
      }, {
        key: "_unsubscribe",
        value: function _unsubscribe(sid) {
          this.services.subscriptions.remove(sid);
        }
        /**
         * Current version of the Sync client.
         */
      }, {
        key: "connectionState",
        get: (
          /**
           * Current service connection state.
           */
          function get() {
            return this.services.twilsock.state;
          }
        )
        /**
         * Returns a promise which resolves when library is correctly initialized
         * Or throws if initialization is impossible
         *
         * @internal
         */
      }, {
        key: "ensureReady",
        value: function() {
          var _ensureReady = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee() {
            var storageSettings;
            return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (this.services.config.sessionStorageEnabled) {
                      _context.next = 2;
                      break;
                    }
                    return _context.abrupt("return");
                  case 2:
                    _context.prev = 2;
                    _context.next = 5;
                    return this.services.twilsock.storageId();
                  case 5:
                    storageSettings = _context.sent;
                    this.services.storage.updateStorageId(storageSettings.id);
                    _context.next = 12;
                    break;
                  case 9:
                    _context.prev = 9;
                    _context.t0 = _context["catch"](2);
                    log$1.warn("Failed to initialize storage", _context.t0);
                  case 12:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[2, 9]]);
          }));
          function ensureReady() {
            return _ensureReady.apply(this, arguments);
          }
          return ensureReady;
        }()
      }, {
        key: "storeRootInSessionCache",
        value: function storeRootInSessionCache(type, id, value) {
          if (!this.services.config.sessionStorageEnabled || !id) {
            return;
          }
          var valueToStore = deepClone(value);
          if (type === SyncList.type || type === SyncMap.type) {
            valueToStore["last_event_id"] = null;
            delete valueToStore["items"];
          }
          this.services.storage.store(type, id, valueToStore);
        }
      }, {
        key: "readRootFromSessionCache",
        value: function readRootFromSessionCache(type, id) {
          if (!this.services.config.sessionStorageEnabled || !id) {
            return null;
          }
          return this.services.storage.read(type, id);
        }
      }, {
        key: "_get",
        value: function() {
          var _get2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee2(baseUri, id) {
            var optimistic, uri, response, _args2 = arguments;
            return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    optimistic = _args2.length > 2 && _args2[2] !== void 0 ? _args2[2] : false;
                    if (id) {
                      _context2.next = 3;
                      break;
                    }
                    throw new SyncError("Cannot get entity without id", 404);
                  case 3:
                    uri = new UriBuilder(baseUri).pathSegment(id).queryParam("Include", optimistic ? "items" : void 0).build();
                    _context2.next = 6;
                    return this.services.network.get(uri);
                  case 6:
                    response = _context2.sent;
                    return _context2.abrupt("return", response.body);
                  case 8:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function _get3(_x, _x2) {
            return _get2.apply(this, arguments);
          }
          return _get3;
        }()
      }, {
        key: "_createDocument",
        value: function _createDocument(id, data, ttl) {
          var requestBody = {
            unique_name: id,
            data: data || {}
          };
          if (ttl !== void 0) {
            requestBody.ttl = ttl;
          }
          return this.services.network.post(this.services.config.documentsUri, requestBody).then(function(response) {
            response.body.data = requestBody.data;
            return response.body;
          });
        }
      }, {
        key: "_getDocument",
        value: function() {
          var _getDocument2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee3(id) {
            return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    return _context3.abrupt("return", this.readRootFromSessionCache(SyncDocument.type, id) || this._get(this.services.config.documentsUri, id));
                  case 1:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));
          function _getDocument(_x3) {
            return _getDocument2.apply(this, arguments);
          }
          return _getDocument;
        }()
      }, {
        key: "_createList",
        value: function _createList(id, purpose, context, ttl) {
          var requestBody = {
            unique_name: id,
            purpose,
            context
          };
          if (ttl !== void 0) {
            requestBody.ttl = ttl;
          }
          return this.services.network.post(this.services.config.listsUri, requestBody).then(function(response) {
            return response.body;
          });
        }
      }, {
        key: "_getList",
        value: function() {
          var _getList2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee4(id) {
            return _regeneratorRuntime__default["default"].wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    return _context4.abrupt("return", this.readRootFromSessionCache(SyncList.type, id) || this._get(this.services.config.listsUri, id));
                  case 1:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));
          function _getList(_x4) {
            return _getList2.apply(this, arguments);
          }
          return _getList;
        }()
      }, {
        key: "_createMap",
        value: function _createMap(id, ttl) {
          var requestBody = {
            unique_name: id
          };
          if (ttl !== void 0) {
            requestBody.ttl = ttl;
          }
          return this.services.network.post(this.services.config.mapsUri, requestBody).then(function(response) {
            return response.body;
          });
        }
      }, {
        key: "_getMap",
        value: function() {
          var _getMap2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee5(id) {
            var optimistic, _args5 = arguments;
            return _regeneratorRuntime__default["default"].wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    optimistic = _args5.length > 1 && _args5[1] !== void 0 ? _args5[1] : false;
                    return _context5.abrupt("return", this.readRootFromSessionCache(SyncMap.type, id) || this._get(this.services.config.mapsUri, id, optimistic));
                  case 2:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));
          function _getMap(_x5) {
            return _getMap2.apply(this, arguments);
          }
          return _getMap;
        }()
      }, {
        key: "_getStream",
        value: function() {
          var _getStream2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee6(id) {
            return _regeneratorRuntime__default["default"].wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    return _context6.abrupt("return", this.readRootFromSessionCache(SyncStream.type, id) || this._get(this.services.config.streamsUri, id, false));
                  case 1:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, this);
          }));
          function _getStream(_x6) {
            return _getStream2.apply(this, arguments);
          }
          return _getStream;
        }()
      }, {
        key: "_createStream",
        value: function() {
          var _createStream2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee7(id, ttl) {
            var requestBody, response;
            return _regeneratorRuntime__default["default"].wrap(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    requestBody = {
                      unique_name: id
                    };
                    if (ttl !== void 0) {
                      requestBody.ttl = ttl;
                    }
                    _context7.next = 4;
                    return this.services.network.post(this.services.config.streamsUri, requestBody);
                  case 4:
                    response = _context7.sent;
                    return _context7.abrupt("return", response.body);
                  case 6:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee7, this);
          }));
          function _createStream(_x7, _x8) {
            return _createStream2.apply(this, arguments);
          }
          return _createStream;
        }()
      }, {
        key: "_getLiveQuery",
        value: function _getLiveQuery(sid) {
          return this.readRootFromSessionCache(LiveQuery.type, sid);
        }
      }, {
        key: "getCached",
        value: function getCached(id, type) {
          if (id) {
            return this.entities.get(id, type) || null;
          }
          return null;
        }
      }, {
        key: "removeFromCacheAndSession",
        value: function removeFromCacheAndSession(type, sid, uniqueName) {
          this.entities.remove(sid);
          if (this.services.config.sessionStorageEnabled) {
            this.services.storage.remove(type, sid, uniqueName);
          }
        }
        /**
         * Read or create a Sync document.
         * @param arg Could be any of the following:
         * * Unique name or SID identifying the Sync document - opens the document with the given identifier or creates one if it does not exist.
         * * none - creates a new document with a randomly assigned SID and no unique name.
         * * {@link OpenDocumentOptions} object for more granular control.
         * @return A promise which resolves after the document is successfully read (or created).
         * This promise may reject if the document could not be created or if this endpoint lacks the necessary permissions to access it.
         * @example
         * ```typescript
         * syncClient.document('MyDocument')
         *   .then((document) => {
         *     console.log('Successfully opened a document. SID:', document.sid);
         *     document.on('updated', (event) => {
         *       console.log('Received an "updated" event: ', event);
         *     });
         *   })
         *   .catch((error) => {
         *     console.error('Unexpected error', error);
         *   });
         * ```
         */
      }, {
        key: "document",
        value: function() {
          var _document = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee8(arg) {
            var _this2 = this;
            var opts, docDescriptor, docFromInMemoryCache, syncDocumentImpl;
            return _regeneratorRuntime__default["default"].wrap(function _callee8$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    _context8.next = 2;
                    return this.ensureReady();
                  case 2:
                    opts = decompose(arg);
                    if (!(opts.mode === "create_new")) {
                      _context8.next = 9;
                      break;
                    }
                    _context8.next = 6;
                    return this._createDocument(opts.id, opts.data, opts.ttl);
                  case 6:
                    docDescriptor = _context8.sent;
                    _context8.next = 39;
                    break;
                  case 9:
                    docFromInMemoryCache = this.getCached(opts.id, SyncDocument.type);
                    if (!docFromInMemoryCache) {
                      _context8.next = 14;
                      break;
                    }
                    return _context8.abrupt("return", new SyncDocument(docFromInMemoryCache));
                  case 14:
                    _context8.prev = 14;
                    _context8.next = 17;
                    return this._getDocument(opts.id);
                  case 17:
                    docDescriptor = _context8.sent;
                    _context8.next = 39;
                    break;
                  case 20:
                    _context8.prev = 20;
                    _context8.t0 = _context8["catch"](14);
                    if (!(_context8.t0.status !== 404 || opts.mode === "open_existing")) {
                      _context8.next = 26;
                      break;
                    }
                    throw _context8.t0;
                  case 26:
                    _context8.prev = 26;
                    _context8.next = 29;
                    return this._createDocument(opts.id, opts.data, opts.ttl);
                  case 29:
                    docDescriptor = _context8.sent;
                    _context8.next = 39;
                    break;
                  case 32:
                    _context8.prev = 32;
                    _context8.t1 = _context8["catch"](26);
                    if (!(_context8.t1.status === 409)) {
                      _context8.next = 38;
                      break;
                    }
                    return _context8.abrupt("return", this.document(arg));
                  case 38:
                    throw _context8.t1;
                  case 39:
                    this.storeRootInSessionCache(SyncDocument.type, opts.id, docDescriptor);
                    syncDocumentImpl = new SyncDocumentImpl(this.services, docDescriptor, function(type, sid, uniqueName) {
                      return _this2.removeFromCacheAndSession(type, sid, uniqueName);
                    });
                    syncDocumentImpl = this.entities.store(syncDocumentImpl);
                    return _context8.abrupt("return", new SyncDocument(syncDocumentImpl));
                  case 43:
                  case "end":
                    return _context8.stop();
                }
              }
            }, _callee8, this, [[14, 20], [26, 32]]);
          }));
          function document2(_x9) {
            return _document.apply(this, arguments);
          }
          return document2;
        }()
        /**
         * Read or create a Sync map.
         * @param arg Could be any of the following:
         * * Unique name or SID identifying the Sync map - opens the map with the given identifier or creates one if it does not exist.
         * * none - creates a new map with a randomly assigned SID and no unique name.
         * * {@link OpenMapOptions} object for more granular control.
         * @return A promise which resolves after the map is successfully read (or created).
         * This promise may reject if the map could not be created or if this endpoint lacks the necessary permissions to access it.
         * @example
         * ```typescript
         * syncClient.map('MyMap')
         *   .then((map) => {
         *     console.log('Successfully opened a map. SID:', map.sid);
         *     map.on('itemUpdated', (event) => {
         *       console.log('Received an "itemUpdated" event:', event);
         *     });
         *   })
         *   .catch((error) => {
         *     console.error('Unexpected error', error);
         *   });
         * ```
         */
      }, {
        key: "map",
        value: function() {
          var _map = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee9(arg) {
            var _this3 = this;
            var opts, mapDescriptor, mapFromInMemoryCache, syncMapImpl;
            return _regeneratorRuntime__default["default"].wrap(function _callee9$(_context9) {
              while (1) {
                switch (_context9.prev = _context9.next) {
                  case 0:
                    _context9.next = 2;
                    return this.ensureReady();
                  case 2:
                    opts = decompose(arg);
                    if (!(opts.mode === "create_new")) {
                      _context9.next = 9;
                      break;
                    }
                    _context9.next = 6;
                    return this._createMap(opts.id, opts.ttl);
                  case 6:
                    mapDescriptor = _context9.sent;
                    _context9.next = 39;
                    break;
                  case 9:
                    mapFromInMemoryCache = this.getCached(opts.id, SyncMap.type);
                    if (!mapFromInMemoryCache) {
                      _context9.next = 14;
                      break;
                    }
                    return _context9.abrupt("return", new SyncMap(mapFromInMemoryCache));
                  case 14:
                    _context9.prev = 14;
                    _context9.next = 17;
                    return this._getMap(opts.id, opts.includeItems);
                  case 17:
                    mapDescriptor = _context9.sent;
                    _context9.next = 39;
                    break;
                  case 20:
                    _context9.prev = 20;
                    _context9.t0 = _context9["catch"](14);
                    if (!(_context9.t0.status !== 404 || opts.mode === "open_existing")) {
                      _context9.next = 26;
                      break;
                    }
                    throw _context9.t0;
                  case 26:
                    _context9.prev = 26;
                    _context9.next = 29;
                    return this._createMap(opts.id, opts.ttl);
                  case 29:
                    mapDescriptor = _context9.sent;
                    _context9.next = 39;
                    break;
                  case 32:
                    _context9.prev = 32;
                    _context9.t1 = _context9["catch"](26);
                    if (!(_context9.t1.status === 409)) {
                      _context9.next = 38;
                      break;
                    }
                    return _context9.abrupt("return", this.map(arg));
                  case 38:
                    throw _context9.t1;
                  case 39:
                    this.storeRootInSessionCache(SyncMap.type, opts.id, mapDescriptor);
                    syncMapImpl = new SyncMapImpl(this.services, mapDescriptor, function(type, sid, uniqueName) {
                      return _this3.removeFromCacheAndSession(type, sid, uniqueName);
                    });
                    syncMapImpl = this.entities.store(syncMapImpl);
                    return _context9.abrupt("return", new SyncMap(syncMapImpl));
                  case 43:
                  case "end":
                    return _context9.stop();
                }
              }
            }, _callee9, this, [[14, 20], [26, 32]]);
          }));
          function map(_x10) {
            return _map.apply(this, arguments);
          }
          return map;
        }()
        /**
         * Read or create a Sync list.
         * @param arg Could be any of the following:
         * * Unique name or SID identifying a Sync list - opens the list with the given identifier or creates one if it does not exist.
         * * none - creates a new list with a randomly assigned SID and no unique name.
         * * {@link OpenListOptions} object for more granular control.
         * @return A promise which resolves after the list is successfully read (or created).
         * This promise may reject if the list could not be created or if this endpoint lacks the necessary permissions to access it.
         * @example
         * ```typescript
         * syncClient.list('MyList')
         *   .then((list) => {
         *     console.log('Successfully opened a List. SID:', list.sid);
         *     list.on('itemAdded', (event) => {
         *       console.log('Received an "itemAdded" event:', event);
         *     });
         *   })
         *   .catch((error) => {
         *     console.error('Unexpected error', error);
         *   });
         * ```
         */
      }, {
        key: "list",
        value: function() {
          var _list = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee10(arg) {
            var _this4 = this;
            var opts, listDescriptor, listFromInMemoryCache, syncListImpl;
            return _regeneratorRuntime__default["default"].wrap(function _callee10$(_context10) {
              while (1) {
                switch (_context10.prev = _context10.next) {
                  case 0:
                    _context10.next = 2;
                    return this.ensureReady();
                  case 2:
                    opts = decompose(arg);
                    if (!(opts.mode === "create_new")) {
                      _context10.next = 9;
                      break;
                    }
                    _context10.next = 6;
                    return this._createList(opts.id, opts.purpose, opts.context, opts.ttl);
                  case 6:
                    listDescriptor = _context10.sent;
                    _context10.next = 39;
                    break;
                  case 9:
                    listFromInMemoryCache = this.getCached(opts.id, SyncList.type);
                    if (!listFromInMemoryCache) {
                      _context10.next = 14;
                      break;
                    }
                    return _context10.abrupt("return", new SyncList(listFromInMemoryCache));
                  case 14:
                    _context10.prev = 14;
                    _context10.next = 17;
                    return this._getList(opts.id);
                  case 17:
                    listDescriptor = _context10.sent;
                    _context10.next = 39;
                    break;
                  case 20:
                    _context10.prev = 20;
                    _context10.t0 = _context10["catch"](14);
                    if (!(_context10.t0.status !== 404 || opts.mode === "open_existing")) {
                      _context10.next = 26;
                      break;
                    }
                    throw _context10.t0;
                  case 26:
                    _context10.prev = 26;
                    _context10.next = 29;
                    return this._createList(opts.id, opts.purpose, opts.context, opts.ttl);
                  case 29:
                    listDescriptor = _context10.sent;
                    _context10.next = 39;
                    break;
                  case 32:
                    _context10.prev = 32;
                    _context10.t1 = _context10["catch"](26);
                    if (!(_context10.t1.status === 409)) {
                      _context10.next = 38;
                      break;
                    }
                    return _context10.abrupt("return", this.list(arg));
                  case 38:
                    throw _context10.t1;
                  case 39:
                    this.storeRootInSessionCache(SyncList.type, opts.id, listDescriptor);
                    syncListImpl = new SyncListImpl(this.services, listDescriptor, function(type, sid, uniqueName) {
                      return _this4.removeFromCacheAndSession(type, sid, uniqueName);
                    });
                    syncListImpl = this.entities.store(syncListImpl);
                    return _context10.abrupt("return", new SyncList(syncListImpl));
                  case 43:
                  case "end":
                    return _context10.stop();
                }
              }
            }, _callee10, this, [[14, 20], [26, 32]]);
          }));
          function list(_x11) {
            return _list.apply(this, arguments);
          }
          return list;
        }()
        /**
         * Read or create a Sync message stream.
         * @param arg Could be any of the following:
         * * Unique name or SID identifying a stream - opens the stream with the given identifier or creates one if it does not exist.
         * * none - creates a new stream with a randomly assigned SID and no unique name.
         * * {@link OpenStreamOptions} object for more granular control.
         * @return A promise which resolves after the stream is successfully read (or created).
         * The flow of messages will begin imminently (but not necessarily immediately) upon resolution.
         * This promise may reject if the stream could not be created or if this endpoint lacks the necessary permissions to access it.
         * @example
         * ```typescript
         * syncClient.stream('MyStream')
         *   .then((stream) => {
         *     console.log('Successfully opened a message stream. SID:', stream.sid);
         *     stream.on('messagePublished', (event) => {
         *       console.log('Received a "messagePublished" event:', event);
         *     });
         *   })
         *   .catch((error) => {
         *     console.error('Unexpected error', error);
         *   });
         * ```
         */
      }, {
        key: "stream",
        value: function() {
          var _stream = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee11(arg) {
            var _this5 = this;
            var opts, streamDescriptor, streamFromInMemoryCache, streamRemovalHandler, syncStreamImpl;
            return _regeneratorRuntime__default["default"].wrap(function _callee11$(_context11) {
              while (1) {
                switch (_context11.prev = _context11.next) {
                  case 0:
                    _context11.next = 2;
                    return this.ensureReady();
                  case 2:
                    opts = decompose(arg);
                    if (!(opts.mode === "create_new")) {
                      _context11.next = 9;
                      break;
                    }
                    _context11.next = 6;
                    return this._createStream(opts.id, opts.ttl);
                  case 6:
                    streamDescriptor = _context11.sent;
                    _context11.next = 39;
                    break;
                  case 9:
                    streamFromInMemoryCache = this.getCached(opts.id, SyncStream.type);
                    if (!streamFromInMemoryCache) {
                      _context11.next = 14;
                      break;
                    }
                    return _context11.abrupt("return", new SyncStream(streamFromInMemoryCache));
                  case 14:
                    _context11.prev = 14;
                    _context11.next = 17;
                    return this._getStream(opts.id);
                  case 17:
                    streamDescriptor = _context11.sent;
                    _context11.next = 39;
                    break;
                  case 20:
                    _context11.prev = 20;
                    _context11.t0 = _context11["catch"](14);
                    if (!(_context11.t0.status !== 404 || opts.mode === "open_existing")) {
                      _context11.next = 26;
                      break;
                    }
                    throw _context11.t0;
                  case 26:
                    _context11.prev = 26;
                    _context11.next = 29;
                    return this._createStream(opts.id, opts.ttl);
                  case 29:
                    streamDescriptor = _context11.sent;
                    _context11.next = 39;
                    break;
                  case 32:
                    _context11.prev = 32;
                    _context11.t1 = _context11["catch"](26);
                    if (!(_context11.t1.status === 409)) {
                      _context11.next = 38;
                      break;
                    }
                    return _context11.abrupt("return", this.stream(arg));
                  case 38:
                    throw _context11.t1;
                  case 39:
                    this.storeRootInSessionCache(SyncStream.type, opts.id, streamDescriptor);
                    streamRemovalHandler = function streamRemovalHandler2(type, sid, uniqueName) {
                      return _this5.removeFromCacheAndSession(type, sid, uniqueName);
                    };
                    syncStreamImpl = new SyncStreamImpl(this.services, streamDescriptor, streamRemovalHandler);
                    syncStreamImpl = this.entities.store(syncStreamImpl);
                    return _context11.abrupt("return", new SyncStream(syncStreamImpl));
                  case 44:
                  case "end":
                    return _context11.stop();
                }
              }
            }, _callee11, this, [[14, 20], [26, 32]]);
          }));
          function stream(_x12) {
            return _stream.apply(this, arguments);
          }
          return stream;
        }()
        /**
         * Gracefully shuts the Sync client down.
         */
      }, {
        key: "shutdown",
        value: function() {
          var _shutdown = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee12() {
            return _regeneratorRuntime__default["default"].wrap(function _callee12$(_context12) {
              while (1) {
                switch (_context12.prev = _context12.next) {
                  case 0:
                    _context12.next = 2;
                    return this.services.subscriptions.shutdown();
                  case 2:
                    _context12.next = 4;
                    return this.services.twilsock.disconnect();
                  case 4:
                  case "end":
                    return _context12.stop();
                }
              }
            }, _callee12, this);
          }));
          function shutdown() {
            return _shutdown.apply(this, arguments);
          }
          return shutdown;
        }()
        /**
         * Set the authentication token.
         * @param token New token to set.
         */
      }, {
        key: "updateToken",
        value: function() {
          var _updateToken = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee13(token) {
            return _regeneratorRuntime__default["default"].wrap(function _callee13$(_context13) {
              while (1) {
                switch (_context13.prev = _context13.next) {
                  case 0:
                    return _context13.abrupt("return", this.services.twilsock.updateToken(token).catch(function(error) {
                      var _error$reply;
                      var status = error === null || error === void 0 ? void 0 : (_error$reply = error.reply) === null || _error$reply === void 0 ? void 0 : _error$reply.status;
                      if ((status === null || status === void 0 ? void 0 : status.code) === 401 && (status === null || status === void 0 ? void 0 : status.status) === "UNAUTHORIZED") {
                        throw new SyncError("Updated token was rejected by server", 400, 51130);
                      }
                      throw error;
                    }));
                  case 1:
                  case "end":
                    return _context13.stop();
                }
              }
            }, _callee13, this);
          }));
          function updateToken(_x13) {
            return _updateToken.apply(this, arguments);
          }
          return updateToken;
        }()
        /**
         * For Flex customers only. Establishes a long-running query against Flex data wherein the returned
         * result set is updated whenever new (or updated) records match the given expression. Updated results
         * are presented row-by-row according to the lifetime of the returned LiveQuery object.
         *
         * @param indexName Must specify one of the Flex data classes for which Live Queries are available.
         * @param queryExpression A query expression to be executed against the given data index.
         * Please review the [Live Query Language](https://www.twilio.com/docs/sync/live-query)
         * page for Sync client limits and a full list of operators currently supported in query expressions.
         *
         * @return A promise that resolves when the query has been successfully executed.
         * @example
         * ```typescript
         * syncClient.liveQuery('tr-worker', 'data.attributes.worker_name == "Bob"')
         *   .then((args) => {
         *      console.log('Subscribed to live data updates for worker Bob');
         *      const items = args.getItems();
         *      Object.entries(items).forEach(([key, value]) => {
         *        console.log('Search result item key:', key);
         *        console.log('Search result item value:', value);
         *      });
         *   })
         *   .catch((err) => {
         *      console.error('Error when subscribing to live updates for worker Bob', err);
         *   });
         * ```
         */
      }, {
        key: "liveQuery",
        value: function() {
          var _liveQuery = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee14(indexName, queryExpression) {
            var _this6 = this;
            var queryUri, response, liveQueryImpl, descriptor, liveQueryRemovalHandler;
            return _regeneratorRuntime__default["default"].wrap(function _callee14$(_context14) {
              while (1) {
                switch (_context14.prev = _context14.next) {
                  case 0:
                    _context14.next = 2;
                    return this.ensureReady();
                  case 2:
                    queryUri = new UriBuilder(this.services.config.insightsUri).pathSegment(indexName).pathSegment("Items").build();
                    _context14.next = 5;
                    return queryItems({
                      network: this.services.network,
                      uri: queryUri,
                      queryString: queryExpression,
                      type: LiveQuery.type
                    });
                  case 5:
                    response = _context14.sent;
                    liveQueryImpl = this.getCached(response.query_id, LiveQuery.type);
                    if (!liveQueryImpl) {
                      descriptor = this._getLiveQuery(response.query_id);
                      if (!descriptor) {
                        descriptor = {
                          indexName,
                          queryExpression,
                          sid: response.query_id,
                          queryUri,
                          last_event_id: response.last_event_id
                        };
                      }
                      liveQueryRemovalHandler = function liveQueryRemovalHandler2(type, sid, uniqueName) {
                        return _this6.removeFromCacheAndSession(type, sid, uniqueName);
                      };
                      liveQueryImpl = new LiveQueryImpl(descriptor, this.services, liveQueryRemovalHandler, response.items);
                    }
                    this.storeRootInSessionCache(LiveQuery.type, response.query_id, liveQueryImpl.liveQueryDescriptor);
                    liveQueryImpl = this.entities.store(liveQueryImpl);
                    return _context14.abrupt("return", new LiveQuery(liveQueryImpl));
                  case 11:
                  case "end":
                    return _context14.stop();
                }
              }
            }, _callee14, this);
          }));
          function liveQuery(_x14, _x15) {
            return _liveQuery.apply(this, arguments);
          }
          return liveQuery;
        }()
        /**
         * For Flex customers only. Creates a query object that can be used to issue one-time queries repeatedly
         * against the target index.
         *
         * @param indexName Must specify one of the Flex data classes for which live queries are available.
         * @return A promise which resolves after the instance of InstantQuery is successfully created.
         * @example
         * ```typescript
         * syncClient.instantQuery('tr-worker')
         *   .then((q) => {
         *     q.on('searchResult', (items) => {
         *       Object.entries(items).forEach(([key, value]) => {
         *         console.log('Search result item key:', key);
         *         console.log('Search result item value:', value);
         *       });
         *     });
         *   });
         * ```
         */
      }, {
        key: "instantQuery",
        value: function() {
          var _instantQuery = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee15(indexName) {
            var _this7 = this;
            var liveQueryCreator;
            return _regeneratorRuntime__default["default"].wrap(function _callee15$(_context15) {
              while (1) {
                switch (_context15.prev = _context15.next) {
                  case 0:
                    _context15.next = 2;
                    return this.ensureReady();
                  case 2:
                    liveQueryCreator = function liveQueryCreator2(indexName2, queryExpression) {
                      return _this7.liveQuery(indexName2, queryExpression);
                    };
                    return _context15.abrupt("return", new InstantQuery({
                      indexName,
                      network: this.services.network,
                      insightsUri: this.services.config.insightsUri,
                      liveQueryCreator
                    }));
                  case 4:
                  case "end":
                    return _context15.stop();
                }
              }
            }, _callee15, this);
          }));
          function instantQuery(_x16) {
            return _instantQuery.apply(this, arguments);
          }
          return instantQuery;
        }()
      }], [{
        key: "populateInitRegistrations",
        value: function populateInitRegistrations(reg) {
          reg.populateInitRegistrations([SYNC_NOTIFICATION_TYPE, SYNC_DOCUMENT_NOTIFICATION_TYPE, SYNC_LIST_NOTIFICATION_TYPE, SYNC_MAP_NOTIFICATION_TYPE]);
        }
      }, {
        key: "version",
        get: function get() {
          return SDK_VERSION;
        }
      }]);
      return Client2;
    }(EventEmitter);
    _defineProperty__default["default"](Client, "connectionStateChanged", "connectionStateChanged");
    _defineProperty__default["default"](Client, "connectionError", "connectionError");
    _defineProperty__default["default"](Client, "tokenAboutToExpire", "tokenAboutToExpire");
    _defineProperty__default["default"](Client, "tokenExpired", "tokenExpired");
    __decorate([declarativeTypeValidator.validateTypesAsync(["undefined", "string", declarativeTypeValidator.objectSchema("open document options", {
      id: ["string", "undefined"],
      mode: [declarativeTypeValidator.literal("open_or_create", "open_existing", "create_new"), "undefined"],
      ttl: [declarativeTypeValidator.nonNegativeInteger, "undefined"],
      data: [declarativeTypeValidator.pureObject, "undefined", declarativeTypeValidator.literal(null)]
    })]), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", Promise)], Client.prototype, "document", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(["undefined", "string", declarativeTypeValidator.objectSchema("open map options", {
      id: ["string", "undefined"],
      mode: [declarativeTypeValidator.literal("open_or_create", "open_existing", "create_new"), "undefined"],
      ttl: [declarativeTypeValidator.nonNegativeInteger, "undefined"],
      data: [declarativeTypeValidator.pureObject, "undefined", declarativeTypeValidator.literal(null)],
      includeItems: ["boolean", "undefined"]
    })]), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", Promise)], Client.prototype, "map", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(["undefined", "string", declarativeTypeValidator.objectSchema("open list options", {
      id: ["string", "undefined"],
      mode: [declarativeTypeValidator.literal("open_or_create", "open_existing", "create_new"), "undefined"],
      ttl: [declarativeTypeValidator.nonNegativeInteger, "undefined"],
      data: [declarativeTypeValidator.pureObject, "undefined", declarativeTypeValidator.literal(null)],
      purpose: ["string", "undefined"],
      context: [declarativeTypeValidator.pureObject, "undefined"],
      includeItems: ["boolean", "undefined"]
    })]), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", Promise)], Client.prototype, "list", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(["undefined", "string", declarativeTypeValidator.objectSchema("open stream options", {
      id: ["string", "undefined"],
      mode: [declarativeTypeValidator.literal("open_or_create", "open_existing", "create_new"), "undefined"],
      ttl: [declarativeTypeValidator.nonNegativeInteger, "undefined"],
      data: [declarativeTypeValidator.pureObject, "undefined", declarativeTypeValidator.literal(null)]
    })]), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", Promise)], Client.prototype, "stream", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", Promise)], Client.prototype, "updateToken", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString, "string"), __metadata("design:type", Function), __metadata("design:paramtypes", [String, String]), __metadata("design:returntype", Promise)], Client.prototype, "liveQuery", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", Promise)], Client.prototype, "instantQuery", null);
    exports.Client = Client;
    exports.InsightsItem = InsightsItem;
    exports.InstantQuery = InstantQuery;
    exports.LiveQuery = LiveQuery;
    exports.Paginator = Paginator;
    exports.SyncClient = Client;
    exports.SyncDocument = SyncDocument;
    exports.SyncList = SyncList;
    exports.SyncListItem = SyncListItem;
    exports.SyncMap = SyncMap;
    exports.SyncMapItem = SyncMapItem;
    exports.SyncStream = SyncStream;
  }
});

// node_modules/core-js/internals/is-regexp.js
var require_is_regexp = __commonJS({
  "node_modules/core-js/internals/is-regexp.js"(exports, module) {
    "use strict";
    var isObject = require_is_object();
    var classof = require_classof_raw();
    var wellKnownSymbol = require_well_known_symbol();
    var MATCH = wellKnownSymbol("match");
    module.exports = function(it) {
      var isRegExp;
      return isObject(it) && ((isRegExp = it[MATCH]) !== void 0 ? !!isRegExp : classof(it) === "RegExp");
    };
  }
});

// node_modules/core-js/internals/not-a-regexp.js
var require_not_a_regexp = __commonJS({
  "node_modules/core-js/internals/not-a-regexp.js"(exports, module) {
    "use strict";
    var isRegExp = require_is_regexp();
    var $TypeError = TypeError;
    module.exports = function(it) {
      if (isRegExp(it)) {
        throw new $TypeError("The method doesn't accept regular expressions");
      }
      return it;
    };
  }
});

// node_modules/core-js/internals/correct-is-regexp-logic.js
var require_correct_is_regexp_logic = __commonJS({
  "node_modules/core-js/internals/correct-is-regexp-logic.js"(exports, module) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    var MATCH = wellKnownSymbol("match");
    module.exports = function(METHOD_NAME) {
      var regexp = /./;
      try {
        "/./"[METHOD_NAME](regexp);
      } catch (error1) {
        try {
          regexp[MATCH] = false;
          return "/./"[METHOD_NAME](regexp);
        } catch (error2) {
        }
      }
      return false;
    };
  }
});

// node_modules/core-js/modules/es.string.starts-with.js
var require_es_string_starts_with = __commonJS({
  "node_modules/core-js/modules/es.string.starts-with.js"() {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this_clause();
    var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
    var toLength = require_to_length();
    var toString = require_to_string();
    var notARegExp = require_not_a_regexp();
    var requireObjectCoercible = require_require_object_coercible();
    var correctIsRegExpLogic = require_correct_is_regexp_logic();
    var IS_PURE = require_is_pure();
    var stringSlice = uncurryThis("".slice);
    var min = Math.min;
    var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic("startsWith");
    var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function() {
      var descriptor = getOwnPropertyDescriptor(String.prototype, "startsWith");
      return descriptor && !descriptor.writable;
    }();
    $({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
      startsWith: function startsWith(searchString) {
        var that = toString(requireObjectCoercible(this));
        notARegExp(searchString);
        var index = toLength(min(arguments.length > 1 ? arguments[1] : void 0, that.length));
        var search = toString(searchString);
        return stringSlice(that, index, index + search.length) === search;
      }
    });
  }
});

// node_modules/core-js/internals/url-constructor-detection.js
var require_url_constructor_detection = __commonJS({
  "node_modules/core-js/internals/url-constructor-detection.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    var wellKnownSymbol = require_well_known_symbol();
    var DESCRIPTORS = require_descriptors();
    var IS_PURE = require_is_pure();
    var ITERATOR = wellKnownSymbol("iterator");
    module.exports = !fails(function() {
      var url = new URL("b?a=1&b=2&c=3", "https://a");
      var params = url.searchParams;
      var params2 = new URLSearchParams("a=1&a=2&b=3");
      var result = "";
      url.pathname = "c%20d";
      params.forEach(function(value, key) {
        params["delete"]("b");
        result += key + value;
      });
      params2["delete"]("a", 2);
      params2["delete"]("b", void 0);
      return IS_PURE && (!url.toJSON || !params2.has("a", 1) || params2.has("a", 2) || !params2.has("a", void 0) || params2.has("b")) || !params.size && (IS_PURE || !DESCRIPTORS) || !params.sort || url.href !== "https://a/c%20d?a=1&c=3" || params.get("c") !== "3" || String(new URLSearchParams("?a=1")) !== "a=1" || !params[ITERATOR] || new URL("https://a@b").username !== "a" || new URLSearchParams(new URLSearchParams("a=b")).get("a") !== "b" || new URL("https://ÑÐµÑÑ").host !== "xn--e1aybc" || new URL("https://a#Ð±").hash !== "#%D0%B1" || result !== "a1c3" || new URL("https://x", void 0).host !== "x";
    });
  }
});

// node_modules/core-js/internals/string-punycode-to-ascii.js
var require_string_punycode_to_ascii = __commonJS({
  "node_modules/core-js/internals/string-punycode-to-ascii.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var maxInt = 2147483647;
    var base = 36;
    var tMin = 1;
    var tMax = 26;
    var skew = 38;
    var damp = 700;
    var initialBias = 72;
    var initialN = 128;
    var delimiter = "-";
    var regexNonASCII = /[^\0-\u007E]/;
    var regexSeparators = /[.\u3002\uFF0E\uFF61]/g;
    var OVERFLOW_ERROR = "Overflow: input needs wider integers to process";
    var baseMinusTMin = base - tMin;
    var $RangeError = RangeError;
    var exec = uncurryThis(regexSeparators.exec);
    var floor = Math.floor;
    var fromCharCode = String.fromCharCode;
    var charCodeAt = uncurryThis("".charCodeAt);
    var join = uncurryThis([].join);
    var push = uncurryThis([].push);
    var replace = uncurryThis("".replace);
    var split = uncurryThis("".split);
    var toLowerCase = uncurryThis("".toLowerCase);
    var ucs2decode = function(string) {
      var output = [];
      var counter = 0;
      var length = string.length;
      while (counter < length) {
        var value = charCodeAt(string, counter++);
        if (value >= 55296 && value <= 56319 && counter < length) {
          var extra = charCodeAt(string, counter++);
          if ((extra & 64512) === 56320) {
            push(output, ((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            push(output, value);
            counter--;
          }
        } else {
          push(output, value);
        }
      }
      return output;
    };
    var digitToBasic = function(digit) {
      return digit + 22 + 75 * (digit < 26);
    };
    var adapt = function(delta, numPoints, firstTime) {
      var k = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      while (delta > baseMinusTMin * tMax >> 1) {
        delta = floor(delta / baseMinusTMin);
        k += base;
      }
      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    };
    var encode = function(input) {
      var output = [];
      input = ucs2decode(input);
      var inputLength = input.length;
      var n = initialN;
      var delta = 0;
      var bias = initialBias;
      var i, currentValue;
      for (i = 0; i < input.length; i++) {
        currentValue = input[i];
        if (currentValue < 128) {
          push(output, fromCharCode(currentValue));
        }
      }
      var basicLength = output.length;
      var handledCPCount = basicLength;
      if (basicLength) {
        push(output, delimiter);
      }
      while (handledCPCount < inputLength) {
        var m = maxInt;
        for (i = 0; i < input.length; i++) {
          currentValue = input[i];
          if (currentValue >= n && currentValue < m) {
            m = currentValue;
          }
        }
        var handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
          throw new $RangeError(OVERFLOW_ERROR);
        }
        delta += (m - n) * handledCPCountPlusOne;
        n = m;
        for (i = 0; i < input.length; i++) {
          currentValue = input[i];
          if (currentValue < n && ++delta > maxInt) {
            throw new $RangeError(OVERFLOW_ERROR);
          }
          if (currentValue === n) {
            var q = delta;
            var k = base;
            while (true) {
              var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
              if (q < t) break;
              var qMinusT = q - t;
              var baseMinusT = base - t;
              push(output, fromCharCode(digitToBasic(t + qMinusT % baseMinusT)));
              q = floor(qMinusT / baseMinusT);
              k += base;
            }
            push(output, fromCharCode(digitToBasic(q)));
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
            delta = 0;
            handledCPCount++;
          }
        }
        delta++;
        n++;
      }
      return join(output, "");
    };
    module.exports = function(input) {
      var encoded = [];
      var labels = split(replace(toLowerCase(input), regexSeparators, "."), ".");
      var i, label;
      for (i = 0; i < labels.length; i++) {
        label = labels[i];
        push(encoded, exec(regexNonASCII, label) ? "xn--" + encode(label) : label);
      }
      return join(encoded, ".");
    };
  }
});

// node_modules/core-js/modules/es.string.from-code-point.js
var require_es_string_from_code_point = __commonJS({
  "node_modules/core-js/modules/es.string.from-code-point.js"() {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this();
    var toAbsoluteIndex = require_to_absolute_index();
    var $RangeError = RangeError;
    var fromCharCode = String.fromCharCode;
    var $fromCodePoint = String.fromCodePoint;
    var join = uncurryThis([].join);
    var INCORRECT_LENGTH = !!$fromCodePoint && $fromCodePoint.length !== 1;
    $({ target: "String", stat: true, arity: 1, forced: INCORRECT_LENGTH }, {
      // eslint-disable-next-line no-unused-vars -- required for `.length`
      fromCodePoint: function fromCodePoint(x) {
        var elements = [];
        var length = arguments.length;
        var i = 0;
        var code;
        while (length > i) {
          code = +arguments[i++];
          if (toAbsoluteIndex(code, 1114111) !== code) throw new $RangeError(code + " is not a valid code point");
          elements[i] = code < 65536 ? fromCharCode(code) : fromCharCode(((code -= 65536) >> 10) + 55296, code % 1024 + 56320);
        }
        return join(elements, "");
      }
    });
  }
});

// node_modules/core-js/modules/web.url-search-params.constructor.js
var require_web_url_search_params_constructor = __commonJS({
  "node_modules/core-js/modules/web.url-search-params.constructor.js"(exports, module) {
    "use strict";
    require_es_array_iterator();
    require_es_string_from_code_point();
    var $ = require_export();
    var globalThis2 = require_global_this();
    var safeGetBuiltIn = require_safe_get_built_in();
    var getBuiltIn = require_get_built_in();
    var call = require_function_call();
    var uncurryThis = require_function_uncurry_this();
    var DESCRIPTORS = require_descriptors();
    var USE_NATIVE_URL = require_url_constructor_detection();
    var defineBuiltIn = require_define_built_in();
    var defineBuiltInAccessor = require_define_built_in_accessor();
    var defineBuiltIns = require_define_built_ins();
    var setToStringTag = require_set_to_string_tag();
    var createIteratorConstructor = require_iterator_create_constructor();
    var InternalStateModule = require_internal_state();
    var anInstance = require_an_instance();
    var isCallable = require_is_callable();
    var hasOwn = require_has_own_property();
    var bind = require_function_bind_context();
    var classof = require_classof();
    var anObject = require_an_object();
    var isObject = require_is_object();
    var $toString = require_to_string();
    var create = require_object_create();
    var createPropertyDescriptor = require_create_property_descriptor();
    var getIterator = require_get_iterator();
    var getIteratorMethod = require_get_iterator_method();
    var createIterResultObject = require_create_iter_result_object();
    var validateArgumentsLength = require_validate_arguments_length();
    var wellKnownSymbol = require_well_known_symbol();
    var arraySort = require_array_sort();
    var ITERATOR = wellKnownSymbol("iterator");
    var URL_SEARCH_PARAMS = "URLSearchParams";
    var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + "Iterator";
    var setInternalState = InternalStateModule.set;
    var getInternalParamsState = InternalStateModule.getterFor(URL_SEARCH_PARAMS);
    var getInternalIteratorState = InternalStateModule.getterFor(URL_SEARCH_PARAMS_ITERATOR);
    var nativeFetch = safeGetBuiltIn("fetch");
    var NativeRequest = safeGetBuiltIn("Request");
    var Headers = safeGetBuiltIn("Headers");
    var RequestPrototype = NativeRequest && NativeRequest.prototype;
    var HeadersPrototype = Headers && Headers.prototype;
    var TypeError2 = globalThis2.TypeError;
    var encodeURIComponent2 = globalThis2.encodeURIComponent;
    var fromCharCode = String.fromCharCode;
    var fromCodePoint = getBuiltIn("String", "fromCodePoint");
    var $parseInt = parseInt;
    var charAt = uncurryThis("".charAt);
    var join = uncurryThis([].join);
    var push = uncurryThis([].push);
    var replace = uncurryThis("".replace);
    var shift = uncurryThis([].shift);
    var splice = uncurryThis([].splice);
    var split = uncurryThis("".split);
    var stringSlice = uncurryThis("".slice);
    var exec = uncurryThis(/./.exec);
    var plus = /\+/g;
    var FALLBACK_REPLACER = "ï¿½";
    var VALID_HEX = /^[0-9a-f]+$/i;
    var parseHexOctet = function(string, start) {
      var substr = stringSlice(string, start, start + 2);
      if (!exec(VALID_HEX, substr)) return NaN;
      return $parseInt(substr, 16);
    };
    var getLeadingOnes = function(octet) {
      var count = 0;
      for (var mask = 128; mask > 0 && (octet & mask) !== 0; mask >>= 1) {
        count++;
      }
      return count;
    };
    var utf8Decode = function(octets) {
      var codePoint = null;
      switch (octets.length) {
        case 1:
          codePoint = octets[0];
          break;
        case 2:
          codePoint = (octets[0] & 31) << 6 | octets[1] & 63;
          break;
        case 3:
          codePoint = (octets[0] & 15) << 12 | (octets[1] & 63) << 6 | octets[2] & 63;
          break;
        case 4:
          codePoint = (octets[0] & 7) << 18 | (octets[1] & 63) << 12 | (octets[2] & 63) << 6 | octets[3] & 63;
          break;
      }
      return codePoint > 1114111 ? null : codePoint;
    };
    var decode = function(input) {
      input = replace(input, plus, " ");
      var length = input.length;
      var result = "";
      var i = 0;
      while (i < length) {
        var decodedChar = charAt(input, i);
        if (decodedChar === "%") {
          if (charAt(input, i + 1) === "%" || i + 3 > length) {
            result += "%";
            i++;
            continue;
          }
          var octet = parseHexOctet(input, i + 1);
          if (octet !== octet) {
            result += decodedChar;
            i++;
            continue;
          }
          i += 2;
          var byteSequenceLength = getLeadingOnes(octet);
          if (byteSequenceLength === 0) {
            decodedChar = fromCharCode(octet);
          } else {
            if (byteSequenceLength === 1 || byteSequenceLength > 4) {
              result += FALLBACK_REPLACER;
              i++;
              continue;
            }
            var octets = [octet];
            var sequenceIndex = 1;
            while (sequenceIndex < byteSequenceLength) {
              i++;
              if (i + 3 > length || charAt(input, i) !== "%") break;
              var nextByte = parseHexOctet(input, i + 1);
              if (nextByte !== nextByte) {
                i += 3;
                break;
              }
              if (nextByte > 191 || nextByte < 128) break;
              push(octets, nextByte);
              i += 2;
              sequenceIndex++;
            }
            if (octets.length !== byteSequenceLength) {
              result += FALLBACK_REPLACER;
              continue;
            }
            var codePoint = utf8Decode(octets);
            if (codePoint === null) {
              result += FALLBACK_REPLACER;
            } else {
              decodedChar = fromCodePoint(codePoint);
            }
          }
        }
        result += decodedChar;
        i++;
      }
      return result;
    };
    var find = /[!'()~]|%20/g;
    var replacements = {
      "!": "%21",
      "'": "%27",
      "(": "%28",
      ")": "%29",
      "~": "%7E",
      "%20": "+"
    };
    var replacer = function(match) {
      return replacements[match];
    };
    var serialize = function(it) {
      return replace(encodeURIComponent2(it), find, replacer);
    };
    var URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {
      setInternalState(this, {
        type: URL_SEARCH_PARAMS_ITERATOR,
        target: getInternalParamsState(params).entries,
        index: 0,
        kind
      });
    }, URL_SEARCH_PARAMS, function next() {
      var state = getInternalIteratorState(this);
      var target = state.target;
      var index = state.index++;
      if (!target || index >= target.length) {
        state.target = null;
        return createIterResultObject(void 0, true);
      }
      var entry = target[index];
      switch (state.kind) {
        case "keys":
          return createIterResultObject(entry.key, false);
        case "values":
          return createIterResultObject(entry.value, false);
      }
      return createIterResultObject([entry.key, entry.value], false);
    }, true);
    var URLSearchParamsState = function(init) {
      this.entries = [];
      this.url = null;
      if (init !== void 0) {
        if (isObject(init)) this.parseObject(init);
        else this.parseQuery(typeof init == "string" ? charAt(init, 0) === "?" ? stringSlice(init, 1) : init : $toString(init));
      }
    };
    URLSearchParamsState.prototype = {
      type: URL_SEARCH_PARAMS,
      bindURL: function(url) {
        this.url = url;
        this.update();
      },
      parseObject: function(object) {
        var entries = this.entries;
        var iteratorMethod = getIteratorMethod(object);
        var iterator, next, step, entryIterator, entryNext, first, second;
        if (iteratorMethod) {
          iterator = getIterator(object, iteratorMethod);
          next = iterator.next;
          while (!(step = call(next, iterator)).done) {
            entryIterator = getIterator(anObject(step.value));
            entryNext = entryIterator.next;
            if ((first = call(entryNext, entryIterator)).done || (second = call(entryNext, entryIterator)).done || !call(entryNext, entryIterator).done) throw new TypeError2("Expected sequence with length 2");
            push(entries, { key: $toString(first.value), value: $toString(second.value) });
          }
        } else for (var key in object) if (hasOwn(object, key)) {
          push(entries, { key, value: $toString(object[key]) });
        }
      },
      parseQuery: function(query) {
        if (query) {
          var entries = this.entries;
          var attributes = split(query, "&");
          var index = 0;
          var attribute, entry;
          while (index < attributes.length) {
            attribute = attributes[index++];
            if (attribute.length) {
              entry = split(attribute, "=");
              push(entries, {
                key: decode(shift(entry)),
                value: decode(join(entry, "="))
              });
            }
          }
        }
      },
      serialize: function() {
        var entries = this.entries;
        var result = [];
        var index = 0;
        var entry;
        while (index < entries.length) {
          entry = entries[index++];
          push(result, serialize(entry.key) + "=" + serialize(entry.value));
        }
        return join(result, "&");
      },
      update: function() {
        this.entries.length = 0;
        this.parseQuery(this.url.query);
      },
      updateURL: function() {
        if (this.url) this.url.update();
      }
    };
    var URLSearchParamsConstructor = function URLSearchParams2() {
      anInstance(this, URLSearchParamsPrototype);
      var init = arguments.length > 0 ? arguments[0] : void 0;
      var state = setInternalState(this, new URLSearchParamsState(init));
      if (!DESCRIPTORS) this.size = state.entries.length;
    };
    var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;
    defineBuiltIns(URLSearchParamsPrototype, {
      // `URLSearchParams.prototype.append` method
      // https://url.spec.whatwg.org/#dom-urlsearchparams-append
      append: function append(name, value) {
        var state = getInternalParamsState(this);
        validateArgumentsLength(arguments.length, 2);
        push(state.entries, { key: $toString(name), value: $toString(value) });
        if (!DESCRIPTORS) this.length++;
        state.updateURL();
      },
      // `URLSearchParams.prototype.delete` method
      // https://url.spec.whatwg.org/#dom-urlsearchparams-delete
      "delete": function(name) {
        var state = getInternalParamsState(this);
        var length = validateArgumentsLength(arguments.length, 1);
        var entries = state.entries;
        var key = $toString(name);
        var $value = length < 2 ? void 0 : arguments[1];
        var value = $value === void 0 ? $value : $toString($value);
        var index = 0;
        while (index < entries.length) {
          var entry = entries[index];
          if (entry.key === key && (value === void 0 || entry.value === value)) {
            splice(entries, index, 1);
            if (value !== void 0) break;
          } else index++;
        }
        if (!DESCRIPTORS) this.size = entries.length;
        state.updateURL();
      },
      // `URLSearchParams.prototype.get` method
      // https://url.spec.whatwg.org/#dom-urlsearchparams-get
      get: function get(name) {
        var entries = getInternalParamsState(this).entries;
        validateArgumentsLength(arguments.length, 1);
        var key = $toString(name);
        var index = 0;
        for (; index < entries.length; index++) {
          if (entries[index].key === key) return entries[index].value;
        }
        return null;
      },
      // `URLSearchParams.prototype.getAll` method
      // https://url.spec.whatwg.org/#dom-urlsearchparams-getall
      getAll: function getAll(name) {
        var entries = getInternalParamsState(this).entries;
        validateArgumentsLength(arguments.length, 1);
        var key = $toString(name);
        var result = [];
        var index = 0;
        for (; index < entries.length; index++) {
          if (entries[index].key === key) push(result, entries[index].value);
        }
        return result;
      },
      // `URLSearchParams.prototype.has` method
      // https://url.spec.whatwg.org/#dom-urlsearchparams-has
      has: function has(name) {
        var entries = getInternalParamsState(this).entries;
        var length = validateArgumentsLength(arguments.length, 1);
        var key = $toString(name);
        var $value = length < 2 ? void 0 : arguments[1];
        var value = $value === void 0 ? $value : $toString($value);
        var index = 0;
        while (index < entries.length) {
          var entry = entries[index++];
          if (entry.key === key && (value === void 0 || entry.value === value)) return true;
        }
        return false;
      },
      // `URLSearchParams.prototype.set` method
      // https://url.spec.whatwg.org/#dom-urlsearchparams-set
      set: function set(name, value) {
        var state = getInternalParamsState(this);
        validateArgumentsLength(arguments.length, 1);
        var entries = state.entries;
        var found = false;
        var key = $toString(name);
        var val = $toString(value);
        var index = 0;
        var entry;
        for (; index < entries.length; index++) {
          entry = entries[index];
          if (entry.key === key) {
            if (found) splice(entries, index--, 1);
            else {
              found = true;
              entry.value = val;
            }
          }
        }
        if (!found) push(entries, { key, value: val });
        if (!DESCRIPTORS) this.size = entries.length;
        state.updateURL();
      },
      // `URLSearchParams.prototype.sort` method
      // https://url.spec.whatwg.org/#dom-urlsearchparams-sort
      sort: function sort() {
        var state = getInternalParamsState(this);
        arraySort(state.entries, function(a, b) {
          return a.key > b.key ? 1 : -1;
        });
        state.updateURL();
      },
      // `URLSearchParams.prototype.forEach` method
      forEach: function forEach(callback) {
        var entries = getInternalParamsState(this).entries;
        var boundFunction = bind(callback, arguments.length > 1 ? arguments[1] : void 0);
        var index = 0;
        var entry;
        while (index < entries.length) {
          entry = entries[index++];
          boundFunction(entry.value, entry.key, this);
        }
      },
      // `URLSearchParams.prototype.keys` method
      keys: function keys() {
        return new URLSearchParamsIterator(this, "keys");
      },
      // `URLSearchParams.prototype.values` method
      values: function values() {
        return new URLSearchParamsIterator(this, "values");
      },
      // `URLSearchParams.prototype.entries` method
      entries: function entries() {
        return new URLSearchParamsIterator(this, "entries");
      }
    }, { enumerable: true });
    defineBuiltIn(URLSearchParamsPrototype, ITERATOR, URLSearchParamsPrototype.entries, { name: "entries" });
    defineBuiltIn(URLSearchParamsPrototype, "toString", function toString() {
      return getInternalParamsState(this).serialize();
    }, { enumerable: true });
    if (DESCRIPTORS) defineBuiltInAccessor(URLSearchParamsPrototype, "size", {
      get: function size() {
        return getInternalParamsState(this).entries.length;
      },
      configurable: true,
      enumerable: true
    });
    setToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);
    $({ global: true, constructor: true, forced: !USE_NATIVE_URL }, {
      URLSearchParams: URLSearchParamsConstructor
    });
    if (!USE_NATIVE_URL && isCallable(Headers)) {
      headersHas = uncurryThis(HeadersPrototype.has);
      headersSet = uncurryThis(HeadersPrototype.set);
      wrapRequestOptions = function(init) {
        if (isObject(init)) {
          var body = init.body;
          var headers;
          if (classof(body) === URL_SEARCH_PARAMS) {
            headers = init.headers ? new Headers(init.headers) : new Headers();
            if (!headersHas(headers, "content-type")) {
              headersSet(headers, "content-type", "application/x-www-form-urlencoded;charset=UTF-8");
            }
            return create(init, {
              body: createPropertyDescriptor(0, $toString(body)),
              headers: createPropertyDescriptor(0, headers)
            });
          }
        }
        return init;
      };
      if (isCallable(nativeFetch)) {
        $({ global: true, enumerable: true, dontCallGetSet: true, forced: true }, {
          fetch: function fetch(input) {
            return nativeFetch(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
          }
        });
      }
      if (isCallable(NativeRequest)) {
        RequestConstructor = function Request(input) {
          anInstance(this, RequestPrototype);
          return new NativeRequest(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
        };
        RequestPrototype.constructor = RequestConstructor;
        RequestConstructor.prototype = RequestPrototype;
        $({ global: true, constructor: true, dontCallGetSet: true, forced: true }, {
          Request: RequestConstructor
        });
      }
    }
    var headersHas;
    var headersSet;
    var wrapRequestOptions;
    var RequestConstructor;
    module.exports = {
      URLSearchParams: URLSearchParamsConstructor,
      getState: getInternalParamsState
    };
  }
});

// node_modules/core-js/modules/web.url.constructor.js
var require_web_url_constructor = __commonJS({
  "node_modules/core-js/modules/web.url.constructor.js"() {
    "use strict";
    require_es_string_iterator();
    var $ = require_export();
    var DESCRIPTORS = require_descriptors();
    var USE_NATIVE_URL = require_url_constructor_detection();
    var globalThis2 = require_global_this();
    var bind = require_function_bind_context();
    var uncurryThis = require_function_uncurry_this();
    var defineBuiltIn = require_define_built_in();
    var defineBuiltInAccessor = require_define_built_in_accessor();
    var anInstance = require_an_instance();
    var hasOwn = require_has_own_property();
    var assign = require_object_assign();
    var arrayFrom = require_array_from();
    var arraySlice = require_array_slice();
    var codeAt = require_string_multibyte().codeAt;
    var toASCII = require_string_punycode_to_ascii();
    var $toString = require_to_string();
    var setToStringTag = require_set_to_string_tag();
    var validateArgumentsLength = require_validate_arguments_length();
    var URLSearchParamsModule = require_web_url_search_params_constructor();
    var InternalStateModule = require_internal_state();
    var setInternalState = InternalStateModule.set;
    var getInternalURLState = InternalStateModule.getterFor("URL");
    var URLSearchParams2 = URLSearchParamsModule.URLSearchParams;
    var getInternalSearchParamsState = URLSearchParamsModule.getState;
    var NativeURL = globalThis2.URL;
    var TypeError2 = globalThis2.TypeError;
    var parseInt2 = globalThis2.parseInt;
    var floor = Math.floor;
    var pow = Math.pow;
    var charAt = uncurryThis("".charAt);
    var exec = uncurryThis(/./.exec);
    var join = uncurryThis([].join);
    var numberToString = uncurryThis(1.1.toString);
    var pop = uncurryThis([].pop);
    var push = uncurryThis([].push);
    var replace = uncurryThis("".replace);
    var shift = uncurryThis([].shift);
    var split = uncurryThis("".split);
    var stringSlice = uncurryThis("".slice);
    var toLowerCase = uncurryThis("".toLowerCase);
    var unshift = uncurryThis([].unshift);
    var INVALID_AUTHORITY = "Invalid authority";
    var INVALID_SCHEME = "Invalid scheme";
    var INVALID_HOST = "Invalid host";
    var INVALID_PORT = "Invalid port";
    var ALPHA = /[a-z]/i;
    var ALPHANUMERIC = /[\d+-.a-z]/i;
    var DIGIT = /\d/;
    var HEX_START = /^0x/i;
    var OCT = /^[0-7]+$/;
    var DEC = /^\d+$/;
    var HEX = /^[\da-f]+$/i;
    var FORBIDDEN_HOST_CODE_POINT = /[\0\t\n\r #%/:<>?@[\\\]^|]/;
    var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\0\t\n\r #/:<>?@[\\\]^|]/;
    var LEADING_C0_CONTROL_OR_SPACE = /^[\u0000-\u0020]+/;
    var TRAILING_C0_CONTROL_OR_SPACE = /(^|[^\u0000-\u0020])[\u0000-\u0020]+$/;
    var TAB_AND_NEW_LINE = /[\t\n\r]/g;
    var EOF;
    var parseIPv4 = function(input) {
      var parts = split(input, ".");
      var partsLength, numbers2, index, part, radix, number, ipv4;
      if (parts.length && parts[parts.length - 1] === "") {
        parts.length--;
      }
      partsLength = parts.length;
      if (partsLength > 4) return input;
      numbers2 = [];
      for (index = 0; index < partsLength; index++) {
        part = parts[index];
        if (part === "") return input;
        radix = 10;
        if (part.length > 1 && charAt(part, 0) === "0") {
          radix = exec(HEX_START, part) ? 16 : 8;
          part = stringSlice(part, radix === 8 ? 1 : 2);
        }
        if (part === "") {
          number = 0;
        } else {
          if (!exec(radix === 10 ? DEC : radix === 8 ? OCT : HEX, part)) return input;
          number = parseInt2(part, radix);
        }
        push(numbers2, number);
      }
      for (index = 0; index < partsLength; index++) {
        number = numbers2[index];
        if (index === partsLength - 1) {
          if (number >= pow(256, 5 - partsLength)) return null;
        } else if (number > 255) return null;
      }
      ipv4 = pop(numbers2);
      for (index = 0; index < numbers2.length; index++) {
        ipv4 += numbers2[index] * pow(256, 3 - index);
      }
      return ipv4;
    };
    var parseIPv6 = function(input) {
      var address = [0, 0, 0, 0, 0, 0, 0, 0];
      var pieceIndex = 0;
      var compress = null;
      var pointer = 0;
      var value, length, numbersSeen, ipv4Piece, number, swaps, swap;
      var chr = function() {
        return charAt(input, pointer);
      };
      if (chr() === ":") {
        if (charAt(input, 1) !== ":") return;
        pointer += 2;
        pieceIndex++;
        compress = pieceIndex;
      }
      while (chr()) {
        if (pieceIndex === 8) return;
        if (chr() === ":") {
          if (compress !== null) return;
          pointer++;
          pieceIndex++;
          compress = pieceIndex;
          continue;
        }
        value = length = 0;
        while (length < 4 && exec(HEX, chr())) {
          value = value * 16 + parseInt2(chr(), 16);
          pointer++;
          length++;
        }
        if (chr() === ".") {
          if (length === 0) return;
          pointer -= length;
          if (pieceIndex > 6) return;
          numbersSeen = 0;
          while (chr()) {
            ipv4Piece = null;
            if (numbersSeen > 0) {
              if (chr() === "." && numbersSeen < 4) pointer++;
              else return;
            }
            if (!exec(DIGIT, chr())) return;
            while (exec(DIGIT, chr())) {
              number = parseInt2(chr(), 10);
              if (ipv4Piece === null) ipv4Piece = number;
              else if (ipv4Piece === 0) return;
              else ipv4Piece = ipv4Piece * 10 + number;
              if (ipv4Piece > 255) return;
              pointer++;
            }
            address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
            numbersSeen++;
            if (numbersSeen === 2 || numbersSeen === 4) pieceIndex++;
          }
          if (numbersSeen !== 4) return;
          break;
        } else if (chr() === ":") {
          pointer++;
          if (!chr()) return;
        } else if (chr()) return;
        address[pieceIndex++] = value;
      }
      if (compress !== null) {
        swaps = pieceIndex - compress;
        pieceIndex = 7;
        while (pieceIndex !== 0 && swaps > 0) {
          swap = address[pieceIndex];
          address[pieceIndex--] = address[compress + swaps - 1];
          address[compress + --swaps] = swap;
        }
      } else if (pieceIndex !== 8) return;
      return address;
    };
    var findLongestZeroSequence = function(ipv6) {
      var maxIndex = null;
      var maxLength = 1;
      var currStart = null;
      var currLength = 0;
      var index = 0;
      for (; index < 8; index++) {
        if (ipv6[index] !== 0) {
          if (currLength > maxLength) {
            maxIndex = currStart;
            maxLength = currLength;
          }
          currStart = null;
          currLength = 0;
        } else {
          if (currStart === null) currStart = index;
          ++currLength;
        }
      }
      return currLength > maxLength ? currStart : maxIndex;
    };
    var serializeHost = function(host) {
      var result, index, compress, ignore0;
      if (typeof host == "number") {
        result = [];
        for (index = 0; index < 4; index++) {
          unshift(result, host % 256);
          host = floor(host / 256);
        }
        return join(result, ".");
      }
      if (typeof host == "object") {
        result = "";
        compress = findLongestZeroSequence(host);
        for (index = 0; index < 8; index++) {
          if (ignore0 && host[index] === 0) continue;
          if (ignore0) ignore0 = false;
          if (compress === index) {
            result += index ? ":" : "::";
            ignore0 = true;
          } else {
            result += numberToString(host[index], 16);
            if (index < 7) result += ":";
          }
        }
        return "[" + result + "]";
      }
      return host;
    };
    var C0ControlPercentEncodeSet = {};
    var fragmentPercentEncodeSet = assign({}, C0ControlPercentEncodeSet, {
      " ": 1,
      '"': 1,
      "<": 1,
      ">": 1,
      "`": 1
    });
    var pathPercentEncodeSet = assign({}, fragmentPercentEncodeSet, {
      "#": 1,
      "?": 1,
      "{": 1,
      "}": 1
    });
    var userinfoPercentEncodeSet = assign({}, pathPercentEncodeSet, {
      "/": 1,
      ":": 1,
      ";": 1,
      "=": 1,
      "@": 1,
      "[": 1,
      "\\": 1,
      "]": 1,
      "^": 1,
      "|": 1
    });
    var percentEncode = function(chr, set) {
      var code = codeAt(chr, 0);
      return code > 32 && code < 127 && !hasOwn(set, chr) ? chr : encodeURIComponent(chr);
    };
    var specialSchemes = {
      ftp: 21,
      file: null,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var isWindowsDriveLetter = function(string, normalized) {
      var second;
      return string.length === 2 && exec(ALPHA, charAt(string, 0)) && ((second = charAt(string, 1)) === ":" || !normalized && second === "|");
    };
    var startsWithWindowsDriveLetter = function(string) {
      var third;
      return string.length > 1 && isWindowsDriveLetter(stringSlice(string, 0, 2)) && (string.length === 2 || ((third = charAt(string, 2)) === "/" || third === "\\" || third === "?" || third === "#"));
    };
    var isSingleDot = function(segment) {
      return segment === "." || toLowerCase(segment) === "%2e";
    };
    var isDoubleDot = function(segment) {
      segment = toLowerCase(segment);
      return segment === ".." || segment === "%2e." || segment === ".%2e" || segment === "%2e%2e";
    };
    var SCHEME_START = {};
    var SCHEME = {};
    var NO_SCHEME = {};
    var SPECIAL_RELATIVE_OR_AUTHORITY = {};
    var PATH_OR_AUTHORITY = {};
    var RELATIVE = {};
    var RELATIVE_SLASH = {};
    var SPECIAL_AUTHORITY_SLASHES = {};
    var SPECIAL_AUTHORITY_IGNORE_SLASHES = {};
    var AUTHORITY = {};
    var HOST = {};
    var HOSTNAME = {};
    var PORT = {};
    var FILE = {};
    var FILE_SLASH = {};
    var FILE_HOST = {};
    var PATH_START = {};
    var PATH = {};
    var CANNOT_BE_A_BASE_URL_PATH = {};
    var QUERY = {};
    var FRAGMENT = {};
    var URLState = function(url, isBase, base) {
      var urlString = $toString(url);
      var baseState, failure, searchParams;
      if (isBase) {
        failure = this.parse(urlString);
        if (failure) throw new TypeError2(failure);
        this.searchParams = null;
      } else {
        if (base !== void 0) baseState = new URLState(base, true);
        failure = this.parse(urlString, null, baseState);
        if (failure) throw new TypeError2(failure);
        searchParams = getInternalSearchParamsState(new URLSearchParams2());
        searchParams.bindURL(this);
        this.searchParams = searchParams;
      }
    };
    URLState.prototype = {
      type: "URL",
      // https://url.spec.whatwg.org/#url-parsing
      // eslint-disable-next-line max-statements -- TODO
      parse: function(input, stateOverride, base) {
        var url = this;
        var state = stateOverride || SCHEME_START;
        var pointer = 0;
        var buffer = "";
        var seenAt = false;
        var seenBracket = false;
        var seenPasswordToken = false;
        var codePoints, chr, bufferCodePoints, failure;
        input = $toString(input);
        if (!stateOverride) {
          url.scheme = "";
          url.username = "";
          url.password = "";
          url.host = null;
          url.port = null;
          url.path = [];
          url.query = null;
          url.fragment = null;
          url.cannotBeABaseURL = false;
          input = replace(input, LEADING_C0_CONTROL_OR_SPACE, "");
          input = replace(input, TRAILING_C0_CONTROL_OR_SPACE, "$1");
        }
        input = replace(input, TAB_AND_NEW_LINE, "");
        codePoints = arrayFrom(input);
        while (pointer <= codePoints.length) {
          chr = codePoints[pointer];
          switch (state) {
            case SCHEME_START:
              if (chr && exec(ALPHA, chr)) {
                buffer += toLowerCase(chr);
                state = SCHEME;
              } else if (!stateOverride) {
                state = NO_SCHEME;
                continue;
              } else return INVALID_SCHEME;
              break;
            case SCHEME:
              if (chr && (exec(ALPHANUMERIC, chr) || chr === "+" || chr === "-" || chr === ".")) {
                buffer += toLowerCase(chr);
              } else if (chr === ":") {
                if (stateOverride && (url.isSpecial() !== hasOwn(specialSchemes, buffer) || buffer === "file" && (url.includesCredentials() || url.port !== null) || url.scheme === "file" && !url.host)) return;
                url.scheme = buffer;
                if (stateOverride) {
                  if (url.isSpecial() && specialSchemes[url.scheme] === url.port) url.port = null;
                  return;
                }
                buffer = "";
                if (url.scheme === "file") {
                  state = FILE;
                } else if (url.isSpecial() && base && base.scheme === url.scheme) {
                  state = SPECIAL_RELATIVE_OR_AUTHORITY;
                } else if (url.isSpecial()) {
                  state = SPECIAL_AUTHORITY_SLASHES;
                } else if (codePoints[pointer + 1] === "/") {
                  state = PATH_OR_AUTHORITY;
                  pointer++;
                } else {
                  url.cannotBeABaseURL = true;
                  push(url.path, "");
                  state = CANNOT_BE_A_BASE_URL_PATH;
                }
              } else if (!stateOverride) {
                buffer = "";
                state = NO_SCHEME;
                pointer = 0;
                continue;
              } else return INVALID_SCHEME;
              break;
            case NO_SCHEME:
              if (!base || base.cannotBeABaseURL && chr !== "#") return INVALID_SCHEME;
              if (base.cannotBeABaseURL && chr === "#") {
                url.scheme = base.scheme;
                url.path = arraySlice(base.path);
                url.query = base.query;
                url.fragment = "";
                url.cannotBeABaseURL = true;
                state = FRAGMENT;
                break;
              }
              state = base.scheme === "file" ? FILE : RELATIVE;
              continue;
            case SPECIAL_RELATIVE_OR_AUTHORITY:
              if (chr === "/" && codePoints[pointer + 1] === "/") {
                state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
                pointer++;
              } else {
                state = RELATIVE;
                continue;
              }
              break;
            case PATH_OR_AUTHORITY:
              if (chr === "/") {
                state = AUTHORITY;
                break;
              } else {
                state = PATH;
                continue;
              }
            case RELATIVE:
              url.scheme = base.scheme;
              if (chr === EOF) {
                url.username = base.username;
                url.password = base.password;
                url.host = base.host;
                url.port = base.port;
                url.path = arraySlice(base.path);
                url.query = base.query;
              } else if (chr === "/" || chr === "\\" && url.isSpecial()) {
                state = RELATIVE_SLASH;
              } else if (chr === "?") {
                url.username = base.username;
                url.password = base.password;
                url.host = base.host;
                url.port = base.port;
                url.path = arraySlice(base.path);
                url.query = "";
                state = QUERY;
              } else if (chr === "#") {
                url.username = base.username;
                url.password = base.password;
                url.host = base.host;
                url.port = base.port;
                url.path = arraySlice(base.path);
                url.query = base.query;
                url.fragment = "";
                state = FRAGMENT;
              } else {
                url.username = base.username;
                url.password = base.password;
                url.host = base.host;
                url.port = base.port;
                url.path = arraySlice(base.path);
                url.path.length--;
                state = PATH;
                continue;
              }
              break;
            case RELATIVE_SLASH:
              if (url.isSpecial() && (chr === "/" || chr === "\\")) {
                state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
              } else if (chr === "/") {
                state = AUTHORITY;
              } else {
                url.username = base.username;
                url.password = base.password;
                url.host = base.host;
                url.port = base.port;
                state = PATH;
                continue;
              }
              break;
            case SPECIAL_AUTHORITY_SLASHES:
              state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
              if (chr !== "/" || charAt(buffer, pointer + 1) !== "/") continue;
              pointer++;
              break;
            case SPECIAL_AUTHORITY_IGNORE_SLASHES:
              if (chr !== "/" && chr !== "\\") {
                state = AUTHORITY;
                continue;
              }
              break;
            case AUTHORITY:
              if (chr === "@") {
                if (seenAt) buffer = "%40" + buffer;
                seenAt = true;
                bufferCodePoints = arrayFrom(buffer);
                for (var i = 0; i < bufferCodePoints.length; i++) {
                  var codePoint = bufferCodePoints[i];
                  if (codePoint === ":" && !seenPasswordToken) {
                    seenPasswordToken = true;
                    continue;
                  }
                  var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);
                  if (seenPasswordToken) url.password += encodedCodePoints;
                  else url.username += encodedCodePoints;
                }
                buffer = "";
              } else if (chr === EOF || chr === "/" || chr === "?" || chr === "#" || chr === "\\" && url.isSpecial()) {
                if (seenAt && buffer === "") return INVALID_AUTHORITY;
                pointer -= arrayFrom(buffer).length + 1;
                buffer = "";
                state = HOST;
              } else buffer += chr;
              break;
            case HOST:
            case HOSTNAME:
              if (stateOverride && url.scheme === "file") {
                state = FILE_HOST;
                continue;
              } else if (chr === ":" && !seenBracket) {
                if (buffer === "") return INVALID_HOST;
                failure = url.parseHost(buffer);
                if (failure) return failure;
                buffer = "";
                state = PORT;
                if (stateOverride === HOSTNAME) return;
              } else if (chr === EOF || chr === "/" || chr === "?" || chr === "#" || chr === "\\" && url.isSpecial()) {
                if (url.isSpecial() && buffer === "") return INVALID_HOST;
                if (stateOverride && buffer === "" && (url.includesCredentials() || url.port !== null)) return;
                failure = url.parseHost(buffer);
                if (failure) return failure;
                buffer = "";
                state = PATH_START;
                if (stateOverride) return;
                continue;
              } else {
                if (chr === "[") seenBracket = true;
                else if (chr === "]") seenBracket = false;
                buffer += chr;
              }
              break;
            case PORT:
              if (exec(DIGIT, chr)) {
                buffer += chr;
              } else if (chr === EOF || chr === "/" || chr === "?" || chr === "#" || chr === "\\" && url.isSpecial() || stateOverride) {
                if (buffer !== "") {
                  var port = parseInt2(buffer, 10);
                  if (port > 65535) return INVALID_PORT;
                  url.port = url.isSpecial() && port === specialSchemes[url.scheme] ? null : port;
                  buffer = "";
                }
                if (stateOverride) return;
                state = PATH_START;
                continue;
              } else return INVALID_PORT;
              break;
            case FILE:
              url.scheme = "file";
              if (chr === "/" || chr === "\\") state = FILE_SLASH;
              else if (base && base.scheme === "file") {
                switch (chr) {
                  case EOF:
                    url.host = base.host;
                    url.path = arraySlice(base.path);
                    url.query = base.query;
                    break;
                  case "?":
                    url.host = base.host;
                    url.path = arraySlice(base.path);
                    url.query = "";
                    state = QUERY;
                    break;
                  case "#":
                    url.host = base.host;
                    url.path = arraySlice(base.path);
                    url.query = base.query;
                    url.fragment = "";
                    state = FRAGMENT;
                    break;
                  default:
                    if (!startsWithWindowsDriveLetter(join(arraySlice(codePoints, pointer), ""))) {
                      url.host = base.host;
                      url.path = arraySlice(base.path);
                      url.shortenPath();
                    }
                    state = PATH;
                    continue;
                }
              } else {
                state = PATH;
                continue;
              }
              break;
            case FILE_SLASH:
              if (chr === "/" || chr === "\\") {
                state = FILE_HOST;
                break;
              }
              if (base && base.scheme === "file" && !startsWithWindowsDriveLetter(join(arraySlice(codePoints, pointer), ""))) {
                if (isWindowsDriveLetter(base.path[0], true)) push(url.path, base.path[0]);
                else url.host = base.host;
              }
              state = PATH;
              continue;
            case FILE_HOST:
              if (chr === EOF || chr === "/" || chr === "\\" || chr === "?" || chr === "#") {
                if (!stateOverride && isWindowsDriveLetter(buffer)) {
                  state = PATH;
                } else if (buffer === "") {
                  url.host = "";
                  if (stateOverride) return;
                  state = PATH_START;
                } else {
                  failure = url.parseHost(buffer);
                  if (failure) return failure;
                  if (url.host === "localhost") url.host = "";
                  if (stateOverride) return;
                  buffer = "";
                  state = PATH_START;
                }
                continue;
              } else buffer += chr;
              break;
            case PATH_START:
              if (url.isSpecial()) {
                state = PATH;
                if (chr !== "/" && chr !== "\\") continue;
              } else if (!stateOverride && chr === "?") {
                url.query = "";
                state = QUERY;
              } else if (!stateOverride && chr === "#") {
                url.fragment = "";
                state = FRAGMENT;
              } else if (chr !== EOF) {
                state = PATH;
                if (chr !== "/") continue;
              }
              break;
            case PATH:
              if (chr === EOF || chr === "/" || chr === "\\" && url.isSpecial() || !stateOverride && (chr === "?" || chr === "#")) {
                if (isDoubleDot(buffer)) {
                  url.shortenPath();
                  if (chr !== "/" && !(chr === "\\" && url.isSpecial())) {
                    push(url.path, "");
                  }
                } else if (isSingleDot(buffer)) {
                  if (chr !== "/" && !(chr === "\\" && url.isSpecial())) {
                    push(url.path, "");
                  }
                } else {
                  if (url.scheme === "file" && !url.path.length && isWindowsDriveLetter(buffer)) {
                    if (url.host) url.host = "";
                    buffer = charAt(buffer, 0) + ":";
                  }
                  push(url.path, buffer);
                }
                buffer = "";
                if (url.scheme === "file" && (chr === EOF || chr === "?" || chr === "#")) {
                  while (url.path.length > 1 && url.path[0] === "") {
                    shift(url.path);
                  }
                }
                if (chr === "?") {
                  url.query = "";
                  state = QUERY;
                } else if (chr === "#") {
                  url.fragment = "";
                  state = FRAGMENT;
                }
              } else {
                buffer += percentEncode(chr, pathPercentEncodeSet);
              }
              break;
            case CANNOT_BE_A_BASE_URL_PATH:
              if (chr === "?") {
                url.query = "";
                state = QUERY;
              } else if (chr === "#") {
                url.fragment = "";
                state = FRAGMENT;
              } else if (chr !== EOF) {
                url.path[0] += percentEncode(chr, C0ControlPercentEncodeSet);
              }
              break;
            case QUERY:
              if (!stateOverride && chr === "#") {
                url.fragment = "";
                state = FRAGMENT;
              } else if (chr !== EOF) {
                if (chr === "'" && url.isSpecial()) url.query += "%27";
                else if (chr === "#") url.query += "%23";
                else url.query += percentEncode(chr, C0ControlPercentEncodeSet);
              }
              break;
            case FRAGMENT:
              if (chr !== EOF) url.fragment += percentEncode(chr, fragmentPercentEncodeSet);
              break;
          }
          pointer++;
        }
      },
      // https://url.spec.whatwg.org/#host-parsing
      parseHost: function(input) {
        var result, codePoints, index;
        if (charAt(input, 0) === "[") {
          if (charAt(input, input.length - 1) !== "]") return INVALID_HOST;
          result = parseIPv6(stringSlice(input, 1, -1));
          if (!result) return INVALID_HOST;
          this.host = result;
        } else if (!this.isSpecial()) {
          if (exec(FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT, input)) return INVALID_HOST;
          result = "";
          codePoints = arrayFrom(input);
          for (index = 0; index < codePoints.length; index++) {
            result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);
          }
          this.host = result;
        } else {
          input = toASCII(input);
          if (exec(FORBIDDEN_HOST_CODE_POINT, input)) return INVALID_HOST;
          result = parseIPv4(input);
          if (result === null) return INVALID_HOST;
          this.host = result;
        }
      },
      // https://url.spec.whatwg.org/#cannot-have-a-username-password-port
      cannotHaveUsernamePasswordPort: function() {
        return !this.host || this.cannotBeABaseURL || this.scheme === "file";
      },
      // https://url.spec.whatwg.org/#include-credentials
      includesCredentials: function() {
        return this.username !== "" || this.password !== "";
      },
      // https://url.spec.whatwg.org/#is-special
      isSpecial: function() {
        return hasOwn(specialSchemes, this.scheme);
      },
      // https://url.spec.whatwg.org/#shorten-a-urls-path
      shortenPath: function() {
        var path = this.path;
        var pathSize = path.length;
        if (pathSize && (this.scheme !== "file" || pathSize !== 1 || !isWindowsDriveLetter(path[0], true))) {
          path.length--;
        }
      },
      // https://url.spec.whatwg.org/#concept-url-serializer
      serialize: function() {
        var url = this;
        var scheme = url.scheme;
        var username = url.username;
        var password = url.password;
        var host = url.host;
        var port = url.port;
        var path = url.path;
        var query = url.query;
        var fragment = url.fragment;
        var output = scheme + ":";
        if (host !== null) {
          output += "//";
          if (url.includesCredentials()) {
            output += username + (password ? ":" + password : "") + "@";
          }
          output += serializeHost(host);
          if (port !== null) output += ":" + port;
        } else if (scheme === "file") output += "//";
        output += url.cannotBeABaseURL ? path[0] : path.length ? "/" + join(path, "/") : "";
        if (query !== null) output += "?" + query;
        if (fragment !== null) output += "#" + fragment;
        return output;
      },
      // https://url.spec.whatwg.org/#dom-url-href
      setHref: function(href) {
        var failure = this.parse(href);
        if (failure) throw new TypeError2(failure);
        this.searchParams.update();
      },
      // https://url.spec.whatwg.org/#dom-url-origin
      getOrigin: function() {
        var scheme = this.scheme;
        var port = this.port;
        if (scheme === "blob") try {
          return new URLConstructor(scheme.path[0]).origin;
        } catch (error) {
          return "null";
        }
        if (scheme === "file" || !this.isSpecial()) return "null";
        return scheme + "://" + serializeHost(this.host) + (port !== null ? ":" + port : "");
      },
      // https://url.spec.whatwg.org/#dom-url-protocol
      getProtocol: function() {
        return this.scheme + ":";
      },
      setProtocol: function(protocol) {
        this.parse($toString(protocol) + ":", SCHEME_START);
      },
      // https://url.spec.whatwg.org/#dom-url-username
      getUsername: function() {
        return this.username;
      },
      setUsername: function(username) {
        var codePoints = arrayFrom($toString(username));
        if (this.cannotHaveUsernamePasswordPort()) return;
        this.username = "";
        for (var i = 0; i < codePoints.length; i++) {
          this.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);
        }
      },
      // https://url.spec.whatwg.org/#dom-url-password
      getPassword: function() {
        return this.password;
      },
      setPassword: function(password) {
        var codePoints = arrayFrom($toString(password));
        if (this.cannotHaveUsernamePasswordPort()) return;
        this.password = "";
        for (var i = 0; i < codePoints.length; i++) {
          this.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);
        }
      },
      // https://url.spec.whatwg.org/#dom-url-host
      getHost: function() {
        var host = this.host;
        var port = this.port;
        return host === null ? "" : port === null ? serializeHost(host) : serializeHost(host) + ":" + port;
      },
      setHost: function(host) {
        if (this.cannotBeABaseURL) return;
        this.parse(host, HOST);
      },
      // https://url.spec.whatwg.org/#dom-url-hostname
      getHostname: function() {
        var host = this.host;
        return host === null ? "" : serializeHost(host);
      },
      setHostname: function(hostname) {
        if (this.cannotBeABaseURL) return;
        this.parse(hostname, HOSTNAME);
      },
      // https://url.spec.whatwg.org/#dom-url-port
      getPort: function() {
        var port = this.port;
        return port === null ? "" : $toString(port);
      },
      setPort: function(port) {
        if (this.cannotHaveUsernamePasswordPort()) return;
        port = $toString(port);
        if (port === "") this.port = null;
        else this.parse(port, PORT);
      },
      // https://url.spec.whatwg.org/#dom-url-pathname
      getPathname: function() {
        var path = this.path;
        return this.cannotBeABaseURL ? path[0] : path.length ? "/" + join(path, "/") : "";
      },
      setPathname: function(pathname) {
        if (this.cannotBeABaseURL) return;
        this.path = [];
        this.parse(pathname, PATH_START);
      },
      // https://url.spec.whatwg.org/#dom-url-search
      getSearch: function() {
        var query = this.query;
        return query ? "?" + query : "";
      },
      setSearch: function(search) {
        search = $toString(search);
        if (search === "") {
          this.query = null;
        } else {
          if (charAt(search, 0) === "?") search = stringSlice(search, 1);
          this.query = "";
          this.parse(search, QUERY);
        }
        this.searchParams.update();
      },
      // https://url.spec.whatwg.org/#dom-url-searchparams
      getSearchParams: function() {
        return this.searchParams.facade;
      },
      // https://url.spec.whatwg.org/#dom-url-hash
      getHash: function() {
        var fragment = this.fragment;
        return fragment ? "#" + fragment : "";
      },
      setHash: function(hash) {
        hash = $toString(hash);
        if (hash === "") {
          this.fragment = null;
          return;
        }
        if (charAt(hash, 0) === "#") hash = stringSlice(hash, 1);
        this.fragment = "";
        this.parse(hash, FRAGMENT);
      },
      update: function() {
        this.query = this.searchParams.serialize() || null;
      }
    };
    var URLConstructor = function URL2(url) {
      var that = anInstance(this, URLPrototype);
      var base = validateArgumentsLength(arguments.length, 1) > 1 ? arguments[1] : void 0;
      var state = setInternalState(that, new URLState(url, false, base));
      if (!DESCRIPTORS) {
        that.href = state.serialize();
        that.origin = state.getOrigin();
        that.protocol = state.getProtocol();
        that.username = state.getUsername();
        that.password = state.getPassword();
        that.host = state.getHost();
        that.hostname = state.getHostname();
        that.port = state.getPort();
        that.pathname = state.getPathname();
        that.search = state.getSearch();
        that.searchParams = state.getSearchParams();
        that.hash = state.getHash();
      }
    };
    var URLPrototype = URLConstructor.prototype;
    var accessorDescriptor = function(getter, setter) {
      return {
        get: function() {
          return getInternalURLState(this)[getter]();
        },
        set: setter && function(value) {
          return getInternalURLState(this)[setter](value);
        },
        configurable: true,
        enumerable: true
      };
    };
    if (DESCRIPTORS) {
      defineBuiltInAccessor(URLPrototype, "href", accessorDescriptor("serialize", "setHref"));
      defineBuiltInAccessor(URLPrototype, "origin", accessorDescriptor("getOrigin"));
      defineBuiltInAccessor(URLPrototype, "protocol", accessorDescriptor("getProtocol", "setProtocol"));
      defineBuiltInAccessor(URLPrototype, "username", accessorDescriptor("getUsername", "setUsername"));
      defineBuiltInAccessor(URLPrototype, "password", accessorDescriptor("getPassword", "setPassword"));
      defineBuiltInAccessor(URLPrototype, "host", accessorDescriptor("getHost", "setHost"));
      defineBuiltInAccessor(URLPrototype, "hostname", accessorDescriptor("getHostname", "setHostname"));
      defineBuiltInAccessor(URLPrototype, "port", accessorDescriptor("getPort", "setPort"));
      defineBuiltInAccessor(URLPrototype, "pathname", accessorDescriptor("getPathname", "setPathname"));
      defineBuiltInAccessor(URLPrototype, "search", accessorDescriptor("getSearch", "setSearch"));
      defineBuiltInAccessor(URLPrototype, "searchParams", accessorDescriptor("getSearchParams"));
      defineBuiltInAccessor(URLPrototype, "hash", accessorDescriptor("getHash", "setHash"));
    }
    defineBuiltIn(URLPrototype, "toJSON", function toJSON() {
      return getInternalURLState(this).serialize();
    }, { enumerable: true });
    defineBuiltIn(URLPrototype, "toString", function toString() {
      return getInternalURLState(this).serialize();
    }, { enumerable: true });
    if (NativeURL) {
      nativeCreateObjectURL = NativeURL.createObjectURL;
      nativeRevokeObjectURL = NativeURL.revokeObjectURL;
      if (nativeCreateObjectURL) defineBuiltIn(URLConstructor, "createObjectURL", bind(nativeCreateObjectURL, NativeURL));
      if (nativeRevokeObjectURL) defineBuiltIn(URLConstructor, "revokeObjectURL", bind(nativeRevokeObjectURL, NativeURL));
    }
    var nativeCreateObjectURL;
    var nativeRevokeObjectURL;
    setToStringTag(URLConstructor, "URL");
    $({ global: true, constructor: true, forced: !USE_NATIVE_URL, sham: !DESCRIPTORS }, {
      URL: URLConstructor
    });
  }
});

// node_modules/core-js/modules/web.url.js
var require_web_url = __commonJS({
  "node_modules/core-js/modules/web.url.js"() {
    "use strict";
    require_web_url_constructor();
  }
});

// node_modules/core-js/modules/web.url-search-params.js
var require_web_url_search_params = __commonJS({
  "node_modules/core-js/modules/web.url-search-params.js"() {
    "use strict";
    require_web_url_search_params_constructor();
  }
});

// node_modules/@twilio/conversations/node_modules/@twilio/mcs-client/builds/browser.js
var require_browser9 = __commonJS({
  "node_modules/@twilio/conversations/node_modules/@twilio/mcs-client/builds/browser.js"(exports) {
    "use strict";
    var global2 = typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
    Object.defineProperty(exports, "__esModule", { value: true });
    require_es_reflect_to_string_tag();
    require_es_reflect_construct();
    var _classCallCheck = require_classCallCheck();
    var _createClass = require_createClass();
    var _inherits = require_inherits();
    var _possibleConstructorReturn = require_possibleConstructorReturn();
    var _getPrototypeOf = require_getPrototypeOf();
    var _wrapNativeSuper = require_wrapNativeSuper();
    var _defineProperty = require_defineProperty();
    require_es_object_to_string();
    require_es_promise();
    require_es_array_iterator();
    require_es_map();
    require_es_string_iterator();
    require_web_dom_collections_iterator();
    var _asyncToGenerator = require_asyncToGenerator();
    var _regeneratorRuntime = require_regenerator2();
    require_es_array_concat();
    require_es_array_map();
    require_web_dom_collections_for_each();
    var _typeof = require_typeof();
    require_es_array_from();
    var log$2 = require_loglevel();
    require_es_string_starts_with();
    require_es_array_filter();
    require_es_regexp_exec();
    require_es_string_split();
    require_es_string_replace();
    require_es_array_join();
    require_es_array_slice();
    require_es_json_stringify();
    require_es_object_assign();
    require_web_url();
    require_web_url_search_params();
    var operationRetrier = require_browser3();
    var declarativeTypeValidator = require_browser();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    function _interopNamespace(e) {
      if (e && e.__esModule) return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var _classCallCheck__default = _interopDefaultLegacy(_classCallCheck);
    var _createClass__default = _interopDefaultLegacy(_createClass);
    var _inherits__default = _interopDefaultLegacy(_inherits);
    var _possibleConstructorReturn__default = _interopDefaultLegacy(_possibleConstructorReturn);
    var _getPrototypeOf__default = _interopDefaultLegacy(_getPrototypeOf);
    var _wrapNativeSuper__default = _interopDefaultLegacy(_wrapNativeSuper);
    var _defineProperty__default = _interopDefaultLegacy(_defineProperty);
    var _asyncToGenerator__default = _interopDefaultLegacy(_asyncToGenerator);
    var _regeneratorRuntime__default = _interopDefaultLegacy(_regeneratorRuntime);
    var _typeof__default = _interopDefaultLegacy(_typeof);
    var log__namespace = _interopNamespace(log$2);
    var rngBrowser = { exports: {} };
    var getRandomValues = typeof crypto != "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != "undefined" && typeof window.msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (getRandomValues) {
      rnds8 = new Uint8Array(16);
      rngBrowser.exports = function whatwgRNG() {
        getRandomValues(rnds8);
        return rnds8;
      };
    } else {
      rnds = new Array(16);
      rngBrowser.exports = function mathRNG() {
        for (var i2 = 0, r; i2 < 16; i2++) {
          if ((i2 & 3) === 0) r = Math.random() * 4294967296;
          rnds[i2] = r >>> ((i2 & 3) << 3) & 255;
        }
        return rnds;
      };
    }
    var rnds8;
    var rnds;
    var byteToHex = [];
    for (i = 0; i < 256; ++i) {
      byteToHex[i] = (i + 256).toString(16).substr(1);
    }
    var i;
    function bytesToUuid$2(buf, offset) {
      var i2 = offset || 0;
      var bth = byteToHex;
      return [bth[buf[i2++]], bth[buf[i2++]], bth[buf[i2++]], bth[buf[i2++]], "-", bth[buf[i2++]], bth[buf[i2++]], "-", bth[buf[i2++]], bth[buf[i2++]], "-", bth[buf[i2++]], bth[buf[i2++]], "-", bth[buf[i2++]], bth[buf[i2++]], bth[buf[i2++]], bth[buf[i2++]], bth[buf[i2++]], bth[buf[i2++]]].join("");
    }
    var bytesToUuid_1 = bytesToUuid$2;
    var rng$1 = rngBrowser.exports;
    var bytesToUuid$1 = bytesToUuid_1;
    var _nodeId;
    var _clockseq;
    var _lastMSecs = 0;
    var _lastNSecs = 0;
    function v1$1(options, buf, offset) {
      var i2 = buf && offset || 0;
      var b = buf || [];
      options = options || {};
      var node = options.node || _nodeId;
      var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
      if (node == null || clockseq == null) {
        var seedBytes = rng$1();
        if (node == null) {
          node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
        }
        if (clockseq == null) {
          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
        }
      }
      var msecs = options.msecs !== void 0 ? options.msecs : (/* @__PURE__ */ new Date()).getTime();
      var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
      var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
      if (dt < 0 && options.clockseq === void 0) {
        clockseq = clockseq + 1 & 16383;
      }
      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
        nsecs = 0;
      }
      if (nsecs >= 1e4) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;
      msecs += 122192928e5;
      var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      b[i2++] = tl >>> 24 & 255;
      b[i2++] = tl >>> 16 & 255;
      b[i2++] = tl >>> 8 & 255;
      b[i2++] = tl & 255;
      var tmh = msecs / 4294967296 * 1e4 & 268435455;
      b[i2++] = tmh >>> 8 & 255;
      b[i2++] = tmh & 255;
      b[i2++] = tmh >>> 24 & 15 | 16;
      b[i2++] = tmh >>> 16 & 255;
      b[i2++] = clockseq >>> 8 | 128;
      b[i2++] = clockseq & 255;
      for (var n = 0; n < 6; ++n) {
        b[i2 + n] = node[n];
      }
      return buf ? buf : bytesToUuid$1(b);
    }
    var v1_1 = v1$1;
    var rng = rngBrowser.exports;
    var bytesToUuid = bytesToUuid_1;
    function v4$1(options, buf, offset) {
      var i2 = buf && offset || 0;
      if (typeof options == "string") {
        buf = options === "binary" ? new Array(16) : null;
        options = null;
      }
      options = options || {};
      var rnds2 = options.random || (options.rng || rng)();
      rnds2[6] = rnds2[6] & 15 | 64;
      rnds2[8] = rnds2[8] & 63 | 128;
      if (buf) {
        for (var ii = 0; ii < 16; ++ii) {
          buf[i2 + ii] = rnds2[ii];
        }
      }
      return buf || bytesToUuid(rnds2);
    }
    var v4_1 = v4$1;
    var v1 = v1_1;
    var v4 = v4_1;
    var uuid = v4;
    uuid.v1 = v1;
    uuid.v4 = v4;
    var uuid_1 = uuid;
    function _createSuper$1(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$1() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var CancellablePromise = function(_Promise) {
      _inherits__default["default"](CancellablePromise2, _Promise);
      var _super = _createSuper$1(CancellablePromise2);
      function CancellablePromise2(executor) {
        var _this;
        _classCallCheck__default["default"](this, CancellablePromise2);
        var outerId = uuid_1.v4();
        var outerRejectPromise;
        _this = _super.call(this, function(resolve, reject) {
          outerRejectPromise = reject;
          return executor(function(value) {
            CancellablePromise2.cancellationMap.delete(outerId);
            resolve(value);
          }, function(reason) {
            CancellablePromise2.cancellationMap.delete(outerId);
            reject(reason);
          }, function(cancellationFunction) {
            CancellablePromise2.cancellationMap.set(outerId, cancellationFunction);
          });
        });
        _this.id = outerId;
        _this.rejectPromise = outerRejectPromise;
        return _this;
      }
      _createClass__default["default"](CancellablePromise2, [{
        key: "cancel",
        value: function cancel() {
          var onCancel = CancellablePromise2.cancellationMap.get(this.id);
          onCancel === null || onCancel === void 0 ? void 0 : onCancel();
          if (this.rejectPromise) {
            this.catch(function() {
              return void 0;
            });
            this.rejectPromise(new Error("Promise was cancelled"));
          }
          return this;
        }
      }]);
      return CancellablePromise2;
    }(_wrapNativeSuper__default["default"](Promise));
    _defineProperty__default["default"](CancellablePromise, "cancellationMap", /* @__PURE__ */ new Map());
    function __decorate(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ((typeof Reflect === "undefined" ? "undefined" : _typeof__default["default"](Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
        if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      }
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __metadata(metadataKey, metadataValue) {
      if ((typeof Reflect === "undefined" ? "undefined" : _typeof__default["default"](Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }
    function prepareLine(prefix, args) {
      return ["".concat((/* @__PURE__ */ new Date()).toISOString(), " MCS Client ").concat(prefix, ":")].concat(Array.from(args));
    }
    var Logger = function() {
      function Logger2(prefix) {
        _classCallCheck__default["default"](this, Logger2);
        _defineProperty__default["default"](this, "prefix", "");
        this.prefix = prefix !== null && prefix !== void 0 && prefix.length > 0 ? prefix + " " : "";
      }
      _createClass__default["default"](Logger2, [{
        key: "setLevel",
        value: function setLevel(level) {
          log__namespace.setLevel(level);
        }
      }, {
        key: "trace",
        value: (
          /* eslint-disable @typescript-eslint/explicit-module-boundary-types */
          function trace() {
            if (log__namespace.getLevel() == log__namespace.levels.TRACE) {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              log__namespace.debug.apply(null, prepareLine(this.prefix + "T", args));
            }
          }
        )
      }, {
        key: "debug",
        value: function debug() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          log__namespace.debug.apply(null, prepareLine(this.prefix + "D", args));
        }
      }, {
        key: "info",
        value: function info() {
          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }
          log__namespace.info.apply(null, prepareLine(this.prefix + "I", args));
        }
      }, {
        key: "warn",
        value: function warn() {
          for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args[_key4] = arguments[_key4];
          }
          log__namespace.warn.apply(null, prepareLine(this.prefix + "W", args));
        }
      }, {
        key: "error",
        value: function error() {
          for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
            args[_key5] = arguments[_key5];
          }
          log__namespace.error.apply(null, prepareLine(this.prefix + "E", args));
        }
      }], [{
        key: "scope",
        value: function scope(prefix) {
          return new Logger2(prefix);
        }
      }, {
        key: "setLevel",
        value: function setLevel(level) {
          log__namespace.setLevel(level);
        }
      }, {
        key: "trace",
        value: function trace() {
          if (log__namespace.getLevel() == log__namespace.levels.TRACE) {
            for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
              args[_key6] = arguments[_key6];
            }
            log__namespace.debug.apply(null, prepareLine("T", args));
          }
        }
      }, {
        key: "debug",
        value: function debug() {
          for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
            args[_key7] = arguments[_key7];
          }
          log__namespace.debug.apply(null, prepareLine("D", args));
        }
      }, {
        key: "info",
        value: function info() {
          for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
            args[_key8] = arguments[_key8];
          }
          log__namespace.info.apply(null, prepareLine("I", args));
        }
      }, {
        key: "warn",
        value: function warn() {
          for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
            args[_key9] = arguments[_key9];
          }
          log__namespace.warn.apply(null, prepareLine("W", args));
        }
      }, {
        key: "error",
        value: function error() {
          for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
            args[_key10] = arguments[_key10];
          }
          log__namespace.error.apply(null, prepareLine("E", args));
        }
      }]);
      return Logger2;
    }();
    var MINIMUM_RETRY_DELAY = 1e3;
    var MAXIMUM_RETRY_DELAY = 4e3;
    var MAXIMUM_ATTEMPTS_COUNT = 3;
    var RETRY_WHEN_THROTTLED = true;
    var regionalMcsHost = function regionalMcsHost2(region) {
      return "https://mcs.".concat(region !== null && region !== void 0 ? region : "us1", ".twilio.com");
    };
    var isFullUrl = function isFullUrl2(url) {
      return url.startsWith("http");
    };
    var fullUrl = function fullUrl2(partUrl, region) {
      return "".concat(!isFullUrl(partUrl) ? regionalMcsHost(region) : "").concat(partUrl);
    };
    var Configuration = function() {
      function Configuration2(token, baseUrl, baseSetUrl, options) {
        var _ref, _options$MCS, _ref2, _constructorOptions$r, _constructorOptions$r2, _constructorOptions$b;
        _classCallCheck__default["default"](this, Configuration2);
        var constructorOptions = (_ref = (_options$MCS = options.MCS) !== null && _options$MCS !== void 0 ? _options$MCS : options) !== null && _ref !== void 0 ? _ref : {};
        this.region = (_ref2 = (_constructorOptions$r = constructorOptions.region) !== null && _constructorOptions$r !== void 0 ? _constructorOptions$r : options.region) !== null && _ref2 !== void 0 ? _ref2 : "us1";
        this.mediaUrl = fullUrl(baseUrl, this.region);
        this.mediaSetUrl = baseSetUrl ? fullUrl(baseSetUrl) : "".concat(this.mediaUrl, "Set");
        this.token = token;
        this.retryWhenThrottledOverride = (_constructorOptions$r2 = constructorOptions.retryWhenThrottledOverride) !== null && _constructorOptions$r2 !== void 0 ? _constructorOptions$r2 : RETRY_WHEN_THROTTLED;
        this.backoffConfigOverride = (_constructorOptions$b = constructorOptions.backoffConfigOverride) !== null && _constructorOptions$b !== void 0 ? _constructorOptions$b : Configuration2.backoffConfigDefault;
      }
      _createClass__default["default"](Configuration2, [{
        key: "updateToken",
        value: function updateToken(token) {
          this.token = token;
        }
      }], [{
        key: "backoffConfigDefault",
        get: function get() {
          return {
            min: MINIMUM_RETRY_DELAY,
            max: MAXIMUM_RETRY_DELAY,
            maxAttemptsCount: MAXIMUM_ATTEMPTS_COUNT
          };
        }
      }, {
        key: "retryWhenThrottledDefault",
        get: function get() {
          return RETRY_WHEN_THROTTLED;
        }
      }]);
      return Configuration2;
    }();
    var Media = function() {
      function Media2(config, network, data) {
        _classCallCheck__default["default"](this, Media2);
        this.config = config;
        this.network = network;
        this._update(data);
      }
      _createClass__default["default"](Media2, [{
        key: "sid",
        get: function get() {
          return this.state.sid;
        }
      }, {
        key: "serviceSid",
        get: function get() {
          return this.state.serviceSid;
        }
      }, {
        key: "dateCreated",
        get: function get() {
          return this.state.dateCreated;
        }
      }, {
        key: "dateUpdated",
        get: function get() {
          return this.state.dateUpdated;
        }
      }, {
        key: "contentType",
        get: function get() {
          return this.state.contentType;
        }
      }, {
        key: "size",
        get: function get() {
          return this.state.size;
        }
        /** @deprecated Use filename instead */
      }, {
        key: "fileName",
        get: function get() {
          return this.state.filename;
        }
      }, {
        key: "filename",
        get: function get() {
          return this.state.filename;
        }
      }, {
        key: "category",
        get: function get() {
          return this.state.category;
        }
        /**
         * Returns direct content URL to uploaded binary. This URL will expire after some time.
         * This function gets a new URL every time, preventing it from expiring but putting additional load on backend.
         * See getCachedContentUrl() for a function that reduces the amount of network requests.
         *
         * It is reasonable to build your own refresh logic upon these two functions: as soon as URL returned
         * by getCachedContentUrl() returns 40x status you should call getContentUrl() to refresh it.
         */
      }, {
        key: "getContentUrl",
        value: function getContentUrl() {
          var _this = this;
          return new CancellablePromise(function() {
            var _ref = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee(resolve, reject, onCancel) {
              var request, response;
              return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      request = _this.network.get("".concat(_this.config.mediaUrl, "/").concat(_this.sid));
                      onCancel(function() {
                        return request.cancel();
                      });
                      _context.prev = 2;
                      _context.next = 5;
                      return request;
                    case 5:
                      response = _context.sent;
                      _this._update(response.body);
                      resolve(_this.state.contentDirectUrl);
                      _context.next = 13;
                      break;
                    case 10:
                      _context.prev = 10;
                      _context.t0 = _context["catch"](2);
                      reject(_context.t0);
                    case 13:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, null, [[2, 10]]);
            }));
            return function(_x, _x2, _x3) {
              return _ref.apply(this, arguments);
            };
          }());
        }
      }, {
        key: "_update",
        value: function _update(data) {
          var _data$links$content_d, _data$filename, _data$category, _data$is_multipart_up;
          this.state = {
            sid: data.sid,
            serviceSid: data.service_sid,
            channelSid: data.channel_sid,
            messageSid: data.message_sid,
            dateCreated: data.date_created ? new Date(data.date_created) : null,
            dateUploadUpdated: data.date_upload_updated ? new Date(data.date_upload_updated) : null,
            dateUpdated: data.date_updated ? new Date(data.date_updated) : null,
            size: data.size,
            contentType: data.content_type,
            author: data.author,
            url: data.url,
            contentUrl: data.links.content,
            contentDirectUrl: (_data$links$content_d = data.links.content_direct_temporary) !== null && _data$links$content_d !== void 0 ? _data$links$content_d : null,
            filename: (_data$filename = data.filename) !== null && _data$filename !== void 0 ? _data$filename : null,
            category: (_data$category = data.category) !== null && _data$category !== void 0 ? _data$category : "media",
            isMultipartUpstream: (_data$is_multipart_up = data.is_multipart_upstream) !== null && _data$is_multipart_up !== void 0 ? _data$is_multipart_up : false
          };
        }
        /**
         * @internal
         * This payload is compatible with Conversations' media object _state().
         */
      }, {
        key: "_state",
        value: function _state() {
          var _this$state$filename;
          return {
            sid: this.state.sid,
            category: this.state.category,
            filename: (_this$state$filename = this.state.filename) !== null && _this$state$filename !== void 0 ? _this$state$filename : null,
            contentType: this.state.contentType,
            size: this.state.size
          };
        }
      }]);
      return Media2;
    }();
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var TransportError = function(_Error) {
      _inherits__default["default"](TransportError2, _Error);
      var _super = _createSuper(TransportError2);
      function TransportError2(message, code, body, status, headers) {
        var _this;
        _classCallCheck__default["default"](this, TransportError2);
        _this = _super.call(this, message);
        _this.code = code;
        _this.body = body;
        _this.status = status;
        _this.headers = headers;
        return _this;
      }
      return _createClass__default["default"](TransportError2);
    }(_wrapNativeSuper__default["default"](Error));
    var XHR = global2["XMLHttpRequest"] || {};
    function parseResponseHeaders(headerString) {
      if (!headerString) {
        return {};
      }
      return headerString.split("\r\n").map(function(el) {
        return el.split(": ");
      }).filter(function(el) {
        return el.length === 2 && el[1].length > 0;
      }).reduce(function(prev, curr) {
        prev[curr[0]] = curr[1];
        return prev;
      }, {});
    }
    function extractBody(xhr) {
      var contentType = xhr.getResponseHeader("Content-Type");
      if (!contentType || contentType.indexOf("application/json") !== 0 || xhr.responseText.length === 0) {
        return xhr.responseText;
      }
      try {
        return JSON.parse(xhr.responseText);
      } catch (e) {
        return xhr.responseText;
      }
    }
    var Transport = function() {
      function Transport2() {
        _classCallCheck__default["default"](this, Transport2);
      }
      _createClass__default["default"](Transport2, [{
        key: "get",
        value: (
          /**
           * Make a GET request by given URL
           */
          function get(url, headers) {
            return Transport2.request("GET", url, headers);
          }
        )
        /**
         * Make a POST request by given URL
         */
      }, {
        key: "post",
        value: function post(url, headers, body) {
          return Transport2.request("POST", url, headers, body);
        }
      }], [{
        key: "request",
        value: function request(method, url, headers, body) {
          return new CancellablePromise(function(resolve, reject, onCancel) {
            var xhr = new XHR();
            var isCancelled = false;
            onCancel(function() {
              xhr.abort();
              isCancelled = true;
            });
            xhr.open(method, url, true);
            xhr.onreadystatechange = function onreadystatechange() {
              if (xhr.readyState !== 4 || isCancelled) {
                return;
              }
              var responseHeaders = parseResponseHeaders(xhr.getAllResponseHeaders());
              var body2 = extractBody(xhr);
              if (200 <= xhr.status && xhr.status < 300) {
                resolve({
                  status: xhr.status,
                  headers: responseHeaders,
                  body: body2
                });
              } else {
                var _xhr$statusText;
                var status = (_xhr$statusText = xhr.statusText) !== null && _xhr$statusText !== void 0 ? _xhr$statusText : "NONE";
                var bodyRepresentation;
                if (typeof body2 === "string") {
                  if (body2 && body2.split("\n", 2).length === 1) bodyRepresentation = body2;
                  else {
                    var _body$replace$split$f;
                    var errorInfo = (_body$replace$split$f = body2.replace(/<.*?>/g, "").split(/\r\n/g).filter(function(str) {
                      return str.length;
                    })[0]) === null || _body$replace$split$f === void 0 ? void 0 : _body$replace$split$f.split(" ");
                    bodyRepresentation = (errorInfo === null || errorInfo === void 0 ? void 0 : errorInfo.length) > 2 ? errorInfo === null || errorInfo === void 0 ? void 0 : errorInfo.slice(1).join(" ") : "";
                  }
                } else {
                  bodyRepresentation = JSON.stringify(body2);
                }
                var message = "".concat(xhr.status, ": [").concat(status, "] ").concat(bodyRepresentation);
                reject(new TransportError(message, xhr.status, body2, status, responseHeaders));
              }
            };
            for (var headerName in headers) {
              xhr.setRequestHeader(headerName, headers[headerName]);
              if (headerName === "Content-Type" && headers[headerName] === "application/json") {
                body = JSON.stringify(body);
              }
            }
            xhr.send(body);
          });
        }
      }]);
      return Transport2;
    }();
    var log$1 = Logger.scope("Network");
    var Network = function() {
      function Network2(config, transport) {
        _classCallCheck__default["default"](this, Network2);
        this.config = config;
        this.transport = transport;
      }
      _createClass__default["default"](Network2, [{
        key: "backoffConfig",
        value: function backoffConfig() {
          return Object.assign(Configuration.backoffConfigDefault, this.config.backoffConfigOverride);
        }
      }, {
        key: "retryWhenThrottled",
        value: function retryWhenThrottled() {
          var _ref, _this$config$retryWhe;
          return (_ref = (_this$config$retryWhe = this.config.retryWhenThrottledOverride) !== null && _this$config$retryWhe !== void 0 ? _this$config$retryWhe : Configuration.retryWhenThrottledDefault) !== null && _ref !== void 0 ? _ref : false;
        }
      }, {
        key: "executeWithRetry",
        value: function executeWithRetry(request, retryWhenThrottled) {
          var _this = this;
          return new CancellablePromise(function() {
            var _ref2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee2(resolve, reject, onCancel) {
              var retrier, codesToRetryOn;
              return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      retrier = new operationRetrier.Retrier(_this.backoffConfig());
                      codesToRetryOn = [502, 503, 504];
                      if (retryWhenThrottled) {
                        codesToRetryOn.push(429);
                      }
                      onCancel(function() {
                        retrier.cancel();
                        retrier.removeAllListeners();
                      });
                      retrier.on("attempt", _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee() {
                        var requestPromise, result;
                        return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
                          while (1) {
                            switch (_context.prev = _context.next) {
                              case 0:
                                _context.prev = 0;
                                requestPromise = request();
                                onCancel(function() {
                                  requestPromise.cancel();
                                  retrier.cancel();
                                  retrier.removeAllListeners();
                                });
                                _context.next = 5;
                                return requestPromise;
                              case 5:
                                result = _context.sent;
                                retrier.succeeded(result);
                                _context.next = 12;
                                break;
                              case 9:
                                _context.prev = 9;
                                _context.t0 = _context["catch"](0);
                                if (codesToRetryOn.indexOf(_context.t0.status) > -1) {
                                  retrier.failed(_context.t0);
                                } else if (_context.t0.message === "Twilsock disconnected") {
                                  retrier.failed(_context.t0);
                                } else {
                                  retrier.removeAllListeners();
                                  retrier.cancel();
                                  reject(_context.t0);
                                }
                              case 12:
                              case "end":
                                return _context.stop();
                            }
                          }
                        }, _callee, null, [[0, 9]]);
                      })));
                      retrier.on("succeeded", function(result) {
                        resolve(result);
                      });
                      retrier.on("cancelled", function(err) {
                        return reject(err);
                      });
                      retrier.on("failed", function(err) {
                        return reject(err);
                      });
                      retrier.start();
                    case 9:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2);
            }));
            return function(_x, _x2, _x3) {
              return _ref2.apply(this, arguments);
            };
          }());
        }
      }, {
        key: "get",
        value: function get(url) {
          var _this2 = this;
          return new CancellablePromise(function() {
            var _ref4 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee3(resolve, reject, onCancel) {
              var headers, request, response;
              return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      headers = {
                        "X-Twilio-Token": _this2.config.token
                      };
                      request = _this2.executeWithRetry(function() {
                        return _this2.transport.get(url, headers);
                      }, _this2.retryWhenThrottled());
                      log$1.trace("sending GET request to ", url, " headers ", headers);
                      onCancel(function() {
                        return request.cancel();
                      });
                      _context3.prev = 4;
                      _context3.next = 7;
                      return request;
                    case 7:
                      response = _context3.sent;
                      log$1.trace("response", response);
                      resolve(response);
                      _context3.next = 16;
                      break;
                    case 12:
                      _context3.prev = 12;
                      _context3.t0 = _context3["catch"](4);
                      log$1.debug("get() error ".concat(_context3.t0));
                      reject(_context3.t0);
                    case 16:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _callee3, null, [[4, 12]]);
            }));
            return function(_x4, _x5, _x6) {
              return _ref4.apply(this, arguments);
            };
          }());
        }
      }, {
        key: "post",
        value: function post(url, category, media, contentType, filename) {
          var _this3 = this;
          var headers = {
            "X-Twilio-Token": this.config.token
          };
          if ((typeof FormData === "undefined" || !(media instanceof FormData)) && contentType) {
            Object.assign(headers, {
              "Content-Type": contentType
            });
          }
          var fullUrl2 = new URL(url);
          if (category) {
            fullUrl2.searchParams.append("Category", category);
          }
          if (filename) {
            fullUrl2.searchParams.append("Filename", filename);
          }
          return new CancellablePromise(function() {
            var _ref5 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee4(resolve, reject, onCancel) {
              var request, response;
              return _regeneratorRuntime__default["default"].wrap(function _callee4$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      request = _this3.transport.post(fullUrl2.href, headers, media);
                      onCancel(function() {
                        return request.cancel();
                      });
                      log$1.trace("sending POST request to ".concat(url, " with headers ").concat(headers));
                      _context4.prev = 3;
                      _context4.next = 6;
                      return request;
                    case 6:
                      response = _context4.sent;
                      _context4.next = 17;
                      break;
                    case 9:
                      _context4.prev = 9;
                      _context4.t0 = _context4["catch"](3);
                      if (!(global2["XMLHttpRequest"] === void 0 && media instanceof FormData)) {
                        _context4.next = 14;
                        break;
                      }
                      reject(new TypeError("Posting FormData supported only with browser engine's FormData"));
                      return _context4.abrupt("return");
                    case 14:
                      log$1.debug("post() error ".concat(_context4.t0));
                      reject(_context4.t0);
                      return _context4.abrupt("return");
                    case 17:
                      log$1.trace("response", response);
                      resolve(response);
                    case 19:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4, null, [[3, 9]]);
            }));
            return function(_x7, _x8, _x9) {
              return _ref5.apply(this, arguments);
            };
          }());
        }
      }]);
      return Network2;
    }();
    var version = "0.6.10";
    var _class;
    var log = Logger.scope("");
    exports["default"] = (_class = function() {
      function Client(token, baseUrl, baseSetUrl) {
        var _this$options$logLeve, _this$options$transpo;
        var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        _classCallCheck__default["default"](this, Client);
        this.options = options;
        this.options.logLevel = (_this$options$logLeve = this.options.logLevel) !== null && _this$options$logLeve !== void 0 ? _this$options$logLeve : "silent";
        this.config = new Configuration(token, baseUrl, baseSetUrl, this.options);
        log.setLevel(this.options.logLevel);
        this.options.transport = (_this$options$transpo = this.options.transport) !== null && _this$options$transpo !== void 0 ? _this$options$transpo : new Transport();
        this.transport = this.options.transport;
        this.network = new Network(this.config, this.transport);
      }
      _createClass__default["default"](Client, [{
        key: "updateToken",
        value: function updateToken(token) {
          log.info("updateToken");
          this.config.updateToken(token);
        }
        /**
         * Gets media from media service
         * @param {String} sid - Media's SID
         */
      }, {
        key: "get",
        value: function get(sid) {
          var _this = this;
          return new CancellablePromise(function() {
            var _ref = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee(resolve, reject, onCancel) {
              var request, response;
              return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      request = _this.network.get("".concat(_this.config.mediaUrl, "/").concat(sid));
                      onCancel(function() {
                        return request.cancel();
                      });
                      _context.prev = 2;
                      _context.next = 5;
                      return request;
                    case 5:
                      response = _context.sent;
                      resolve(new Media(_this.config, _this.network, response.body));
                      _context.next = 12;
                      break;
                    case 9:
                      _context.prev = 9;
                      _context.t0 = _context["catch"](2);
                      reject(_context.t0);
                    case 12:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, null, [[2, 9]]);
            }));
            return function(_x, _x2, _x3) {
              return _ref.apply(this, arguments);
            };
          }());
        }
        /**
         * Posts raw content to media service
         * @param {String} contentType - content type of media
         * @param {String|Buffer|Blob} media - content to post
         * @param {MediaCategory|null} category - category for the media
         */
      }, {
        key: "post",
        value: function post(contentType, media, category, filename) {
          var _this2 = this;
          return new CancellablePromise(function() {
            var _ref2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee2(resolve, reject, onCancel) {
              var request, response;
              return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      request = _this2.network.post(_this2.config.mediaUrl, category !== null && category !== void 0 ? category : "media", media, contentType, filename);
                      onCancel(function() {
                        return request.cancel();
                      });
                      _context2.prev = 2;
                      _context2.next = 5;
                      return request;
                    case 5:
                      response = _context2.sent;
                      resolve(new Media(_this2.config, _this2.network, response.body));
                      _context2.next = 12;
                      break;
                    case 9:
                      _context2.prev = 9;
                      _context2.t0 = _context2["catch"](2);
                      reject(_context2.t0);
                    case 12:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2, null, [[2, 9]]);
            }));
            return function(_x4, _x5, _x6) {
              return _ref2.apply(this, arguments);
            };
          }());
        }
        /**
         * Posts FormData to media service. Can be used only with browser engine's FormData.
         * In non-browser FormData case the method will do promise reject with
         * new TypeError("Posting FormData supported only with browser engine's FormData")
         * @param {FormData} formData - form data to post
         * @param {MediaCategory|null} category - category for the media
         */
      }, {
        key: "postFormData",
        value: function postFormData(formData, category) {
          var _this3 = this;
          return new CancellablePromise(function() {
            var _ref3 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee3(resolve, reject, onCancel) {
              var request, response;
              return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      request = _this3.network.post(_this3.config.mediaUrl, category !== null && category !== void 0 ? category : "media", formData);
                      onCancel(function() {
                        return request.cancel();
                      });
                      _context3.prev = 2;
                      _context3.next = 5;
                      return request;
                    case 5:
                      response = _context3.sent;
                      resolve(new Media(_this3.config, _this3.network, response.body));
                      _context3.next = 12;
                      break;
                    case 9:
                      _context3.prev = 9;
                      _context3.t0 = _context3["catch"](2);
                      reject(_context3.t0);
                    case 12:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _callee3, null, [[2, 9]]);
            }));
            return function(_x7, _x8, _x9) {
              return _ref3.apply(this, arguments);
            };
          }());
        }
        /**
         * Retrieve information about multiple media SIDs at the same time.
         * @param mediaSids Array of Media SIDs to get information from.
         */
      }, {
        key: "mediaSetGet",
        value: function mediaSetGet(mediaSids) {
          var _this4 = this;
          return new CancellablePromise(function() {
            var _ref4 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee4(resolve, reject, onCancel) {
              var query, request, response, media;
              return _regeneratorRuntime__default["default"].wrap(function _callee4$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      query = {
                        command: "get",
                        list: mediaSids.map(function(sid) {
                          return {
                            media_sid: sid
                          };
                        })
                      };
                      request = _this4.network.post("".concat(_this4.config.mediaSetUrl), null, query, "application/json");
                      onCancel(function() {
                        return request.cancel();
                      });
                      _context4.prev = 3;
                      _context4.next = 6;
                      return request;
                    case 6:
                      response = _context4.sent;
                      media = response.body.map(function(item) {
                        if (item.code !== 200) {
                          reject("Failed to obtain detailed information about Media items (failed SID ".concat(item.media_record.sid, ")"));
                          return;
                        }
                        return new Media(_this4.config, _this4.network, item.media_record);
                      });
                      resolve(media);
                      _context4.next = 14;
                      break;
                    case 11:
                      _context4.prev = 11;
                      _context4.t0 = _context4["catch"](3);
                      reject(_context4.t0);
                    case 14:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4, null, [[3, 11]]);
            }));
            return function(_x10, _x11, _x12) {
              return _ref4.apply(this, arguments);
            };
          }());
        }
        /**
         * Retrieve temporary URLs for a set of media SIDs.
         * @param mediaSids array of the media SIDs to get URLs from.
         */
      }, {
        key: "mediaSetGetContentUrls",
        value: function mediaSetGetContentUrls(mediaSids) {
          var _this5 = this;
          return new CancellablePromise(function() {
            var _ref5 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee5(resolve, reject, onCancel) {
              var query, request, response, urls;
              return _regeneratorRuntime__default["default"].wrap(function _callee5$(_context5) {
                while (1) {
                  switch (_context5.prev = _context5.next) {
                    case 0:
                      query = {
                        command: "get",
                        list: mediaSids.map(function(sid) {
                          return {
                            media_sid: sid
                          };
                        })
                      };
                      request = _this5.network.post("".concat(_this5.config.mediaSetUrl), null, query, "application/json");
                      onCancel(function() {
                        return request.cancel();
                      });
                      _context5.prev = 3;
                      _context5.next = 6;
                      return request;
                    case 6:
                      response = _context5.sent;
                      urls = /* @__PURE__ */ new Map();
                      response.body.forEach(function(item) {
                        if (item.code !== 200) {
                          reject("Failed to obtain detailed information about Media items (failed SID ".concat(item.media_record.sid, ")"));
                          return;
                        }
                        urls.set(item.media_record.sid, item.media_record.links.content_direct_temporary);
                      });
                      resolve(urls);
                      _context5.next = 15;
                      break;
                    case 12:
                      _context5.prev = 12;
                      _context5.t0 = _context5["catch"](3);
                      reject(_context5.t0);
                    case 15:
                    case "end":
                      return _context5.stop();
                  }
                }
              }, _callee5, null, [[3, 12]]);
            }));
            return function(_x13, _x14, _x15) {
              return _ref5.apply(this, arguments);
            };
          }());
        }
      }]);
      return Client;
    }(), _defineProperty__default["default"](_class, "version", version), _class);
    __decorate([declarativeTypeValidator.validateTypes(declarativeTypeValidator.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", void 0)], exports["default"].prototype, "updateToken", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", CancellablePromise)], exports["default"].prototype, "get", null);
    exports["default"] = __decorate([declarativeTypeValidator.validateConstructorTypes(declarativeTypeValidator.nonEmptyString, declarativeTypeValidator.nonEmptyString, [declarativeTypeValidator.nonEmptyString, declarativeTypeValidator.literal(null)], [declarativeTypeValidator.pureObject, "undefined"]), __metadata("design:paramtypes", [String, String, Object, Object])], exports["default"]);
    exports.CancellablePromise = CancellablePromise;
    exports.Client = exports["default"];
    exports.McsClient = exports["default"];
    exports.McsMedia = Media;
    exports.Media = Media;
  }
});

// node_modules/core-js/modules/es.typed-array.at.js
var require_es_typed_array_at = __commonJS({
  "node_modules/core-js/modules/es.typed-array.at.js"() {
    "use strict";
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var lengthOfArrayLike = require_length_of_array_like();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod("at", function at(index) {
      var O = aTypedArray(this);
      var len = lengthOfArrayLike(O);
      var relativeIndex = toIntegerOrInfinity(index);
      var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
      return k < 0 || k >= len ? void 0 : O[k];
    });
  }
});

// node_modules/core-js/modules/es.array-buffer.constructor.js
var require_es_array_buffer_constructor = __commonJS({
  "node_modules/core-js/modules/es.array-buffer.constructor.js"() {
    "use strict";
    var $ = require_export();
    var globalThis2 = require_global_this();
    var arrayBufferModule = require_array_buffer();
    var setSpecies = require_set_species();
    var ARRAY_BUFFER = "ArrayBuffer";
    var ArrayBuffer2 = arrayBufferModule[ARRAY_BUFFER];
    var NativeArrayBuffer = globalThis2[ARRAY_BUFFER];
    $({ global: true, constructor: true, forced: NativeArrayBuffer !== ArrayBuffer2 }, {
      ArrayBuffer: ArrayBuffer2
    });
    setSpecies(ARRAY_BUFFER);
  }
});

// node_modules/isomorphic-form-data/lib/browser.js
var require_browser10 = __commonJS({
  "node_modules/isomorphic-form-data/lib/browser.js"(exports, module) {
    module.exports = window.FormData;
  }
});

// node_modules/core-js/modules/es.array.sort.js
var require_es_array_sort = __commonJS({
  "node_modules/core-js/modules/es.array.sort.js"() {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this();
    var aCallable = require_a_callable();
    var toObject = require_to_object();
    var lengthOfArrayLike = require_length_of_array_like();
    var deletePropertyOrThrow = require_delete_property_or_throw();
    var toString = require_to_string();
    var fails = require_fails();
    var internalSort = require_array_sort();
    var arrayMethodIsStrict = require_array_method_is_strict();
    var FF = require_environment_ff_version();
    var IE_OR_EDGE = require_environment_is_ie_or_edge();
    var V8 = require_environment_v8_version();
    var WEBKIT = require_environment_webkit_version();
    var test = [];
    var nativeSort = uncurryThis(test.sort);
    var push = uncurryThis(test.push);
    var FAILS_ON_UNDEFINED = fails(function() {
      test.sort(void 0);
    });
    var FAILS_ON_NULL = fails(function() {
      test.sort(null);
    });
    var STRICT_METHOD = arrayMethodIsStrict("sort");
    var STABLE_SORT = !fails(function() {
      if (V8) return V8 < 70;
      if (FF && FF > 3) return;
      if (IE_OR_EDGE) return true;
      if (WEBKIT) return WEBKIT < 603;
      var result = "";
      var code, chr, value, index;
      for (code = 65; code < 76; code++) {
        chr = String.fromCharCode(code);
        switch (code) {
          case 66:
          case 69:
          case 70:
          case 72:
            value = 3;
            break;
          case 68:
          case 71:
            value = 4;
            break;
          default:
            value = 2;
        }
        for (index = 0; index < 47; index++) {
          test.push({ k: chr + index, v: value });
        }
      }
      test.sort(function(a, b) {
        return b.v - a.v;
      });
      for (index = 0; index < test.length; index++) {
        chr = test[index].k.charAt(0);
        if (result.charAt(result.length - 1) !== chr) result += chr;
      }
      return result !== "DGBEFHACIJK";
    });
    var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;
    var getSortCompare = function(comparefn) {
      return function(x, y) {
        if (y === void 0) return -1;
        if (x === void 0) return 1;
        if (comparefn !== void 0) return +comparefn(x, y) || 0;
        return toString(x) > toString(y) ? 1 : -1;
      };
    };
    $({ target: "Array", proto: true, forced: FORCED }, {
      sort: function sort(comparefn) {
        if (comparefn !== void 0) aCallable(comparefn);
        var array = toObject(this);
        if (STABLE_SORT) return comparefn === void 0 ? nativeSort(array) : nativeSort(array, comparefn);
        var items = [];
        var arrayLength = lengthOfArrayLike(array);
        var itemsLength, index;
        for (index = 0; index < arrayLength; index++) {
          if (index in array) push(items, array[index]);
        }
        internalSort(items, getSortCompare(comparefn));
        itemsLength = lengthOfArrayLike(items);
        index = 0;
        while (index < itemsLength) array[index] = items[index++];
        while (index < arrayLength) deletePropertyOrThrow(array, index++);
        return array;
      }
    });
  }
});

// node_modules/core-js/modules/es.string.includes.js
var require_es_string_includes = __commonJS({
  "node_modules/core-js/modules/es.string.includes.js"() {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this();
    var notARegExp = require_not_a_regexp();
    var requireObjectCoercible = require_require_object_coercible();
    var toString = require_to_string();
    var correctIsRegExpLogic = require_correct_is_regexp_logic();
    var stringIndexOf = uncurryThis("".indexOf);
    $({ target: "String", proto: true, forced: !correctIsRegExpLogic("includes") }, {
      includes: function includes(searchString) {
        return !!~stringIndexOf(
          toString(requireObjectCoercible(this)),
          toString(notARegExp(searchString)),
          arguments.length > 1 ? arguments[1] : void 0
        );
      }
    });
  }
});

// node_modules/core-js/internals/collection-weak.js
var require_collection_weak = __commonJS({
  "node_modules/core-js/internals/collection-weak.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var defineBuiltIns = require_define_built_ins();
    var getWeakData = require_internal_metadata().getWeakData;
    var anInstance = require_an_instance();
    var anObject = require_an_object();
    var isNullOrUndefined = require_is_null_or_undefined();
    var isObject = require_is_object();
    var iterate = require_iterate();
    var ArrayIterationModule = require_array_iteration();
    var hasOwn = require_has_own_property();
    var InternalStateModule = require_internal_state();
    var setInternalState = InternalStateModule.set;
    var internalStateGetterFor = InternalStateModule.getterFor;
    var find = ArrayIterationModule.find;
    var findIndex = ArrayIterationModule.findIndex;
    var splice = uncurryThis([].splice);
    var id = 0;
    var uncaughtFrozenStore = function(state) {
      return state.frozen || (state.frozen = new UncaughtFrozenStore());
    };
    var UncaughtFrozenStore = function() {
      this.entries = [];
    };
    var findUncaughtFrozen = function(store, key) {
      return find(store.entries, function(it) {
        return it[0] === key;
      });
    };
    UncaughtFrozenStore.prototype = {
      get: function(key) {
        var entry = findUncaughtFrozen(this, key);
        if (entry) return entry[1];
      },
      has: function(key) {
        return !!findUncaughtFrozen(this, key);
      },
      set: function(key, value) {
        var entry = findUncaughtFrozen(this, key);
        if (entry) entry[1] = value;
        else this.entries.push([key, value]);
      },
      "delete": function(key) {
        var index = findIndex(this.entries, function(it) {
          return it[0] === key;
        });
        if (~index) splice(this.entries, index, 1);
        return !!~index;
      }
    };
    module.exports = {
      getConstructor: function(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
        var Constructor = wrapper(function(that, iterable) {
          anInstance(that, Prototype);
          setInternalState(that, {
            type: CONSTRUCTOR_NAME,
            id: id++,
            frozen: null
          });
          if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
        });
        var Prototype = Constructor.prototype;
        var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);
        var define2 = function(that, key, value) {
          var state = getInternalState(that);
          var data = getWeakData(anObject(key), true);
          if (data === true) uncaughtFrozenStore(state).set(key, value);
          else data[state.id] = value;
          return that;
        };
        defineBuiltIns(Prototype, {
          // `{ WeakMap, WeakSet }.prototype.delete(key)` methods
          // https://tc39.es/ecma262/#sec-weakmap.prototype.delete
          // https://tc39.es/ecma262/#sec-weakset.prototype.delete
          "delete": function(key) {
            var state = getInternalState(this);
            if (!isObject(key)) return false;
            var data = getWeakData(key);
            if (data === true) return uncaughtFrozenStore(state)["delete"](key);
            return data && hasOwn(data, state.id) && delete data[state.id];
          },
          // `{ WeakMap, WeakSet }.prototype.has(key)` methods
          // https://tc39.es/ecma262/#sec-weakmap.prototype.has
          // https://tc39.es/ecma262/#sec-weakset.prototype.has
          has: function has(key) {
            var state = getInternalState(this);
            if (!isObject(key)) return false;
            var data = getWeakData(key);
            if (data === true) return uncaughtFrozenStore(state).has(key);
            return data && hasOwn(data, state.id);
          }
        });
        defineBuiltIns(Prototype, IS_MAP ? {
          // `WeakMap.prototype.get(key)` method
          // https://tc39.es/ecma262/#sec-weakmap.prototype.get
          get: function get(key) {
            var state = getInternalState(this);
            if (isObject(key)) {
              var data = getWeakData(key);
              if (data === true) return uncaughtFrozenStore(state).get(key);
              if (data) return data[state.id];
            }
          },
          // `WeakMap.prototype.set(key, value)` method
          // https://tc39.es/ecma262/#sec-weakmap.prototype.set
          set: function set(key, value) {
            return define2(this, key, value);
          }
        } : {
          // `WeakSet.prototype.add(value)` method
          // https://tc39.es/ecma262/#sec-weakset.prototype.add
          add: function add(value) {
            return define2(this, value, true);
          }
        });
        return Constructor;
      }
    };
  }
});

// node_modules/core-js/modules/es.weak-set.constructor.js
var require_es_weak_set_constructor = __commonJS({
  "node_modules/core-js/modules/es.weak-set.constructor.js"() {
    "use strict";
    var collection = require_collection();
    var collectionWeak = require_collection_weak();
    collection("WeakSet", function(init) {
      return function WeakSet2() {
        return init(this, arguments.length ? arguments[0] : void 0);
      };
    }, collectionWeak);
  }
});

// node_modules/core-js/modules/es.weak-set.js
var require_es_weak_set = __commonJS({
  "node_modules/core-js/modules/es.weak-set.js"() {
    "use strict";
    require_es_weak_set_constructor();
  }
});

// node_modules/@twilio/deprecation-decorator/node_modules/loglevel/lib/loglevel.js
var require_loglevel2 = __commonJS({
  "node_modules/@twilio/deprecation-decorator/node_modules/loglevel/lib/loglevel.js"(exports, module) {
    (function(root, definition) {
      "use strict";
      if (typeof define === "function" && define.amd) {
        define(definition);
      } else if (typeof module === "object" && module.exports) {
        module.exports = definition();
      } else {
        root.log = definition();
      }
    })(exports, function() {
      "use strict";
      var noop = function() {
      };
      var undefinedType = "undefined";
      var isIE = typeof window !== undefinedType && typeof window.navigator !== undefinedType && /Trident\/|MSIE /.test(window.navigator.userAgent);
      var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
      ];
      function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === "function") {
          return method.bind(obj);
        } else {
          try {
            return Function.prototype.bind.call(method, obj);
          } catch (e) {
            return function() {
              return Function.prototype.apply.apply(method, [obj, arguments]);
            };
          }
        }
      }
      function traceForIE() {
        if (console.log) {
          if (console.log.apply) {
            console.log.apply(console, arguments);
          } else {
            Function.prototype.apply.apply(console.log, [console, arguments]);
          }
        }
        if (console.trace) console.trace();
      }
      function realMethod(methodName) {
        if (methodName === "debug") {
          methodName = "log";
        }
        if (typeof console === undefinedType) {
          return false;
        } else if (methodName === "trace" && isIE) {
          return traceForIE;
        } else if (console[methodName] !== void 0) {
          return bindMethod(console, methodName);
        } else if (console.log !== void 0) {
          return bindMethod(console, "log");
        } else {
          return noop;
        }
      }
      function replaceLoggingMethods(level, loggerName) {
        for (var i = 0; i < logMethods.length; i++) {
          var methodName = logMethods[i];
          this[methodName] = i < level ? noop : this.methodFactory(methodName, level, loggerName);
        }
        this.log = this.debug;
      }
      function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
        return function() {
          if (typeof console !== undefinedType) {
            replaceLoggingMethods.call(this, level, loggerName);
            this[methodName].apply(this, arguments);
          }
        };
      }
      function defaultMethodFactory(methodName, level, loggerName) {
        return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);
      }
      function Logger(name, defaultLevel, factory) {
        var self2 = this;
        var currentLevel;
        defaultLevel = defaultLevel == null ? "WARN" : defaultLevel;
        var storageKey = "loglevel";
        if (typeof name === "string") {
          storageKey += ":" + name;
        } else if (typeof name === "symbol") {
          storageKey = void 0;
        }
        function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || "silent").toUpperCase();
          if (typeof window === undefinedType || !storageKey) return;
          try {
            window.localStorage[storageKey] = levelName;
            return;
          } catch (ignore) {
          }
          try {
            window.document.cookie = encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {
          }
        }
        function getPersistedLevel() {
          var storedLevel;
          if (typeof window === undefinedType || !storageKey) return;
          try {
            storedLevel = window.localStorage[storageKey];
          } catch (ignore) {
          }
          if (typeof storedLevel === undefinedType) {
            try {
              var cookie = window.document.cookie;
              var location = cookie.indexOf(
                encodeURIComponent(storageKey) + "="
              );
              if (location !== -1) {
                storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
              }
            } catch (ignore) {
            }
          }
          if (self2.levels[storedLevel] === void 0) {
            storedLevel = void 0;
          }
          return storedLevel;
        }
        function clearPersistedLevel() {
          if (typeof window === undefinedType || !storageKey) return;
          try {
            window.localStorage.removeItem(storageKey);
            return;
          } catch (ignore) {
          }
          try {
            window.document.cookie = encodeURIComponent(storageKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
          } catch (ignore) {
          }
        }
        self2.name = name;
        self2.levels = {
          "TRACE": 0,
          "DEBUG": 1,
          "INFO": 2,
          "WARN": 3,
          "ERROR": 4,
          "SILENT": 5
        };
        self2.methodFactory = factory || defaultMethodFactory;
        self2.getLevel = function() {
          return currentLevel;
        };
        self2.setLevel = function(level, persist) {
          if (typeof level === "string" && self2.levels[level.toUpperCase()] !== void 0) {
            level = self2.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self2.levels.SILENT) {
            currentLevel = level;
            if (persist !== false) {
              persistLevelIfPossible(level);
            }
            replaceLoggingMethods.call(self2, level, name);
            if (typeof console === undefinedType && level < self2.levels.SILENT) {
              return "No console available for logging";
            }
          } else {
            throw "log.setLevel() called with invalid level: " + level;
          }
        };
        self2.setDefaultLevel = function(level) {
          defaultLevel = level;
          if (!getPersistedLevel()) {
            self2.setLevel(level, false);
          }
        };
        self2.resetLevel = function() {
          self2.setLevel(defaultLevel, false);
          clearPersistedLevel();
        };
        self2.enableAll = function(persist) {
          self2.setLevel(self2.levels.TRACE, persist);
        };
        self2.disableAll = function(persist) {
          self2.setLevel(self2.levels.SILENT, persist);
        };
        var initialLevel = getPersistedLevel();
        if (initialLevel == null) {
          initialLevel = defaultLevel;
        }
        self2.setLevel(initialLevel, false);
      }
      var defaultLogger = new Logger();
      var _loggersByName = {};
      defaultLogger.getLogger = function getLogger(name) {
        if (typeof name !== "symbol" && typeof name !== "string" || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }
        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name,
            defaultLogger.getLevel(),
            defaultLogger.methodFactory
          );
        }
        return logger;
      };
      var _log = typeof window !== undefinedType ? window.log : void 0;
      defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType && window.log === defaultLogger) {
          window.log = _log;
        }
        return defaultLogger;
      };
      defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
      };
      defaultLogger["default"] = defaultLogger;
      return defaultLogger;
    });
  }
});

// node_modules/@twilio/deprecation-decorator/builds/browser.js
var require_browser11 = __commonJS({
  "node_modules/@twilio/deprecation-decorator/builds/browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    require_es_array_concat();
    var log = require_loglevel2();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var log__default = _interopDefaultLegacy(log);
    var deprecated = function deprecated2(oldName, newName, link) {
      return function(target, propertyKey, descriptor) {
        if (typeof descriptor.value !== "function" && (descriptor === null || descriptor === void 0 ? void 0 : descriptor.get) === void 0) {
          throw new Error("The deprecated decorator can only be applied to methods or getters");
        }
        if (typeof descriptor.value === "function") {
          var originalMethod = descriptor.value;
          descriptor.value = function() {
            deprecationWarning("The method ".concat(oldName, " is deprecated").concat(newName ? ", use " + newName + " instead" : "").concat(link ? ", " + link : "."));
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return originalMethod.apply(this, args);
          };
          return;
        }
        var originalGet = descriptor.get;
        descriptor.get = function() {
          deprecationWarning("The getter ".concat(oldName, " is deprecated").concat(newName ? ", use " + newName + " instead" : "").concat(link ? ", " + link : "."));
          return originalGet === null || originalGet === void 0 ? void 0 : originalGet.apply(this);
        };
      };
    };
    var deprecationWarning = function deprecationWarning2(warning) {
      var currentLevel = log__default["default"].getLevel();
      log__default["default"].setLevel("warn");
      log__default["default"].warn(warning);
      log__default["default"].setLevel(currentLevel);
    };
    exports.deprecated = deprecated;
    exports.deprecationWarning = deprecationWarning;
  }
});

// node_modules/core-js/modules/es.array.find.js
var require_es_array_find = __commonJS({
  "node_modules/core-js/modules/es.array.find.js"() {
    "use strict";
    var $ = require_export();
    var $find = require_array_iteration().find;
    var addToUnscopables = require_add_to_unscopables();
    var FIND = "find";
    var SKIPS_HOLES = true;
    if (FIND in []) Array(1)[FIND](function() {
      SKIPS_HOLES = false;
    });
    $({ target: "Array", proto: true, forced: SKIPS_HOLES }, {
      find: function find(callbackfn) {
        return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
    addToUnscopables(FIND);
  }
});

// node_modules/core-js/modules/es.object.freeze.js
var require_es_object_freeze = __commonJS({
  "node_modules/core-js/modules/es.object.freeze.js"() {
    "use strict";
    var $ = require_export();
    var FREEZING = require_freezing();
    var fails = require_fails();
    var isObject = require_is_object();
    var onFreeze = require_internal_metadata().onFreeze;
    var $freeze = Object.freeze;
    var FAILS_ON_PRIMITIVES = fails(function() {
      $freeze(1);
    });
    $({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES, sham: !FREEZING }, {
      freeze: function freeze(it) {
        return $freeze && isObject(it) ? $freeze(onFreeze(it)) : it;
      }
    });
  }
});

// node_modules/@twilio/conversations/builds/browser.js
var require_browser12 = __commonJS({
  "node_modules/@twilio/conversations/builds/browser.js"(exports) {
    var global2 = typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
    Object.defineProperty(exports, "__esModule", { value: true });
    require_es_reflect_to_string_tag();
    require_es_reflect_construct();
    require_es_object_keys();
    require_es_symbol();
    require_es_array_filter();
    require_es_object_get_own_property_descriptor();
    require_es_object_get_own_property_descriptors();
    var _asyncToGenerator = require_asyncToGenerator();
    var _assertThisInitialized = require_assertThisInitialized();
    var _inherits = require_inherits();
    var _possibleConstructorReturn = require_possibleConstructorReturn();
    var _getPrototypeOf = require_getPrototypeOf();
    var _defineProperty = require_defineProperty();
    var _createClass = require_createClass();
    var _classCallCheck = require_classCallCheck();
    require_es_array_map();
    require_es_object_to_string();
    require_web_dom_collections_for_each();
    require_es_promise();
    var _regeneratorRuntime = require_regenerator2();
    var _typeof = require_typeof();
    require_es_array_concat();
    require_es_array_from();
    require_es_string_iterator();
    var loglevelLog = require_loglevel();
    var iso8601Duration = (init_src(), __toCommonJS(src_exports));
    require_es_array_iterator();
    require_web_dom_collections_iterator();
    require_es_json_stringify();
    require_es_number_constructor();
    require_es_regexp_exec();
    require_es_string_replace();
    require_es_array_join();
    var declarativeTypeValidator = require_browser();
    var _toConsumableArray = require_toConsumableArray();
    require_es_array_includes();
    var replayEventEmitter = require_browser2();
    var isEqual = require_lodash();
    require_es_array_slice();
    require_es_function_name();
    require_es_regexp_test();
    require_es_symbol_description();
    require_es_symbol_iterator();
    var _slicedToArray = require_slicedToArray();
    require_es_map();
    var operationRetrier = require_browser3();
    var twilsock = require_browser5();
    var notifications = require_browser6();
    var twilioSync = require_browser8();
    var mcsClient = require_browser9();
    require_es_set();
    require_es_number_is_integer();
    require_es_typed_array_uint8_array();
    require_es_typed_array_at();
    require_es_typed_array_copy_within();
    require_es_typed_array_every();
    require_es_typed_array_fill();
    require_es_typed_array_filter();
    require_es_typed_array_find();
    require_es_typed_array_find_index();
    require_es_typed_array_for_each();
    require_es_typed_array_includes();
    require_es_typed_array_index_of();
    require_es_typed_array_iterator();
    require_es_typed_array_join();
    require_es_typed_array_last_index_of();
    require_es_typed_array_map();
    require_es_typed_array_reduce();
    require_es_typed_array_reduce_right();
    require_es_typed_array_reverse();
    require_es_typed_array_set();
    require_es_typed_array_slice();
    require_es_typed_array_some();
    require_es_typed_array_sort();
    require_es_typed_array_subarray();
    require_es_typed_array_to_locale_string();
    require_es_typed_array_to_string();
    require_es_array_buffer_constructor();
    require_browser10();
    require_es_array_sort();
    require_es_string_includes();
    require_es_string_starts_with();
    require_es_weak_set();
    var deprecationDecorator = require_browser11();
    require_es_object_entries();
    require_es_array_find();
    require_es_array_splice();
    var _wrapNativeSuper = require_wrapNativeSuper();
    var uuid = require_uuid2();
    require_es_object_freeze();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    function _interopNamespace(e) {
      if (e && e.__esModule) return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var _asyncToGenerator__default = _interopDefaultLegacy(_asyncToGenerator);
    var _assertThisInitialized__default = _interopDefaultLegacy(_assertThisInitialized);
    var _inherits__default = _interopDefaultLegacy(_inherits);
    var _possibleConstructorReturn__default = _interopDefaultLegacy(_possibleConstructorReturn);
    var _getPrototypeOf__default = _interopDefaultLegacy(_getPrototypeOf);
    var _defineProperty__default = _interopDefaultLegacy(_defineProperty);
    var _createClass__default = _interopDefaultLegacy(_createClass);
    var _classCallCheck__default = _interopDefaultLegacy(_classCallCheck);
    var _regeneratorRuntime__default = _interopDefaultLegacy(_regeneratorRuntime);
    var _typeof__default = _interopDefaultLegacy(_typeof);
    var loglevelLog__namespace = _interopNamespace(loglevelLog);
    var _toConsumableArray__default = _interopDefaultLegacy(_toConsumableArray);
    var isEqual__default = _interopDefaultLegacy(isEqual);
    var _slicedToArray__default = _interopDefaultLegacy(_slicedToArray);
    var _wrapNativeSuper__default = _interopDefaultLegacy(_wrapNativeSuper);
    function __decorate(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ((typeof Reflect === "undefined" ? "undefined" : _typeof__default["default"](Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      }
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __metadata(metadataKey, metadataValue) {
      if ((typeof Reflect === "undefined" ? "undefined" : _typeof__default["default"](Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }
    function prepareLine(prefix, args) {
      return ["".concat((/* @__PURE__ */ new Date()).toISOString(), " Conversations ").concat(prefix, ":")].concat(Array.from(args));
    }
    var log$7 = loglevelLog__namespace.getLogger("twilio-conversations");
    var Logger = function() {
      function Logger2(prefix) {
        _classCallCheck__default["default"](this, Logger2);
        _defineProperty__default["default"](this, "prefix", "");
        this.prefix = prefix !== null && prefix !== void 0 && prefix.length > 0 ? prefix + " " : "";
      }
      _createClass__default["default"](Logger2, [{
        key: "setLevel",
        value: function setLevel(level) {
          log$7.setLevel(level);
        }
      }, {
        key: "trace",
        value: function trace() {
          if (log$7.getLevel() == log$7.levels.TRACE) {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            log$7.debug.apply(null, prepareLine(this.prefix + "T", args));
          }
        }
      }, {
        key: "debug",
        value: function debug() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          log$7.debug.apply(null, prepareLine(this.prefix + "D", args));
        }
      }, {
        key: "info",
        value: function info() {
          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }
          log$7.info.apply(null, prepareLine(this.prefix + "I", args));
        }
      }, {
        key: "warn",
        value: function warn() {
          for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args[_key4] = arguments[_key4];
          }
          log$7.warn.apply(null, prepareLine(this.prefix + "W", args));
        }
      }, {
        key: "error",
        value: function error() {
          for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
            args[_key5] = arguments[_key5];
          }
          log$7.error.apply(null, prepareLine(this.prefix + "E", args));
        }
      }], [{
        key: "scope",
        value: function scope(prefix) {
          return new Logger2(prefix);
        }
      }, {
        key: "setLevel",
        value: function setLevel(level) {
          log$7.setLevel(level);
        }
      }, {
        key: "trace",
        value: function trace() {
          if (log$7.getLevel() == log$7.levels.TRACE) {
            for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
              args[_key6] = arguments[_key6];
            }
            log$7.debug.apply(null, prepareLine("T", args));
          }
        }
      }, {
        key: "debug",
        value: function debug() {
          for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
            args[_key7] = arguments[_key7];
          }
          log$7.debug.apply(null, prepareLine("D", args));
        }
      }, {
        key: "info",
        value: function info() {
          for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
            args[_key8] = arguments[_key8];
          }
          log$7.info.apply(null, prepareLine("I", args));
        }
      }, {
        key: "warn",
        value: function warn() {
          for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
            args[_key9] = arguments[_key9];
          }
          log$7.warn.apply(null, prepareLine("W", args));
        }
      }, {
        key: "error",
        value: function error() {
          for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
            args[_key10] = arguments[_key10];
          }
          log$7.error.apply(null, prepareLine("E", args));
        }
      }]);
      return Logger2;
    }();
    function ownKeys$5(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread$5(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys$5(Object(source), true).forEach(function(key) {
          _defineProperty__default["default"](target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$5(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    var TYPING_TIMEOUT = 5;
    var HTTP_CACHE_LIFETIME = "PT5S";
    var CONSUMPTION_HORIZON_SENDING_INTERVAL = "PT5S";
    var USER_INFOS_TO_SUBSCRIBE = 100;
    var MINIMUM_RETRY_DELAY = 1e3;
    var MAXIMUM_RETRY_DELAY = 4e3;
    var MAXIMUM_ATTEMPTS_COUNT = 3;
    var RETRY_WHEN_THROTTLED = true;
    var CHANNEL_METADATA_CACHE_CAPACITY = 100;
    var MESSAGE_RECIPIENTS_CACHE_CAPACITY = 1e3;
    var Configuration = _createClass__default["default"](function Configuration2() {
      var _ref, _constructorOptions$u, _ref2, _constructorOptions$h, _ref3, _constructorOptions$c, _options$channelMetad, _options$messageRecip;
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var configurationResponse = arguments.length > 1 ? arguments[1] : void 0;
      var logger = arguments.length > 2 ? arguments[2] : void 0;
      _classCallCheck__default["default"](this, Configuration2);
      _defineProperty__default["default"](this, "typingIndicatorTimeoutDefault", TYPING_TIMEOUT * 1e3);
      var constructorOptions = options.Chat || options.IPMessaging || options || {};
      this.productId = constructorOptions.productId;
      this.links = {
        myConversations: configurationResponse.links.my_conversations,
        conversations: configurationResponse.links.conversations,
        users: configurationResponse.links.users,
        currentUser: configurationResponse.links.current_user,
        typing: configurationResponse.links.typing,
        mediaService: configurationResponse.links.media_service,
        mediaSetService: configurationResponse.links.media_set_service,
        messagesReceipts: configurationResponse.links.messages_receipts
      };
      this.limits = {
        mediaAttachmentsCountLimit: configurationResponse.options.media_attachments_count_limit,
        mediaAttachmentSizeLimitInMb: configurationResponse.options.media_attachment_size_limit_in_mb,
        mediaAttachmentsTotalSizeLimitInMb: configurationResponse.options.media_attachments_total_size_limit_in_mb,
        emailHistoriesAllowedContentTypes: configurationResponse.options.email_histories_allowed_mime_types,
        emailBodiesAllowedContentTypes: configurationResponse.options.email_bodies_allowed_mime_types
      };
      this.typingIndicatorTimeoutOverride = constructorOptions.typingIndicatorTimeoutOverride;
      this.backoffConfiguration = _objectSpread$5({
        min: MINIMUM_RETRY_DELAY,
        max: MAXIMUM_RETRY_DELAY,
        maxAttemptsCount: MAXIMUM_ATTEMPTS_COUNT
      }, constructorOptions.backoffConfigOverride);
      this.retryWhenThrottled = constructorOptions.retryWhenThrottledOverride !== void 0 ? constructorOptions.retryWhenThrottledOverride : RETRY_WHEN_THROTTLED;
      this.userInfosToSubscribe = (_ref = (_constructorOptions$u = constructorOptions.userInfosToSubscribeOverride) !== null && _constructorOptions$u !== void 0 ? _constructorOptions$u : configurationResponse.options.user_infos_to_subscribe) !== null && _ref !== void 0 ? _ref : USER_INFOS_TO_SUBSCRIBE;
      this.reachabilityEnabled = configurationResponse.options.reachability_enabled;
      this.userIdentity = configurationResponse.identity;
      this.userInfo = configurationResponse.sync_objects.my_user_info;
      this.myConversations = configurationResponse.sync_objects.my_conversations;
      var httpCacheInterval = (_ref2 = (_constructorOptions$h = constructorOptions.httpCacheIntervalOverride) !== null && _constructorOptions$h !== void 0 ? _constructorOptions$h : configurationResponse.options.http_cache_interval) !== null && _ref2 !== void 0 ? _ref2 : HTTP_CACHE_LIFETIME;
      try {
        this.httpCacheInterval = iso8601Duration.toSeconds(iso8601Duration.parse(httpCacheInterval));
      } catch (_unused) {
        logger.error("Failed to parse http cache interval ".concat(httpCacheInterval, ", using default value ").concat(HTTP_CACHE_LIFETIME));
        this.httpCacheInterval = iso8601Duration.toSeconds(iso8601Duration.parse(HTTP_CACHE_LIFETIME));
      }
      var consumptionReportInterval = (_ref3 = (_constructorOptions$c = constructorOptions.consumptionReportIntervalOverride) !== null && _constructorOptions$c !== void 0 ? _constructorOptions$c : configurationResponse.options.consumption_report_interval) !== null && _ref3 !== void 0 ? _ref3 : CONSUMPTION_HORIZON_SENDING_INTERVAL;
      try {
        this.consumptionReportInterval = iso8601Duration.toSeconds(iso8601Duration.parse(consumptionReportInterval));
      } catch (_unused2) {
        logger.error("Failed to parse consumption report interval ".concat(consumptionReportInterval, ", using default value ").concat(CONSUMPTION_HORIZON_SENDING_INTERVAL));
        this.consumptionReportInterval = iso8601Duration.toSeconds(iso8601Duration.parse(CONSUMPTION_HORIZON_SENDING_INTERVAL));
      }
      this.channelMetadataCacheCapacity = (_options$channelMetad = options.channelMetadataCacheCapacity) !== null && _options$channelMetad !== void 0 ? _options$channelMetad : CHANNEL_METADATA_CACHE_CAPACITY;
      this.messageRecipientsCacheCapacity = (_options$messageRecip = options.messageRecipientsCacheCapacity) !== null && _options$messageRecip !== void 0 ? _options$messageRecip : MESSAGE_RECIPIENTS_CACHE_CAPACITY;
    });
    function deepClone(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
    function parseToNumber(value) {
      if (typeof value !== "undefined" && !isNaN(Number(value))) {
        return Number(value);
      }
      return null;
    }
    function parseTime(timeString) {
      try {
        return new Date(timeString);
      } catch (e) {
        return null;
      }
    }
    function parseAttributes(rawAttributes, warningMessage, log2) {
      var attributes = {};
      if (rawAttributes) {
        try {
          attributes = JSON.parse(rawAttributes);
        } catch (e) {
          log2.warn(warningMessage, e);
        }
      }
      return attributes;
    }
    var UriBuilder = function() {
      function UriBuilder2(base) {
        _classCallCheck__default["default"](this, UriBuilder2);
        this.base = base.replace(/\/$/, "");
        this.args = [];
        this.paths = [];
      }
      _createClass__default["default"](UriBuilder2, [{
        key: "arg",
        value: function arg(name, value) {
          if (typeof value !== "undefined") {
            this.args.push(encodeURIComponent(name) + "=" + encodeURIComponent(value));
          }
          return this;
        }
      }, {
        key: "path",
        value: function path(name) {
          this.paths.push(encodeURIComponent(name));
          return this;
        }
      }, {
        key: "build",
        value: function build() {
          var result = this.base;
          if (this.paths.length) {
            result += "/" + this.paths.join("/");
          }
          if (this.args.length) {
            result += "?" + this.args.join("&");
          }
          return result;
        }
      }]);
      return UriBuilder2;
    }();
    var json = declarativeTypeValidator.custom(function(value) {
      return [["string", "number", "boolean", "object"].includes(_typeof__default["default"](value)), "a JSON type"];
    });
    var optionalJson = declarativeTypeValidator.custom(function(value) {
      return [["undefined", "string", "number", "boolean", "object"].includes(_typeof__default["default"](value)), "an optional JSON type"];
    });
    var sendMediaOptions = declarativeTypeValidator.objectSchema("send media options", {
      contentType: [declarativeTypeValidator.literal(null), "string"],
      filename: ["string", "undefined"],
      media: [declarativeTypeValidator.literal("null"), "string"].concat(_toConsumableArray__default["default"](typeof Buffer === "function" ? [Buffer] : []), _toConsumableArray__default["default"](typeof Blob === "function" ? [Blob] : []))
    });
    function _createSuper$9(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$9();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$9() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var log$6 = Logger.scope("User");
    var User = function(_ReplayEventEmitter) {
      _inherits__default["default"](User2, _ReplayEventEmitter);
      var _super = _createSuper$9(User2);
      function User2(identity, entityName, configuration, services) {
        var _this;
        _classCallCheck__default["default"](this, User2);
        _this = _super.call(this);
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "promiseToFetch", null);
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "updated", "updated");
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "userSubscribed", "userSubscribed");
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "userUnsubscribed", "userUnsubscribed");
        _this.services = services;
        _this.subscribed = "initializing";
        _this.setMaxListeners(0);
        _this.state = {
          identity,
          entityName,
          friendlyName: null,
          attributes: {},
          online: null,
          notifiable: null
        };
        _this._initializationPromise = new Promise(function(resolve) {
          _this._resolveInitializationPromise = resolve;
        });
        if (configuration !== null) {
          _this._resolveInitialization(configuration, identity, entityName, false);
        }
        return _this;
      }
      _createClass__default["default"](User2, [{
        key: "identity",
        get: (
          /**
           * User identity.
           */
          function get() {
            return this.state.identity;
          }
        ),
        set: function set(identity) {
          this.state.identity = identity;
        }
      }, {
        key: "entityName",
        set: function set(name) {
          this.state.entityName = name;
        }
        /**
         * Custom attributes of the user.
         */
      }, {
        key: "attributes",
        get: function get() {
          return this.state.attributes;
        }
        /**
         * Friendly name of the user, null if not set.
         */
      }, {
        key: "friendlyName",
        get: function get() {
          return this.state.friendlyName;
        }
        /**
         * Status of the real-time conversation connection of the user.
         */
      }, {
        key: "isOnline",
        get: function get() {
          return this.state.online;
        }
        /**
         * User push notification registration status.
         */
      }, {
        key: "isNotifiable",
        get: function get() {
          return this.state.notifiable;
        }
        /**
         * True if this user is receiving real-time status updates.
         */
      }, {
        key: "isSubscribed",
        get: function get() {
          return this.subscribed == "subscribed";
        }
        // Handles service updates
      }, {
        key: "_update",
        value: function() {
          var _update2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee(key, value) {
            var updateReasons, updateAttributes;
            return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return this._initializationPromise;
                  case 2:
                    updateReasons = [];
                    log$6.debug("User for", this.state.identity, "updated:", key, value);
                    _context.t0 = key;
                    _context.next = _context.t0 === "friendlyName" ? 7 : _context.t0 === "attributes" ? 9 : _context.t0 === "reachability" ? 12 : 15;
                    break;
                  case 7:
                    if (this.state.friendlyName !== value.value) {
                      updateReasons.push("friendlyName");
                      this.state.friendlyName = value.value;
                    }
                    return _context.abrupt("break", 16);
                  case 9:
                    updateAttributes = parseAttributes(value.value, "Retrieved malformed attributes from the server for user: ".concat(this.state.identity), log$6);
                    if (!isEqual__default["default"](this.state.attributes, updateAttributes)) {
                      this.state.attributes = updateAttributes;
                      updateReasons.push("attributes");
                    }
                    return _context.abrupt("break", 16);
                  case 12:
                    if (this.state.online !== value.online) {
                      this.state.online = value.online;
                      updateReasons.push("reachabilityOnline");
                    }
                    if (this.state.notifiable !== value.notifiable) {
                      this.state.notifiable = value.notifiable;
                      updateReasons.push("reachabilityNotifiable");
                    }
                    return _context.abrupt("break", 16);
                  case 15:
                    return _context.abrupt("return");
                  case 16:
                    if (updateReasons.length > 0) {
                      this.emit("updated", {
                        user: this,
                        updateReasons
                      });
                    }
                  case 17:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function _update(_x, _x2) {
            return _update2.apply(this, arguments);
          }
          return _update;
        }()
        // Fetch reachability info
      }, {
        key: "_updateReachabilityInfo",
        value: function() {
          var _updateReachabilityInfo2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee2(map, update) {
            var _this2 = this;
            return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.next = 2;
                    return this._initializationPromise;
                  case 2:
                    if (this.configuration.reachabilityEnabled) {
                      _context2.next = 4;
                      break;
                    }
                    return _context2.abrupt("return", Promise.resolve());
                  case 4:
                    return _context2.abrupt("return", map.get("reachability").then(update).catch(function(err) {
                      log$6.warn("Failed to get reachability info for ", _this2.state.identity, err);
                    }));
                  case 5:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function _updateReachabilityInfo(_x3, _x4) {
            return _updateReachabilityInfo2.apply(this, arguments);
          }
          return _updateReachabilityInfo;
        }()
        // Fetch user
      }, {
        key: "_fetch",
        value: function() {
          var _fetch2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee3() {
            var _this3 = this;
            return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    _context3.next = 2;
                    return this._initializationPromise;
                  case 2:
                    if (this.state.entityName) {
                      _context3.next = 4;
                      break;
                    }
                    return _context3.abrupt("return", this);
                  case 4:
                    this.promiseToFetch = this.services.syncClient.map({
                      id: this.state.entityName,
                      mode: "open_existing",
                      includeItems: true
                    }).then(function(map) {
                      _this3.entity = map;
                      map.on("itemUpdated", function(args) {
                        log$6.debug(_this3.state.entityName + " (" + _this3.state.identity + ") itemUpdated: " + args.item.key);
                        return _this3._update(args.item.key, args.item.data);
                      });
                      map.on("itemAdded", function(args) {
                        log$6.debug(_this3.state.entityName + " (" + _this3.state.identity + ") itemAdded: " + args.item.key);
                        return _this3._update(args.item.key, args.item.data);
                      });
                      return Promise.all([map.get("friendlyName").then(function(item) {
                        return _this3._update(item.key, item.data);
                      }), map.get("attributes").then(function(item) {
                        return _this3._update(item.key, item.data);
                      }), _this3._updateReachabilityInfo(map, function(item) {
                        return _this3._update(item.key, item.data);
                      })]);
                    }).then(function() {
                      log$6.debug("Fetched for", _this3.identity);
                      _this3.subscribed = "subscribed";
                      _this3.emit("userSubscribed", _this3);
                      return _this3;
                    }).catch(function(err) {
                      _this3.promiseToFetch = null;
                      throw err;
                    });
                    return _context3.abrupt("return", this.promiseToFetch);
                  case 6:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));
          function _fetch() {
            return _fetch2.apply(this, arguments);
          }
          return _fetch;
        }()
      }, {
        key: "_ensureFetched",
        value: function() {
          var _ensureFetched2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee4() {
            return _regeneratorRuntime__default["default"].wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    _context4.next = 2;
                    return this._initializationPromise;
                  case 2:
                    return _context4.abrupt("return", this.promiseToFetch || this._fetch());
                  case 3:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));
          function _ensureFetched() {
            return _ensureFetched2.apply(this, arguments);
          }
          return _ensureFetched;
        }()
        /**
         * Edit user attributes.
         * @param attributes New attributes.
         */
      }, {
        key: "updateAttributes",
        value: function() {
          var _updateAttributes = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee5(attributes) {
            return _regeneratorRuntime__default["default"].wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    _context5.next = 2;
                    return this._initializationPromise;
                  case 2:
                    if (!(this.subscribed == "unsubscribed")) {
                      _context5.next = 4;
                      break;
                    }
                    throw new Error("Can't modify unsubscribed object");
                  case 4:
                    _context5.next = 6;
                    return this.services.commandExecutor.mutateResource("post", this.links.self, {
                      attributes: JSON.stringify(attributes)
                    });
                  case 6:
                    return _context5.abrupt("return", this);
                  case 7:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));
          function updateAttributes(_x5) {
            return _updateAttributes.apply(this, arguments);
          }
          return updateAttributes;
        }()
        /**
         * Update the friendly name of the user.
         * @param friendlyName New friendly name.
         */
      }, {
        key: "updateFriendlyName",
        value: function() {
          var _updateFriendlyName = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee6(friendlyName) {
            return _regeneratorRuntime__default["default"].wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    _context6.next = 2;
                    return this._initializationPromise;
                  case 2:
                    if (!(this.subscribed == "unsubscribed")) {
                      _context6.next = 4;
                      break;
                    }
                    throw new Error("Can't modify unsubscribed object");
                  case 4:
                    _context6.next = 6;
                    return this.services.commandExecutor.mutateResource("post", this.links.self, {
                      friendly_name: friendlyName
                    });
                  case 6:
                    return _context6.abrupt("return", this);
                  case 7:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, this);
          }));
          function updateFriendlyName(_x6) {
            return _updateFriendlyName.apply(this, arguments);
          }
          return updateFriendlyName;
        }()
        /**
         * Remove the user from the subscription list.
         * @return A promise of completion.
         */
      }, {
        key: "unsubscribe",
        value: function() {
          var _unsubscribe = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee7() {
            return _regeneratorRuntime__default["default"].wrap(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    _context7.next = 2;
                    return this._initializationPromise;
                  case 2:
                    if (!this.promiseToFetch) {
                      _context7.next = 9;
                      break;
                    }
                    _context7.next = 5;
                    return this.promiseToFetch;
                  case 5:
                    this.entity.close();
                    this.promiseToFetch = null;
                    this.subscribed = "unsubscribed";
                    this.emit("userUnsubscribed", this);
                  case 9:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee7, this);
          }));
          function unsubscribe() {
            return _unsubscribe.apply(this, arguments);
          }
          return unsubscribe;
        }()
      }, {
        key: "_resolveInitialization",
        value: function _resolveInitialization(configuration, identity, entityName, emitUpdated) {
          this.configuration = configuration;
          this.identity = identity;
          this.entityName = entityName;
          this.links = {
            self: "".concat(this.configuration.links.users, "/").concat(encodeURIComponent(this.identity))
          };
          this._resolveInitializationPromise();
          if (emitUpdated) {
            this.emit("updated", {
              user: this,
              updateReasons: ["friendlyName", "attributes", "reachabilityOnline", "reachabilityNotifiable"]
            });
          }
        }
      }]);
      return User2;
    }(replayEventEmitter.ReplayEventEmitter);
    __decorate([declarativeTypeValidator.validateTypesAsync(json), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", Promise)], User.prototype, "updateAttributes", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(["string"]), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", Promise)], User.prototype, "updateFriendlyName", null);
    function _createForOfIteratorHelper$5(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray$5(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      } };
    }
    function _unsupportedIterableToArray$5(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray$5(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(o, minLen);
    }
    function _arrayLikeToArray$5(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var Network = function() {
      function Network2(configuration, services) {
        _classCallCheck__default["default"](this, Network2);
        this.configuration = configuration;
        this.services = services;
        this.cache = /* @__PURE__ */ new Map();
        this.cacheLifetime = this.configuration.httpCacheInterval * 100;
        this.cleanupCache();
      }
      _createClass__default["default"](Network2, [{
        key: "isExpired",
        value: function isExpired(timestamp) {
          return !this.cacheLifetime || Date.now() - timestamp > this.cacheLifetime;
        }
      }, {
        key: "cleanupCache",
        value: function cleanupCache() {
          var _iterator = _createForOfIteratorHelper$5(this.cache), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var _step$value = _slicedToArray__default["default"](_step.value, 2), k = _step$value[0], v = _step$value[1];
              if (this.isExpired(v.timestamp)) {
                this.cache.delete(k);
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          if (this.cache.size === 0) {
            clearInterval(this.timer);
          }
        }
      }, {
        key: "pokeTimer",
        value: function pokeTimer() {
          var _this = this;
          this.timer = this.timer || setInterval(function() {
            return _this.cleanupCache();
          }, this.cacheLifetime * 2);
        }
      }, {
        key: "executeWithRetry",
        value: function executeWithRetry(request) {
          var _this2 = this;
          var retryWhenThrottled = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          return new Promise(function(resolve, reject) {
            var codesToRetryOn = [502, 503, 504];
            if (retryWhenThrottled) {
              codesToRetryOn.push(429);
            }
            var retrier = new operationRetrier.Retrier(_this2.configuration.backoffConfiguration);
            retrier.on("attempt", function() {
              request().then(function(result) {
                return retrier.succeeded(result);
              }).catch(function(err) {
                if (codesToRetryOn.indexOf(err.status) > -1) {
                  retrier.failed(err);
                } else if (err.message === "Twilsock disconnected") {
                  retrier.failed(err);
                } else {
                  retrier.removeAllListeners();
                  retrier.cancel();
                  reject(err);
                }
              });
            });
            retrier.on("succeeded", function(result) {
              resolve(result);
            });
            retrier.on("cancelled", function(err) {
              return reject(err);
            });
            retrier.on("failed", function(err) {
              return reject(err);
            });
            retrier.start();
          });
        }
      }, {
        key: "get",
        value: function() {
          var _get = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee(url) {
            var _this3 = this;
            var cacheEntry, headers, response;
            return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    cacheEntry = this.cache.get(url);
                    if (!(cacheEntry && !this.isExpired(cacheEntry.timestamp))) {
                      _context.next = 3;
                      break;
                    }
                    return _context.abrupt("return", cacheEntry.response);
                  case 3:
                    headers = {};
                    _context.next = 6;
                    return this.executeWithRetry(function() {
                      return _this3.services.transport.get(url, headers, _this3.configuration.productId);
                    }, this.configuration.retryWhenThrottled);
                  case 6:
                    response = _context.sent;
                    this.cache.set(url, {
                      response,
                      timestamp: Date.now()
                    });
                    this.pokeTimer();
                    return _context.abrupt("return", response);
                  case 10:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function get(_x) {
            return _get.apply(this, arguments);
          }
          return get;
        }()
      }]);
      return Network2;
    }();
    var NotificationTypes = _createClass__default["default"](function NotificationTypes2() {
      _classCallCheck__default["default"](this, NotificationTypes2);
    });
    _defineProperty__default["default"](NotificationTypes, "TYPING_INDICATOR", "twilio.ipmsg.typing_indicator");
    _defineProperty__default["default"](NotificationTypes, "NEW_MESSAGE", "twilio.conversations.new_message");
    _defineProperty__default["default"](NotificationTypes, "ADDED_TO_CONVERSATION", "twilio.conversations.added_to_conversation");
    _defineProperty__default["default"](NotificationTypes, "REMOVED_FROM_CONVERSATION", "twilio.conversations.removed_from_conversation");
    _defineProperty__default["default"](NotificationTypes, "CONSUMPTION_UPDATE", "twilio.channel.consumption_update");
    function _createSuper$8(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$8();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$8() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var log$5 = Logger.scope("Participant");
    var Participant = function(_ReplayEventEmitter) {
      _inherits__default["default"](Participant2, _ReplayEventEmitter);
      var _super = _createSuper$8(Participant2);
      function Participant2(data, sid, conversation, links, services) {
        var _data$roleSid, _data$bindings;
        var _this;
        _classCallCheck__default["default"](this, Participant2);
        _this = _super.call(this);
        _this.conversation = conversation;
        _this.links = links;
        _this.services = services;
        _this.state = {
          attributes: parseAttributes(data.attributes, "Retrieved malformed attributes from the server for participant: " + sid, log$5),
          dateCreated: data.dateCreated ? parseTime(data.dateCreated) : null,
          dateUpdated: data.dateCreated ? parseTime(data.dateUpdated) : null,
          sid,
          typingTimeout: null,
          isTyping: false,
          identity: data.identity,
          roleSid: (_data$roleSid = data.roleSid) !== null && _data$roleSid !== void 0 ? _data$roleSid : "",
          lastReadMessageIndex: Number.isInteger(data.lastConsumedMessageIndex) ? data.lastConsumedMessageIndex : null,
          lastReadTimestamp: data.lastConsumptionTimestamp ? parseTime(data.lastConsumptionTimestamp) : null,
          type: data.type || "chat",
          userInfo: data.userInfo,
          bindings: (_data$bindings = data.bindings) !== null && _data$bindings !== void 0 ? _data$bindings : {}
        };
        if (!data.identity && !data.type) {
          throw new Error("Received invalid Participant object from server: Missing identity or type of Participant.");
        }
        return _this;
      }
      _createClass__default["default"](Participant2, [{
        key: "sid",
        get: (
          /**
           * Conversation that the remote client is a participant of.
           */
          /**
           * The server-assigned unique identifier for the participant.
           */
          function get() {
            return this.state.sid;
          }
        )
        /**
         * Custom attributes of the participant.
         */
      }, {
        key: "attributes",
        get: function get() {
          return this.state.attributes;
        }
        /**
         * Date this participant was created on.
         */
      }, {
        key: "dateCreated",
        get: function get() {
          return this.state.dateCreated;
        }
        /**
         * Date this participant was last updated on.
         */
      }, {
        key: "dateUpdated",
        get: function get() {
          return this.state.dateUpdated;
        }
        /**
         * Identity of the participant.
         */
      }, {
        key: "identity",
        get: function get() {
          return this.state.identity;
        }
        /**
         * Indicates whether the participant is currently typing.
         */
      }, {
        key: "isTyping",
        get: function get() {
          return this.state.isTyping;
        }
        /**
         * The index of the last read message by the participant.
         * Note that retrieving messages on a client endpoint does not mean that messages are read,
         * please consider reading about the [Read Horizon feature](https://www.twilio.com/docs/api/chat/guides/consumption-horizon)
         * to find out about the proper way to mark messages as read.
         */
      }, {
        key: "lastReadMessageIndex",
        get: function get() {
          return this.state.lastReadMessageIndex;
        }
        /**
         * Date of the most recent read horizon update.
         */
      }, {
        key: "lastReadTimestamp",
        get: function get() {
          return this.state.lastReadTimestamp;
        }
      }, {
        key: "roleSid",
        get: function get() {
          return this.state.roleSid;
        }
        /**
         * Type of the participant.
         */
      }, {
        key: "type",
        get: function get() {
          return this.state.type;
        }
        /**
         * Get the bindings mapping for the current participant.
         * Available binding depends on the participant type.
         * You could access it as `participant.bindings.sms?.address` or
         * using the type dynamically `participant.bindings[participant.type]`
         * just be aware that the binding information has different structure for
         * each participant type.
         * See also {ParticipantEmailBinding}, the only available currently binding descriptor.
         */
      }, {
        key: "bindings",
        get: function get() {
          var _this$state$bindings;
          return (_this$state$bindings = this.state.bindings) !== null && _this$state$bindings !== void 0 ? _this$state$bindings : {};
        }
      }, {
        key: "_startTyping",
        value: (
          /**
           * Internal method used to start or reset the typing indicator timeout (with event emitting).
           * @internal
           */
          function _startTyping(timeout) {
            var _this2 = this;
            if (this.state.typingTimeout) {
              clearTimeout(this.state.typingTimeout);
            }
            this.state.isTyping = true;
            this.emit(Participant2.typingStarted, this);
            this.conversation.emit(Conversation.typingStarted, this);
            this.state.typingTimeout = Number(setTimeout(function() {
              return _this2._endTyping();
            }, timeout));
            return this;
          }
        )
        /**
         * Internal method function used to stop the typing indicator timeout (with event emitting).
         * @internal
         */
      }, {
        key: "_endTyping",
        value: function _endTyping() {
          if (!this.state.typingTimeout) {
            return;
          }
          this.state.isTyping = false;
          this.emit(Participant2.typingEnded, this);
          this.conversation.emit(Conversation.typingEnded, this);
          clearInterval(this.state.typingTimeout);
          this.state.typingTimeout = null;
        }
        /**
         * Internal method function used update local object's property roleSid with a new value.
         * @internal
         */
      }, {
        key: "_update",
        value: function _update(data) {
          var updateReasons = [];
          var updateAttributes = parseAttributes(data.attributes, "Retrieved malformed attributes from the server for participant: " + this.state.sid, log$5);
          if (data.attributes && !isEqual__default["default"](this.state.attributes, updateAttributes)) {
            this.state.attributes = updateAttributes;
            updateReasons.push("attributes");
          }
          var updatedDateUpdated = parseTime(data.dateUpdated);
          if (data.dateUpdated && (updatedDateUpdated === null || updatedDateUpdated === void 0 ? void 0 : updatedDateUpdated.getTime()) !== (this.state.dateUpdated && this.state.dateUpdated.getTime())) {
            this.state.dateUpdated = updatedDateUpdated;
            updateReasons.push("dateUpdated");
          }
          var updatedDateCreated = parseTime(data.dateCreated);
          if (data.dateCreated && (updatedDateCreated === null || updatedDateCreated === void 0 ? void 0 : updatedDateCreated.getTime()) !== (this.state.dateCreated && this.state.dateCreated.getTime())) {
            this.state.dateCreated = updatedDateCreated;
            updateReasons.push("dateCreated");
          }
          if (data.roleSid && this.state.roleSid !== data.roleSid) {
            this.state.roleSid = data.roleSid;
            updateReasons.push("roleSid");
          }
          if ((Number.isInteger(data.lastConsumedMessageIndex) || data.lastConsumedMessageIndex === null) && this.state.lastReadMessageIndex !== data.lastConsumedMessageIndex) {
            this.state.lastReadMessageIndex = data.lastConsumedMessageIndex;
            updateReasons.push("lastReadMessageIndex");
          }
          if (data.lastConsumptionTimestamp) {
            var lastReadTimestamp = new Date(data.lastConsumptionTimestamp);
            if (!this.state.lastReadTimestamp || this.state.lastReadTimestamp.getTime() !== lastReadTimestamp.getTime()) {
              this.state.lastReadTimestamp = lastReadTimestamp;
              updateReasons.push("lastReadTimestamp");
            }
          }
          if (data.bindings && !isEqual__default["default"](this.state.bindings, data.bindings)) {
            this.state.bindings = data.bindings;
            updateReasons.push("bindings");
          }
          if (updateReasons.length > 0) {
            this.emit(Participant2.updated, {
              participant: this,
              updateReasons
            });
          }
          return this;
        }
        /**
         * Get the user for this participant and subscribes to it. Supported only for participants of type `chat`.
         */
      }, {
        key: "getUser",
        value: function() {
          var _getUser = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee() {
            return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (!(this.type != "chat")) {
                      _context.next = 2;
                      break;
                    }
                    throw new Error("Getting User is not supported for this Participant type: " + this.type);
                  case 2:
                    return _context.abrupt("return", this.services.users.getUser(this.state.identity, this.state.userInfo));
                  case 3:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function getUser() {
            return _getUser.apply(this, arguments);
          }
          return getUser;
        }()
        /**
         * Remove the participant from the conversation.
         */
      }, {
        key: "remove",
        value: function() {
          var _remove = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee2() {
            return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    return _context2.abrupt("return", this.conversation.removeParticipant(this));
                  case 1:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function remove() {
            return _remove.apply(this, arguments);
          }
          return remove;
        }()
        /**
         * Update the attributes of the participant.
         * @param attributes New attributes.
         */
      }, {
        key: "updateAttributes",
        value: function() {
          var _updateAttributes = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee3(attributes) {
            return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    _context3.next = 2;
                    return this.services.commandExecutor.mutateResource("post", this.links.self, {
                      attributes: JSON.stringify(attributes)
                    });
                  case 2:
                    return _context3.abrupt("return", this);
                  case 3:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));
          function updateAttributes(_x) {
            return _updateAttributes.apply(this, arguments);
          }
          return updateAttributes;
        }()
      }]);
      return Participant2;
    }(replayEventEmitter.ReplayEventEmitter);
    _defineProperty__default["default"](Participant, "typingStarted", "typingStarted");
    _defineProperty__default["default"](Participant, "typingEnded", "typingEnded");
    _defineProperty__default["default"](Participant, "updated", "updated");
    __decorate([declarativeTypeValidator.validateTypesAsync(json), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", Promise)], Participant.prototype, "updateAttributes", null);
    function _createSuper$7(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$7();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$7() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var log$4 = Logger.scope("Participants");
    var Participants = function(_ReplayEventEmitter) {
      _inherits__default["default"](Participants2, _ReplayEventEmitter);
      var _super = _createSuper$7(Participants2);
      function Participants2(conversation, participants, links, services) {
        var _this;
        _classCallCheck__default["default"](this, Participants2);
        _this = _super.call(this);
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "rosterEntityPromise", null);
        _this.conversation = conversation;
        _this.participants = participants;
        _this.links = links;
        _this.services = services;
        return _this;
      }
      _createClass__default["default"](Participants2, [{
        key: "unsubscribe",
        value: function() {
          var _unsubscribe = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee() {
            var entity;
            return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (!this.rosterEntityPromise) {
                      _context.next = 6;
                      break;
                    }
                    _context.next = 3;
                    return this.rosterEntityPromise;
                  case 3:
                    entity = _context.sent;
                    entity.close();
                    this.rosterEntityPromise = null;
                  case 6:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function unsubscribe() {
            return _unsubscribe.apply(this, arguments);
          }
          return unsubscribe;
        }()
      }, {
        key: "subscribe",
        value: function subscribe(arg) {
          var _this2 = this;
          var participantsMapPromise = typeof arg === "string" ? this.services.syncClient.map({
            id: arg,
            mode: "open_existing"
          }) : Promise.resolve(arg);
          return this.rosterEntityPromise = this.rosterEntityPromise || participantsMapPromise.then(function(rosterMap) {
            rosterMap.on(twilioSync.SyncMap.itemAdded, function(args) {
              log$4.debug(_this2.conversation.sid + " itemAdded: " + args.item.key);
              _this2.upsertParticipant(args.item.key, args.item.data).then(function(participant) {
                _this2.emit(Conversation.participantJoined, participant);
              });
            });
            rosterMap.on(twilioSync.SyncMap.itemRemoved, function(args) {
              log$4.debug(_this2.conversation.sid + " itemRemoved: " + args.key);
              var participantSid = args.key;
              if (!_this2.participants.has(participantSid)) {
                return;
              }
              var leftParticipant = _this2.participants.get(participantSid);
              _this2.participants.delete(participantSid);
              if (!leftParticipant) {
                return;
              }
              _this2.emit(Conversation.participantLeft, leftParticipant);
            });
            rosterMap.on(twilioSync.SyncMap.itemUpdated, function(args) {
              log$4.debug(_this2.conversation.sid + " itemUpdated: " + args.item.key);
              _this2.upsertParticipant(args.item.key, args.item.data).catch(function(e) {
                return log$4.error(e);
              });
            });
            var participantsPromises = [];
            var rosterMapHandler = function rosterMapHandler2(paginator) {
              paginator.items.forEach(function(item) {
                participantsPromises.push(_this2.upsertParticipant(item.key, item.data));
              });
              return paginator.hasNextPage ? paginator.nextPage().then(rosterMapHandler2) : null;
            };
            return rosterMap.getItems().then(rosterMapHandler).then(function() {
              return Promise.all(participantsPromises);
            }).then(function() {
              return rosterMap;
            });
          }).catch(function(err) {
            _this2.rosterEntityPromise = null;
            if (_this2.services.syncClient.connectionState != "disconnected") {
              log$4.error("Failed to get roster object for conversation", _this2.conversation.sid, err);
            }
            log$4.debug("ERROR: Failed to get roster object for conversation", _this2.conversation.sid, err);
            throw err;
          });
        }
      }, {
        key: "upsertParticipantFromResponse",
        value: function() {
          var _upsertParticipantFromResponse = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee2(data) {
            var _messagingBinding$typ;
            var sid, responseAttributes, dateCreated, dateUpdated, responseIdentity, roleSid, messagingBinding;
            return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    sid = data.sid, responseAttributes = data.attributes, dateCreated = data.date_created, dateUpdated = data.date_updated, responseIdentity = data.identity, roleSid = data.role_sid, messagingBinding = data.messaging_binding;
                    _context2.next = 3;
                    return this.upsertParticipant(sid, {
                      attributes: responseAttributes,
                      dateCreated: new Date(dateCreated),
                      dateUpdated: new Date(dateUpdated),
                      identity: responseIdentity,
                      roleSid,
                      lastConsumedMessageIndex: null,
                      lastConsumptionTimestamp: null,
                      type: (_messagingBinding$typ = messagingBinding === null || messagingBinding === void 0 ? void 0 : messagingBinding.type) !== null && _messagingBinding$typ !== void 0 ? _messagingBinding$typ : "chat"
                    });
                  case 3:
                    return _context2.abrupt("return", _context2.sent);
                  case 4:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function upsertParticipantFromResponse(_x) {
            return _upsertParticipantFromResponse.apply(this, arguments);
          }
          return upsertParticipantFromResponse;
        }()
      }, {
        key: "upsertParticipant",
        value: function() {
          var _upsertParticipant = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee3(participantSid, data) {
            var _this3 = this;
            var participant, links;
            return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    participant = this.participants.get(participantSid);
                    if (!participant) {
                      _context3.next = 3;
                      break;
                    }
                    return _context3.abrupt("return", participant._update(data));
                  case 3:
                    links = {
                      self: "".concat(this.links.participants, "/").concat(participantSid)
                    };
                    participant = new Participant(data, participantSid, this.conversation, links, this.services);
                    this.participants.set(participantSid, participant);
                    participant.on(Participant.updated, function(args) {
                      return _this3.emit(Conversation.participantUpdated, args);
                    });
                    return _context3.abrupt("return", participant);
                  case 8:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));
          function upsertParticipant(_x2, _x3) {
            return _upsertParticipant.apply(this, arguments);
          }
          return upsertParticipant;
        }()
        /**
         * @returns {Promise<Array<Participant>>} returns list of participants {@see Participant}
         */
      }, {
        key: "getParticipants",
        value: function() {
          var _getParticipants = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee4() {
            var _this4 = this;
            return _regeneratorRuntime__default["default"].wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    return _context4.abrupt("return", this.rosterEntityPromise ? this.rosterEntityPromise.then(function() {
                      var participants = [];
                      _this4.participants.forEach(function(participant) {
                        return participants.push(participant);
                      });
                      return participants;
                    }) : []);
                  case 1:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));
          function getParticipants() {
            return _getParticipants.apply(this, arguments);
          }
          return getParticipants;
        }()
        /**
         * Get participant by SID from conversation
         * @returns {Promise<Participant>}
         */
      }, {
        key: "getParticipantBySid",
        value: function() {
          var _getParticipantBySid = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee5(participantSid) {
            var _this5 = this;
            return _regeneratorRuntime__default["default"].wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    return _context5.abrupt("return", this.rosterEntityPromise ? this.rosterEntityPromise.then(function() {
                      var participant = _this5.participants.get(participantSid);
                      if (!participant) {
                        throw new Error("Participant with SID " + participantSid + " was not found");
                      }
                      return participant;
                    }) : null);
                  case 1:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));
          function getParticipantBySid(_x4) {
            return _getParticipantBySid.apply(this, arguments);
          }
          return getParticipantBySid;
        }()
        /**
         * Get participant by identity from conversation
         * @returns {Promise<Participant>}
         */
      }, {
        key: "getParticipantByIdentity",
        value: function() {
          var _getParticipantByIdentity = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee6(identity) {
            var _this6 = this;
            var foundParticipant;
            return _regeneratorRuntime__default["default"].wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    foundParticipant = null;
                    return _context6.abrupt("return", this.rosterEntityPromise ? this.rosterEntityPromise.then(function() {
                      _this6.participants.forEach(function(participant) {
                        if (participant.identity === identity) {
                          foundParticipant = participant;
                        }
                      });
                      if (!foundParticipant) {
                        throw new Error("Participant with identity " + identity + " was not found");
                      }
                      return foundParticipant;
                    }) : null);
                  case 2:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, this);
          }));
          function getParticipantByIdentity(_x5) {
            return _getParticipantByIdentity.apply(this, arguments);
          }
          return getParticipantByIdentity;
        }()
        /**
         * Add a chat participant to the conversation
         */
      }, {
        key: "add",
        value: function() {
          var _add = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee7(identity, attributes) {
            return _regeneratorRuntime__default["default"].wrap(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    _context7.next = 2;
                    return this.services.commandExecutor.mutateResource("post", this.links.participants, {
                      identity,
                      attributes: typeof attributes !== "undefined" ? JSON.stringify(attributes) : void 0
                    });
                  case 2:
                    return _context7.abrupt("return", _context7.sent);
                  case 3:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee7, this);
          }));
          function add(_x6, _x7) {
            return _add.apply(this, arguments);
          }
          return add;
        }()
        /**
         * Add a non-chat participant to the conversation.
         */
      }, {
        key: "addNonChatParticipant",
        value: function() {
          var _addNonChatParticipant = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee8(proxyAddress, address) {
            var _bindingOptions$email, _bindingOptions$email2;
            var attributes, bindingOptions, _args8 = arguments;
            return _regeneratorRuntime__default["default"].wrap(function _callee8$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    attributes = _args8.length > 2 && _args8[2] !== void 0 ? _args8[2] : {};
                    bindingOptions = _args8.length > 3 && _args8[3] !== void 0 ? _args8[3] : {};
                    _context8.next = 4;
                    return this.services.commandExecutor.mutateResource("post", this.links.participants, {
                      attributes: typeof attributes !== "undefined" ? JSON.stringify(attributes) : void 0,
                      messaging_binding: {
                        address,
                        proxy_address: proxyAddress,
                        name: bindingOptions === null || bindingOptions === void 0 ? void 0 : (_bindingOptions$email = bindingOptions.email) === null || _bindingOptions$email === void 0 ? void 0 : _bindingOptions$email.name,
                        level: bindingOptions === null || bindingOptions === void 0 ? void 0 : (_bindingOptions$email2 = bindingOptions.email) === null || _bindingOptions$email2 === void 0 ? void 0 : _bindingOptions$email2.level
                      }
                    });
                  case 4:
                    return _context8.abrupt("return", _context8.sent);
                  case 5:
                  case "end":
                    return _context8.stop();
                }
              }
            }, _callee8, this);
          }));
          function addNonChatParticipant(_x8, _x9) {
            return _addNonChatParticipant.apply(this, arguments);
          }
          return addNonChatParticipant;
        }()
        /**
         * Remove the participant with a given identity from a conversation.
         */
      }, {
        key: "remove",
        value: function remove(identity) {
          return this.services.commandExecutor.mutateResource("delete", "".concat(this.links.participants, "/").concat(encodeURIComponent(identity)));
        }
      }]);
      return Participants2;
    }(replayEventEmitter.ReplayEventEmitter);
    var Media = function() {
      function Media2(data, services) {
        var _data$filename;
        _classCallCheck__default["default"](this, Media2);
        _defineProperty__default["default"](this, "mcsMedia", null);
        this.services = services;
        if (data instanceof mcsClient.McsMedia) {
          this.mcsMedia = data;
        }
        this.state = {
          sid: data.sid,
          category: data.category,
          filename: (_data$filename = data.filename) !== null && _data$filename !== void 0 ? _data$filename : null,
          contentType: data.contentType,
          size: data.size
        };
      }
      _createClass__default["default"](Media2, [{
        key: "sid",
        get: function get() {
          return this.state.sid;
        }
        /**
         * File name. Null if absent.
         */
      }, {
        key: "filename",
        get: function get() {
          return this.state.filename;
        }
        /**
         * Content type of the media.
         */
      }, {
        key: "contentType",
        get: function get() {
          return this.state.contentType;
        }
        /**
         * Size of the media in bytes.
         */
      }, {
        key: "size",
        get: function get() {
          return this.state.size;
        }
        /**
         * Media category, can be one of the {@link MediaCategory} values.
         */
      }, {
        key: "category",
        get: function get() {
          return this.state.category;
        }
        /**
         * Returns the direct content URL for the media.
         *
         * This URL is impermanent, it will expire in several minutes and cannot be cached.
         * If the URL becomes expired, you need to request a new one.
         * Each call to this function produces a new temporary URL.
         */
      }, {
        key: "getContentTemporaryUrl",
        value: function getContentTemporaryUrl() {
          var _this = this;
          return new mcsClient.CancellablePromise(function() {
            var _ref = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee(resolve, reject, onCancel) {
              var _this$mcsMedia;
              var fetchMediaRequest, contentUrlRequest, mcsMedia;
              return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      fetchMediaRequest = _this.mcsMedia ? void 0 : _this._fetchMcsMedia();
                      contentUrlRequest = (_this$mcsMedia = _this.mcsMedia) === null || _this$mcsMedia === void 0 ? void 0 : _this$mcsMedia.getContentUrl();
                      onCancel(function() {
                        if (fetchMediaRequest) {
                          fetchMediaRequest.cancel();
                        }
                        if (contentUrlRequest) {
                          contentUrlRequest.cancel();
                        }
                      });
                      _context.prev = 3;
                      if (contentUrlRequest) {
                        _context.next = 9;
                        break;
                      }
                      _context.next = 7;
                      return fetchMediaRequest;
                    case 7:
                      mcsMedia = _context.sent;
                      contentUrlRequest = mcsMedia === null || mcsMedia === void 0 ? void 0 : mcsMedia.getContentUrl();
                    case 9:
                      _context.t0 = resolve;
                      if (!contentUrlRequest) {
                        _context.next = 16;
                        break;
                      }
                      _context.next = 13;
                      return contentUrlRequest;
                    case 13:
                      _context.t1 = _context.sent;
                      _context.next = 17;
                      break;
                    case 16:
                      _context.t1 = null;
                    case 17:
                      _context.t2 = _context.t1;
                      (0, _context.t0)(_context.t2);
                      _context.next = 24;
                      break;
                    case 21:
                      _context.prev = 21;
                      _context.t3 = _context["catch"](3);
                      reject(_context.t3);
                    case 24:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, null, [[3, 21]]);
            }));
            return function(_x, _x2, _x3) {
              return _ref.apply(this, arguments);
            };
          }());
        }
      }, {
        key: "_fetchMcsMedia",
        value: function _fetchMcsMedia() {
          var _this2 = this;
          return new mcsClient.CancellablePromise(function() {
            var _ref2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee2(resolve, reject, onCancel) {
              var request;
              return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      if (_this2.services.mcsClient === null) {
                        reject(new Error("Media Content Service is unavailable"));
                      }
                      request = _this2.services.mcsClient.get(_this2.state.sid);
                      onCancel(function() {
                        return request.cancel();
                      });
                      _context2.prev = 3;
                      _context2.next = 6;
                      return request;
                    case 6:
                      _this2.mcsMedia = _context2.sent;
                      _this2.state = _this2.mcsMedia._state();
                      resolve(_this2.mcsMedia);
                      _context2.next = 14;
                      break;
                    case 11:
                      _context2.prev = 11;
                      _context2.t0 = _context2["catch"](3);
                      reject(_context2.t0);
                    case 14:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2, null, [[3, 11]]);
            }));
            return function(_x4, _x5, _x6) {
              return _ref2.apply(this, arguments);
            };
          }());
        }
        /**
         * @internal
         */
      }, {
        key: "_state",
        value: function _state() {
          return this.state;
        }
      }]);
      return Media2;
    }();
    var AggregatedDeliveryReceipt = function() {
      function AggregatedDeliveryReceipt2(data) {
        _classCallCheck__default["default"](this, AggregatedDeliveryReceipt2);
        this.state = data;
      }
      _createClass__default["default"](AggregatedDeliveryReceipt2, [{
        key: "total",
        get: function get() {
          return this.state.total;
        }
        /**
         * Message is considered as **sent** to a participant if the nearest upstream carrier accepted the message.
         *
         * @return Amount of participants that have the **sent** delivery status for the message.
         */
      }, {
        key: "sent",
        get: function get() {
          return this.state.sent;
        }
        /**
         * Message is considered as **delivered** to a participant if Twilio has received confirmation of message
         * delivery from the upstream carrier, and, where available, the destination handset.
         *
         * @return Amount of participants that have the **delivered** delivery status for the message.
         */
      }, {
        key: "delivered",
        get: function get() {
          return this.state.delivered;
        }
        /**
         * Message is considered as **read** by a participant, if the message has been delivered and opened by the
         * recipient in a conversation. The recipient must have enabled the read receipts.
         *
         * @return Amount of participants that have the **read** delivery status for the message.
         */
      }, {
        key: "read",
        get: function get() {
          return this.state.read;
        }
        /**
         * Message is considered as **undelivered** to a participant if Twilio has received a delivery receipt
         * indicating that the message was not delivered. This can happen for many reasons including carrier content
         * filtering and the availability of the destination handset.
         *
         * @return Ammount of participants that have the **undelivered** delivery status for the message.
         */
      }, {
        key: "undelivered",
        get: function get() {
          return this.state.undelivered;
        }
        /**
         * Message is considered as **failed** to be delivered to a participant if the message could not be sent.
         * This can happen for various reasons including queue overflows, account suspensions and media
         * errors (in the case of MMS for instance). Twilio does not charge you for failed messages.
         *
         * @return Amount of participants that have the **failed** delivery status for the message.
         */
      }, {
        key: "failed",
        get: function get() {
          return this.state.failed;
        }
      }, {
        key: "_update",
        value: function _update(data) {
          this.state = data;
        }
      }, {
        key: "_isEquals",
        value: function _isEquals(data) {
          var isTotalSame = this.total === data.total;
          var isSentSame = this.sent === data.sent;
          var isDeliveredSame = this.delivered === data.delivered;
          var isReadSame = this.read === data.read;
          var isUndeliveredSame = this.undelivered === data.undelivered;
          var isFailedSame = this.failed === data.failed;
          return isTotalSame && isSentSame && isDeliveredSame && isReadSame && isUndeliveredSame && isFailedSame;
        }
      }]);
      return AggregatedDeliveryReceipt2;
    }();
    var RestPaginator = function() {
      function RestPaginator2(items, source, prevToken, nextToken) {
        _classCallCheck__default["default"](this, RestPaginator2);
        this.state = {
          prevToken,
          nextToken,
          source,
          items
        };
      }
      _createClass__default["default"](RestPaginator2, [{
        key: "hasNextPage",
        get: (
          /**
           * Indicates the existence of the next page.
           */
          function get() {
            return !!this.state.nextToken;
          }
        )
        /**
         * Indicates the existence of the previous page
         */
      }, {
        key: "hasPrevPage",
        get: function get() {
          return !!this.state.prevToken;
        }
        /**
         * Array of elements on the current page.
         */
      }, {
        key: "items",
        get: function get() {
          return this.state.items;
        }
      }, {
        key: "nextPage",
        value: function nextPage() {
          return this.hasNextPage ? this.state.source(this.state.nextToken) : Promise.reject(new Error("No next page"));
        }
        /**
         * Request the previous page. Does not modify the existing object.
         */
      }, {
        key: "prevPage",
        value: function prevPage() {
          return this.hasPrevPage ? this.state.source(this.state.prevToken) : Promise.reject(new Error("No previous page"));
        }
      }]);
      return RestPaginator2;
    }();
    var DetailedDeliveryReceipt = _createClass__default["default"](
      /**
       * Unique identifier for the delivery receipt.
       */
      /**
       * Unique identifier for the message in the conversation.
       */
      /**
       * Unique identifier for the conversation.
       */
      /**
       * Unique identifier for the `âchannelâ` message (e.g., `WAxx` for WhatsApp, `SMxx` for SMS).
       */
      /**
       * Unique identifier for the participant.
       */
      /**
       * Status of the message delivery.
       */
      /**
       * Numeric error code mapped from Status callback code. Information about the error codes can be found
       * [here](https://www.twilio.com/docs/sms/api/message-resource#delivery-related-errors).
       */
      /**
       * Date this delivery receipt was created on.
       */
      /**
       * Date this delivery receipt was last updated on.
       */
      /**
       * @internal
       */
      function DetailedDeliveryReceipt2(descriptor) {
        _classCallCheck__default["default"](this, DetailedDeliveryReceipt2);
        this.sid = descriptor.sid;
        this.messageSid = descriptor.message_sid;
        this.conversationSid = descriptor.conversation_sid;
        this.channelMessageSid = descriptor.channel_message_sid;
        this.participantSid = descriptor.participant_sid;
        this.status = descriptor.status || "queued";
        this.errorCode = descriptor.error_code || 0;
        this.dateCreated = descriptor.date_created;
        this.dateUpdated = descriptor.date_updated;
      }
    );
    var collectActions = function collectActions2(actions) {
      return actions.map(function(action) {
        var _action$id, _action$index, _action$phone, _action$url;
        var rawData = JSON.stringify(action);
        switch (action.type) {
          case "QUICK_REPLY":
            return {
              type: "reply",
              title: action.title,
              id: (_action$id = action.id) !== null && _action$id !== void 0 ? _action$id : "",
              index: (_action$index = action.index) !== null && _action$index !== void 0 ? _action$index : 0,
              rawData
            };
          case "PHONE_NUMBER":
            return {
              type: "phone",
              title: action.title,
              phone: (_action$phone = action.phone) !== null && _action$phone !== void 0 ? _action$phone : "",
              rawData
            };
          case "URL":
            return {
              type: "url",
              title: action.title,
              url: (_action$url = action.url) !== null && _action$url !== void 0 ? _action$url : "",
              rawData
            };
          default:
            return {
              type: "other",
              rawData
            };
        }
      });
    };
    var parseVariant = function parseVariant2(type, data) {
      var rawData = JSON.stringify(data);
      switch (type) {
        case "twilio/text": {
          var variant = data;
          return {
            type: "text",
            body: variant.body,
            rawData
          };
        }
        case "twilio/media": {
          var _variant = data;
          return {
            type: "media",
            body: _variant.body,
            media: _variant.media,
            rawData
          };
        }
        case "twilio/location": {
          var _variant2 = data;
          return {
            type: "location",
            longitude: _variant2.longitude,
            latitude: _variant2.latitude,
            label: _variant2.label,
            rawData
          };
        }
        case "twilio/quick-reply": {
          var _variant3 = data;
          return {
            type: "quickReply",
            body: _variant3.body,
            replies: _variant3.actions,
            rawData
          };
        }
        case "twilio/call-to-action": {
          var _variant4 = data;
          return {
            type: "callToAction",
            body: _variant4.body,
            actions: collectActions(_variant4.actions),
            rawData
          };
        }
        case "twilio/list-picker": {
          var _variant5 = data;
          return {
            type: "listPicker",
            body: _variant5.body,
            button: _variant5.button,
            items: _variant5.items,
            rawData
          };
        }
        case "twilio/card": {
          var _variant6$media, _variant6$actions;
          var _variant6 = data;
          return {
            type: "card",
            title: _variant6.title,
            subtitle: _variant6.subtitle,
            media: (_variant6$media = _variant6.media) !== null && _variant6$media !== void 0 ? _variant6$media : [],
            actions: collectActions((_variant6$actions = _variant6.actions) !== null && _variant6$actions !== void 0 ? _variant6$actions : []),
            rawData
          };
        }
        default:
          return {
            type: "other",
            rawData
          };
      }
    };
    var collectVariants = function collectVariants2(variants) {
      var variantsMap = /* @__PURE__ */ new Map();
      for (var _i = 0, _Object$entries = Object.entries(variants); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = _slicedToArray__default["default"](_Object$entries[_i], 2), key = _Object$entries$_i[0], value = _Object$entries$_i[1];
        variantsMap.set(key, parseVariant(key, value));
      }
      return variantsMap;
    };
    var ContentTemplateVariable = function() {
      function ContentTemplateVariable2(name, value) {
        _classCallCheck__default["default"](this, ContentTemplateVariable2);
        this.name = name;
        this.value = value;
      }
      _createClass__default["default"](ContentTemplateVariable2, [{
        key: "copyWithValue",
        value: function copyWithValue(value) {
          return new ContentTemplateVariable2(this.name, value);
        }
      }]);
      return ContentTemplateVariable2;
    }();
    var ContentTemplate = _createClass__default["default"](
      /**
       * The server-assigned unique identifier for the template.
       */
      /**
       * Friendly name used to describe the content. Not visible to the recipient.
       */
      /**
       * Variables used by this template.
       */
      /**
       * Variants of the content. See {@link ContentData}.
       */
      /**
       * Date of creation.
       */
      /**
       * Date of the last update.
       */
      /**
       * @internal
       */
      function ContentTemplate2(contentTemplateResponse) {
        _classCallCheck__default["default"](this, ContentTemplate2);
        this.sid = contentTemplateResponse.sid;
        this.friendlyName = contentTemplateResponse.friendly_name;
        this.variables = Object.entries(JSON.parse(contentTemplateResponse.variables)).map(function(_ref) {
          var _ref2 = _slicedToArray__default["default"](_ref, 2), key = _ref2[0], value = _ref2[1];
          return new ContentTemplateVariable(key, value);
        });
        this.variants = collectVariants(contentTemplateResponse.variants);
        this.dateCreated = new Date(contentTemplateResponse.date_created);
        this.dateUpdated = new Date(contentTemplateResponse.date_updated);
      }
    );
    function ownKeys$4(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread$4(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys$4(Object(source), true).forEach(function(key) {
          _defineProperty__default["default"](target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _createSuper$6(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$6();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$6() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _classPrivateMethodInitSpec(obj, privateSet) {
      _checkPrivateRedeclaration(obj, privateSet);
      privateSet.add(obj);
    }
    function _checkPrivateRedeclaration(obj, privateCollection) {
      if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
      }
    }
    function _classPrivateMethodGet(receiver, privateSet, fn) {
      if (!privateSet.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
      }
      return fn;
    }
    var log$3 = Logger.scope("Message");
    var XHR = (
      // eslint-disable-next-line @typescript-eslint/no-var-requires
      global2["XMLHttpRequest"] || {}
    );
    var _wrapMedia = /* @__PURE__ */ new WeakSet();
    var _assignMedias = /* @__PURE__ */ new WeakSet();
    var Message = function(_ReplayEventEmitter) {
      _inherits__default["default"](Message2, _ReplayEventEmitter);
      var _super = _createSuper$6(Message2);
      function Message2(index, data, conversation, links, configuration, services) {
        var _data$text, _data$lastUpdatedBy, _data$type, _data$memberSid, _data$channelMetadata, _data$medias, _data$media;
        var _this;
        _classCallCheck__default["default"](this, Message2);
        _this = _super.call(this);
        _classPrivateMethodInitSpec(_assertThisInitialized__default["default"](_this), _assignMedias);
        _classPrivateMethodInitSpec(_assertThisInitialized__default["default"](_this), _wrapMedia);
        _this.conversation = conversation;
        _this.links = links;
        _this.configuration = configuration;
        _this.services = services;
        _this.state = {
          sid: data.sid,
          index,
          author: data.author,
          subject: data.subject,
          contentSid: data.contentSid,
          body: (_data$text = data.text) !== null && _data$text !== void 0 ? _data$text : null,
          timestamp: data.timestamp ? new Date(data.timestamp) : null,
          dateUpdated: data.dateUpdated ? new Date(data.dateUpdated) : null,
          lastUpdatedBy: (_data$lastUpdatedBy = data.lastUpdatedBy) !== null && _data$lastUpdatedBy !== void 0 ? _data$lastUpdatedBy : null,
          attributes: parseAttributes(data.attributes, "Got malformed attributes for the message ".concat(data.sid), log$3),
          type: (_data$type = data.type) !== null && _data$type !== void 0 ? _data$type : "text",
          media: null,
          medias: null,
          participantSid: (_data$memberSid = data.memberSid) !== null && _data$memberSid !== void 0 ? _data$memberSid : null,
          aggregatedDeliveryReceipt: data.delivery ? new AggregatedDeliveryReceipt(data.delivery) : null,
          hasChannelMetadata: (_data$channelMetadata = data.channelMetadata) !== null && _data$channelMetadata !== void 0 ? _data$channelMetadata : false
        };
        _classPrivateMethodGet(_assertThisInitialized__default["default"](_this), _assignMedias, _assignMedias2).call(_assertThisInitialized__default["default"](_this), (_data$medias = data.medias) !== null && _data$medias !== void 0 ? _data$medias : null, (_data$media = data.media) !== null && _data$media !== void 0 ? _data$media : null);
        return _this;
      }
      _createClass__default["default"](Message2, [{
        key: "sid",
        get: (
          /**
           * The server-assigned unique identifier for the message.
           */
          function get() {
            return this.state.sid;
          }
        )
        /**
         * Name of the user that sent the message.
         */
      }, {
        key: "author",
        get: function get() {
          return this.state.author;
        }
        /**
         * Message subject. Used only in email conversations.
         */
      }, {
        key: "subject",
        get: function get() {
          return this.state.subject;
        }
        /**
         * Unique identifier of {@link ContentTemplate} for this message.
         */
      }, {
        key: "contentSid",
        get: function get() {
          return this.state.contentSid;
        }
        /**
         * Body of the message.
         */
      }, {
        key: "body",
        get: function get() {
          return this.state.body;
        }
        /**
         * Date this message was last updated on.
         */
      }, {
        key: "dateUpdated",
        get: function get() {
          return this.state.dateUpdated;
        }
        /**
         * Index of this message in the conversation's list of messages.
         *
         * By design, the message indices may have arbitrary gaps between them,
         * that does not necessarily mean they were deleted or otherwise modified - just that
         * messages may have some non-contiguous indices even if they are being sent immediately one after another.
         *
         * Trying to use indices for some calculations is going to be unreliable.
         *
         * To calculate the number of unread messages, it is better to use the Read Horizon API.
         * See {@link Conversation.getUnreadMessagesCount} for details.
         */
      }, {
        key: "index",
        get: function get() {
          return this.state.index;
        }
        /**
         * Identity of the last user that updated the message.
         */
      }, {
        key: "lastUpdatedBy",
        get: function get() {
          return this.state.lastUpdatedBy;
        }
        /**
         * Date this message was created on.
         */
      }, {
        key: "dateCreated",
        get: function get() {
          return this.state.timestamp;
        }
        /**
         * Custom attributes of the message.
         */
      }, {
        key: "attributes",
        get: function get() {
          return this.state.attributes;
        }
        /**
         * Type of the message.
         */
      }, {
        key: "type",
        get: function get() {
          return this.state.type;
        }
        /**
         * One of the attached media (if present).
         * @deprecated Use attachedMedia instead. Note that the latter is now an array.
         */
      }, {
        key: "media",
        get: function get() {
          return this.state.media;
        }
        /**
         * Return all media attachments, except email body/history attachments, without temporary urls.
         */
      }, {
        key: "attachedMedia",
        get: function get() {
          return this.getMediaByCategories(["media"]);
        }
        /**
         * The server-assigned unique identifier of the authoring participant.
         */
      }, {
        key: "participantSid",
        get: function get() {
          return this.state.participantSid;
        }
        /**
         * Aggregated information about the message delivery statuses across all participants of a conversation..
         */
      }, {
        key: "aggregatedDeliveryReceipt",
        get: function get() {
          return this.state.aggregatedDeliveryReceipt;
        }
        /**
         * @deprecated
         * Return a (possibly empty) array of media matching a specific set of categories.
         * Allowed category is so far only 'media'.
         * @param categories Array of categories to match.
         * @returns Array of media descriptors matching given categories.
         */
      }, {
        key: "getMediaByCategory",
        value: function getMediaByCategory(categories) {
          return this.getMediaByCategories(categories);
        }
        /**
         * Return a (possibly empty) array of media matching a specific set of categories.
         * Allowed category is so far only 'media'.
         * @param categories Array of categories to match.
         * @returns Array of media descriptors matching given categories.
         */
      }, {
        key: "getMediaByCategories",
        value: function getMediaByCategories(categories) {
          var _this$state$medias;
          return ((_this$state$medias = this.state.medias) !== null && _this$state$medias !== void 0 ? _this$state$medias : []).filter(function(m) {
            return categories.includes(m.category);
          });
        }
        /**
         * Get a media descriptor for an email body attachment of a provided type.
         * Allowed body types are returned in the Conversation.limits().emailBodiesAllowedContentTypes array.
         * @param type Type of email body to request, defaults to `text/plain`.
         */
      }, {
        key: "getEmailBody",
        value: function getEmailBody() {
          var _this$getMediaByCateg, _this$getMediaByCateg2;
          var type = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "text/plain";
          return (_this$getMediaByCateg = (_this$getMediaByCateg2 = this.getMediaByCategories(["body"])) === null || _this$getMediaByCateg2 === void 0 ? void 0 : _this$getMediaByCateg2.filter(function(m) {
            return m.contentType == type;
          }).shift()) !== null && _this$getMediaByCateg !== void 0 ? _this$getMediaByCateg : null;
        }
        /**
         * Get a media descriptor for an email history attachment of a provided type.
         * Allowed body types are returned in the Conversation.limits().emailHistoriesAllowedContentTypes array.
         * @param type Type of email history to request, defaults to `text/plain`.
         */
      }, {
        key: "getEmailHistory",
        value: function getEmailHistory() {
          var _this$getMediaByCateg3, _this$getMediaByCateg4;
          var type = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "text/plain";
          return (_this$getMediaByCateg3 = (_this$getMediaByCateg4 = this.getMediaByCategories(["history"])) === null || _this$getMediaByCateg4 === void 0 ? void 0 : _this$getMediaByCateg4.filter(function(m) {
            return m.contentType == type;
          }).shift()) !== null && _this$getMediaByCateg3 !== void 0 ? _this$getMediaByCateg3 : null;
        }
      }, {
        key: "_update",
        value: function _update(data) {
          var _data$medias2, _this2 = this, _this$state$medias2, _classPrivateMethodGe2, _this$state$media;
          var updateReasons = [];
          if ((data.text || typeof data.text === "string") && data.text !== this.state.body) {
            this.state.body = data.text;
            updateReasons.push("body");
          }
          if (data.subject && data.subject !== this.state.subject) {
            this.state.subject = data.subject;
            updateReasons.push("subject");
          }
          if (data.lastUpdatedBy && data.lastUpdatedBy !== this.state.lastUpdatedBy) {
            this.state.lastUpdatedBy = data.lastUpdatedBy;
            updateReasons.push("lastUpdatedBy");
          }
          if (data.author && data.author !== this.state.author) {
            this.state.author = data.author;
            updateReasons.push("author");
          }
          if (data.dateUpdated && new Date(data.dateUpdated).getTime() !== (this.state.dateUpdated && this.state.dateUpdated.getTime())) {
            this.state.dateUpdated = new Date(data.dateUpdated);
            updateReasons.push("dateUpdated");
          }
          if (data.timestamp && new Date(data.timestamp).getTime() !== (this.state.timestamp && this.state.timestamp.getTime())) {
            this.state.timestamp = new Date(data.timestamp);
            updateReasons.push("dateCreated");
          }
          var updatedAttributes = parseAttributes(data.attributes, "Got malformed attributes for the message ".concat(this.sid), log$3);
          if (!isEqual__default["default"](this.state.attributes, updatedAttributes)) {
            this.state.attributes = updatedAttributes;
            updateReasons.push("attributes");
          }
          var updatedAggregatedDelivery = data.delivery;
          var currentAggregatedDelivery = this.state.aggregatedDeliveryReceipt;
          var isUpdatedAggregateDeliveryValid = !!updatedAggregatedDelivery && !!updatedAggregatedDelivery.total && !!updatedAggregatedDelivery.delivered && !!updatedAggregatedDelivery.failed && !!updatedAggregatedDelivery.read && !!updatedAggregatedDelivery.sent && !!updatedAggregatedDelivery.undelivered;
          if (isUpdatedAggregateDeliveryValid) {
            if (!currentAggregatedDelivery) {
              this.state.aggregatedDeliveryReceipt = new AggregatedDeliveryReceipt(updatedAggregatedDelivery);
              updateReasons.push("deliveryReceipt");
            } else if (!currentAggregatedDelivery._isEquals(updatedAggregatedDelivery)) {
              currentAggregatedDelivery._update(updatedAggregatedDelivery);
              updateReasons.push("deliveryReceipt");
            }
          }
          var input = ((_data$medias2 = data.medias) !== null && _data$medias2 !== void 0 ? _data$medias2 : []).map(function(value) {
            var _classPrivateMethodGe;
            return (_classPrivateMethodGe = _classPrivateMethodGet(_this2, _wrapMedia, _wrapMedia2).call(_this2, value)) === null || _classPrivateMethodGe === void 0 ? void 0 : _classPrivateMethodGe._state();
          }).filter(function(el) {
            return !(el === null);
          });
          var current = ((_this$state$medias2 = this.state.medias) !== null && _this$state$medias2 !== void 0 ? _this$state$medias2 : []).map(function(value) {
            return value._state();
          }).filter(function(el) {
            return !(el === null);
          });
          if (!isEqual__default["default"](input, current) || !isEqual__default["default"]((_classPrivateMethodGe2 = _classPrivateMethodGet(this, _wrapMedia, _wrapMedia2).call(this, data.media)) === null || _classPrivateMethodGe2 === void 0 ? void 0 : _classPrivateMethodGe2._state(), (_this$state$media = this.state.media) === null || _this$state$media === void 0 ? void 0 : _this$state$media._state())) {
            var _data$medias3, _data$media2;
            _classPrivateMethodGet(this, _assignMedias, _assignMedias2).call(this, (_data$medias3 = data.medias) !== null && _data$medias3 !== void 0 ? _data$medias3 : null, (_data$media2 = data.media) !== null && _data$media2 !== void 0 ? _data$media2 : null);
            updateReasons.push("media");
          }
          if (updateReasons.length > 0) {
            this.emit("updated", {
              message: this,
              updateReasons
            });
          }
        }
        /**
         * Get the participant who is the author of the message.
         */
      }, {
        key: "getParticipant",
        value: function() {
          var _getParticipant = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee() {
            var _this3 = this;
            var participant, errorMessage;
            return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    participant = null;
                    if (!this.state.participantSid) {
                      _context.next = 5;
                      break;
                    }
                    _context.next = 4;
                    return this.conversation.getParticipantBySid(this.state.participantSid).catch(function() {
                      log$3.debug('Participant with sid "'.concat(_this3.participantSid, '" not found for message ').concat(_this3.sid));
                      return null;
                    });
                  case 4:
                    participant = _context.sent;
                  case 5:
                    if (!(!participant && this.state.author)) {
                      _context.next = 9;
                      break;
                    }
                    _context.next = 8;
                    return this.conversation.getParticipantByIdentity(this.state.author).catch(function() {
                      log$3.debug('Participant with identity "'.concat(_this3.author, '" not found for message ').concat(_this3.sid));
                      return null;
                    });
                  case 8:
                    participant = _context.sent;
                  case 9:
                    if (!participant) {
                      _context.next = 11;
                      break;
                    }
                    return _context.abrupt("return", participant);
                  case 11:
                    errorMessage = "Participant with ";
                    if (this.state.participantSid) {
                      errorMessage += "SID '" + this.state.participantSid + "' ";
                    }
                    if (this.state.author) {
                      if (this.state.participantSid) {
                        errorMessage += "or ";
                      }
                      errorMessage += "identity '" + this.state.author + "' ";
                    }
                    if (errorMessage === "Participant with ") {
                      errorMessage = "Participant ";
                    }
                    errorMessage += "was not found";
                    throw new Error(errorMessage);
                  case 17:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function getParticipant() {
            return _getParticipant.apply(this, arguments);
          }
          return getParticipant;
        }()
        /**
         * Get the delivery receipts of the message.
         */
      }, {
        key: "getDetailedDeliveryReceipts",
        value: function() {
          var _getDetailedDeliveryReceipts = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee2() {
            var paginator, detailedDeliveryReceipts;
            return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.next = 2;
                    return this._getDetailedDeliveryReceiptsPaginator();
                  case 2:
                    paginator = _context2.sent;
                    detailedDeliveryReceipts = paginator.items;
                  case 4:
                    if (!paginator.hasNextPage) {
                      _context2.next = 11;
                      break;
                    }
                    _context2.next = 7;
                    return paginator.nextPage();
                  case 7:
                    paginator = _context2.sent;
                    detailedDeliveryReceipts = [].concat(_toConsumableArray__default["default"](detailedDeliveryReceipts), _toConsumableArray__default["default"](paginator.items));
                    _context2.next = 4;
                    break;
                  case 11:
                    return _context2.abrupt("return", detailedDeliveryReceipts);
                  case 12:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function getDetailedDeliveryReceipts() {
            return _getDetailedDeliveryReceipts.apply(this, arguments);
          }
          return getDetailedDeliveryReceipts;
        }()
        /**
         * Remove the message.
         */
      }, {
        key: "remove",
        value: function() {
          var _remove = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee3() {
            return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    _context3.next = 2;
                    return this.services.commandExecutor.mutateResource("delete", this.links.self);
                  case 2:
                    return _context3.abrupt("return", this);
                  case 3:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));
          function remove() {
            return _remove.apply(this, arguments);
          }
          return remove;
        }()
        /**
         * Edit the message body.
         * @param body New body of the message.
         */
      }, {
        key: "updateBody",
        value: function() {
          var _updateBody = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee4(body) {
            return _regeneratorRuntime__default["default"].wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    _context4.next = 2;
                    return this.services.commandExecutor.mutateResource("post", this.links.self, {
                      body
                    });
                  case 2:
                    return _context4.abrupt("return", this);
                  case 3:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));
          function updateBody(_x) {
            return _updateBody.apply(this, arguments);
          }
          return updateBody;
        }()
        /**
         * Edit the message attributes.
         * @param attributes New attributes.
         */
      }, {
        key: "updateAttributes",
        value: function() {
          var _updateAttributes = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee5(attributes) {
            return _regeneratorRuntime__default["default"].wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    _context5.next = 2;
                    return this.services.commandExecutor.mutateResource("post", this.links.self, {
                      attributes: typeof attributes !== "undefined" ? JSON.stringify(attributes) : void 0
                    });
                  case 2:
                    return _context5.abrupt("return", this);
                  case 3:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));
          function updateAttributes(_x2) {
            return _updateAttributes.apply(this, arguments);
          }
          return updateAttributes;
        }()
        /**
         * @deprecated
         * Get content URLs for all media attachments in the given set using a single operation.
         * @param contentSet Set of media attachments to query content URLs.
         */
      }, {
        key: "attachTemporaryUrlsFor",
        value: function() {
          var _attachTemporaryUrlsFor = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee6(contentSet) {
            var _this4 = this;
            var sids;
            return _regeneratorRuntime__default["default"].wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    sids = contentSet === null || contentSet === void 0 ? void 0 : contentSet.map(function(m) {
                      return m.sid;
                    });
                    if (!(this.services.mcsClient && sids)) {
                      _context6.next = 7;
                      break;
                    }
                    _context6.next = 4;
                    return this.services.mcsClient.mediaSetGet(sids);
                  case 4:
                    return _context6.abrupt("return", _context6.sent.map(function(item) {
                      return new Media(item, _this4.services);
                    }));
                  case 7:
                    throw new Error("Media Content Service is unavailable");
                  case 8:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, this);
          }));
          function attachTemporaryUrlsFor(_x3) {
            return _attachTemporaryUrlsFor.apply(this, arguments);
          }
          return attachTemporaryUrlsFor;
        }()
        /**
         * Get content URLs for all media attachments in the given set using a single operation.
         * @param contentSet Set of media attachments to query content URLs.
         */
      }, {
        key: "getTemporaryContentUrlsForMedia",
        value: function getTemporaryContentUrlsForMedia(contentSet) {
          var sids = contentSet.map(function(m) {
            return m.sid;
          });
          return this.getTemporaryContentUrlsForMediaSids(sids);
        }
        /**
         * Get content URLs for all media attachments in the given set of media sids using a single operation.
         * @param mediaSids Set of media sids to query for the content URL.
         */
      }, {
        key: "getTemporaryContentUrlsForMediaSids",
        value: function getTemporaryContentUrlsForMediaSids(mediaSids) {
          var _this5 = this;
          return new mcsClient.CancellablePromise(function() {
            var _ref = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee7(resolve, reject, onCancel) {
              var mediaGetRequest, urls;
              return _regeneratorRuntime__default["default"].wrap(function _callee7$(_context7) {
                while (1) {
                  switch (_context7.prev = _context7.next) {
                    case 0:
                      mediaGetRequest = _this5.services.mcsClient.mediaSetGetContentUrls(mediaSids !== null && mediaSids !== void 0 ? mediaSids : []);
                      if (!(!_this5.services.mcsClient || !mediaSids)) {
                        _context7.next = 4;
                        break;
                      }
                      reject(new Error("Media Content Service is unavailable"));
                      return _context7.abrupt("return");
                    case 4:
                      onCancel(function() {
                        mediaGetRequest.cancel();
                      });
                      _context7.prev = 5;
                      _context7.next = 8;
                      return mediaGetRequest;
                    case 8:
                      urls = _context7.sent;
                      resolve(urls);
                      _context7.next = 15;
                      break;
                    case 12:
                      _context7.prev = 12;
                      _context7.t0 = _context7["catch"](5);
                      reject(_context7.t0);
                    case 15:
                    case "end":
                      return _context7.stop();
                  }
                }
              }, _callee7, null, [[5, 12]]);
            }));
            return function(_x4, _x5, _x6) {
              return _ref.apply(this, arguments);
            };
          }());
        }
        /**
         * Get content URLs for all media attached to the message.
         */
      }, {
        key: "getTemporaryContentUrlsForAttachedMedia",
        value: function getTemporaryContentUrlsForAttachedMedia() {
          var _media$map;
          var media = this.attachedMedia;
          var sids = (_media$map = media === null || media === void 0 ? void 0 : media.map(function(m) {
            return m.sid;
          })) !== null && _media$map !== void 0 ? _media$map : [];
          return this.getTemporaryContentUrlsForMediaSids(sids);
        }
      }, {
        key: "_getDetailedDeliveryReceiptsPaginator",
        value: function() {
          var _getDetailedDeliveryReceiptsPaginator2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee8(options) {
            var _this6 = this;
            var messagesReceiptsUrl, url, response;
            return _regeneratorRuntime__default["default"].wrap(function _callee8$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    messagesReceiptsUrl = this.configuration.links.messagesReceipts.replace("%s", this.conversation.sid).replace("%s", this.sid);
                    url = new UriBuilder(messagesReceiptsUrl).arg("PageToken", options === null || options === void 0 ? void 0 : options.pageToken).arg("PageSize", options === null || options === void 0 ? void 0 : options.pageSize).build();
                    _context8.next = 4;
                    return this.services.network.get(url);
                  case 4:
                    response = _context8.sent;
                    return _context8.abrupt("return", new RestPaginator(response.body.delivery_receipts.map(function(x) {
                      return new DetailedDeliveryReceipt(x);
                    }), function(pageToken, pageSize) {
                      return _this6._getDetailedDeliveryReceiptsPaginator({
                        pageToken,
                        pageSize
                      });
                    }, response.body.meta.previous_token, response.body.meta.next_token));
                  case 6:
                  case "end":
                    return _context8.stop();
                }
              }
            }, _callee8, this);
          }));
          function _getDetailedDeliveryReceiptsPaginator(_x7) {
            return _getDetailedDeliveryReceiptsPaginator2.apply(this, arguments);
          }
          return _getDetailedDeliveryReceiptsPaginator;
        }()
        /**
         * Get the {@link ContentData} for this message. Resolves to `null` when
         * {@link Message.contentSid} is null.
         */
      }, {
        key: "getContentData",
        value: function getContentData() {
          var _this7 = this;
          return new mcsClient.CancellablePromise(function() {
            var _ref2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee9(resolve, reject, onCancel) {
              var bodies, twilioPrefix, filteredMedias, contentMedia, urlPromise, url, jsonStringPromise, json2, jsonString, dataType;
              return _regeneratorRuntime__default["default"].wrap(function _callee9$(_context9) {
                while (1) {
                  switch (_context9.prev = _context9.next) {
                    case 0:
                      if (!(_this7.state.contentSid === null)) {
                        _context9.next = 3;
                        break;
                      }
                      resolve(null);
                      return _context9.abrupt("return");
                    case 3:
                      bodies = _this7.getMediaByCategories(["body"]);
                      if (!(bodies === null)) {
                        _context9.next = 7;
                        break;
                      }
                      resolve(null);
                      return _context9.abrupt("return");
                    case 7:
                      twilioPrefix = "application/x-vnd.com.twilio.rich.";
                      filteredMedias = bodies.filter(function(media) {
                        return media.contentType.startsWith(twilioPrefix);
                      });
                      if (!(filteredMedias.length === 0)) {
                        _context9.next = 12;
                        break;
                      }
                      resolve(null);
                      return _context9.abrupt("return");
                    case 12:
                      contentMedia = filteredMedias[0];
                      urlPromise = contentMedia.getContentTemporaryUrl();
                      onCancel(function() {
                        urlPromise.cancel();
                      });
                      _context9.prev = 15;
                      _context9.next = 18;
                      return urlPromise;
                    case 18:
                      url = _context9.sent;
                      _context9.next = 25;
                      break;
                    case 21:
                      _context9.prev = 21;
                      _context9.t0 = _context9["catch"](15);
                      reject(_context9.t0);
                      return _context9.abrupt("return");
                    case 25:
                      if (!(url === null)) {
                        _context9.next = 28;
                        break;
                      }
                      resolve(null);
                      return _context9.abrupt("return");
                    case 28:
                      jsonStringPromise = new Promise(function(resolve2, reject2) {
                        var _url;
                        var isCancelled = false;
                        var xhr = new XHR();
                        xhr.open("GET", (_url = url) !== null && _url !== void 0 ? _url : "", true);
                        xhr.responseType = "text";
                        xhr.onreadystatechange = function() {
                          if (xhr.readyState !== 4 || isCancelled) {
                            return;
                          }
                          resolve2(xhr.responseText);
                        };
                        xhr.onerror = function() {
                          reject2(xhr.statusText);
                        };
                        onCancel(function() {
                          isCancelled = true;
                          xhr.abort();
                          reject2(new Error("XHR has been aborted"));
                        });
                        xhr.send();
                      });
                      _context9.prev = 29;
                      _context9.next = 32;
                      return jsonStringPromise;
                    case 32:
                      jsonString = _context9.sent;
                      json2 = JSON.parse(jsonString);
                      _context9.next = 40;
                      break;
                    case 36:
                      _context9.prev = 36;
                      _context9.t1 = _context9["catch"](29);
                      reject(_context9.t1);
                      return _context9.abrupt("return");
                    case 40:
                      dataType = contentMedia.contentType.replace(twilioPrefix, "").replace(".", "/");
                      resolve(parseVariant(dataType, json2.data));
                    case 42:
                    case "end":
                      return _context9.stop();
                  }
                }
              }, _callee9, null, [[15, 21], [29, 36]]);
            }));
            return function(_x8, _x9, _x10) {
              return _ref2.apply(this, arguments);
            };
          }());
        }
        /**
         * Get the {@link ChannelMetadata} for this message. Resolves to `null` if
         * the message doesn't have any channel metadata.
         */
      }, {
        key: "getChannelMetadata",
        value: function() {
          var _getChannelMetadata = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee10() {
            return _regeneratorRuntime__default["default"].wrap(function _callee10$(_context10) {
              while (1) {
                switch (_context10.prev = _context10.next) {
                  case 0:
                    if (this.state.hasChannelMetadata) {
                      _context10.next = 2;
                      break;
                    }
                    return _context10.abrupt("return", null);
                  case 2:
                    _context10.next = 4;
                    return this.services.channelMetadataClient.getChannelMetadata(this.conversation.sid, this.sid);
                  case 4:
                    return _context10.abrupt("return", _context10.sent);
                  case 5:
                  case "end":
                    return _context10.stop();
                }
              }
            }, _callee10, this);
          }));
          function getChannelMetadata() {
            return _getChannelMetadata.apply(this, arguments);
          }
          return getChannelMetadata;
        }()
        /**
         * Get recipients of the message.
         */
      }, {
        key: "getMessageRecipients",
        value: function() {
          var _getMessageRecipients = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee11() {
            return _regeneratorRuntime__default["default"].wrap(function _callee11$(_context11) {
              while (1) {
                switch (_context11.prev = _context11.next) {
                  case 0:
                    _context11.next = 2;
                    return this.services.messageRecipientsClient.getRecipientsFromMessage(this.conversation.sid, this.sid);
                  case 2:
                    return _context11.abrupt("return", _context11.sent);
                  case 3:
                  case "end":
                    return _context11.stop();
                }
              }
            }, _callee11, this);
          }));
          function getMessageRecipients() {
            return _getMessageRecipients.apply(this, arguments);
          }
          return getMessageRecipients;
        }()
      }]);
      return Message2;
    }(replayEventEmitter.ReplayEventEmitter);
    function _wrapMedia2(media) {
      var category = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      return media ? category ? new Media(_objectSpread$4(_objectSpread$4({}, media), {}, {
        category
      }), this.services) : new Media(media, this.services) : null;
    }
    function _assignMedias2(medias, media) {
      var _this8 = this;
      this.state.media = _classPrivateMethodGet(this, _wrapMedia, _wrapMedia2).call(this, media);
      this.state.medias = medias ? medias.map(function(m) {
        return _classPrivateMethodGet(_this8, _wrapMedia, _wrapMedia2).call(_this8, m);
      }).filter(function(el) {
        return el !== null;
      }) : media && !medias ? [_classPrivateMethodGet(this, _wrapMedia, _wrapMedia2).call(this, media, "media")].filter(function(el) {
        return el !== null;
      }) : null;
    }
    _defineProperty__default["default"](Message, "updated", "updated");
    __decorate([deprecationDecorator.deprecated("getMediaByCategory", "getMediaByCategories"), __metadata("design:type", Function), __metadata("design:paramtypes", [Array]), __metadata("design:returntype", Array)], Message.prototype, "getMediaByCategory", null);
    __decorate([declarativeTypeValidator.validateTypes([declarativeTypeValidator.nonEmptyString, "undefined"]), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", Media)], Message.prototype, "getEmailBody", null);
    __decorate([declarativeTypeValidator.validateTypes([declarativeTypeValidator.nonEmptyString, "undefined"]), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", Media)], Message.prototype, "getEmailHistory", null);
    __decorate([declarativeTypeValidator.validateTypesAsync("string"), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", Promise)], Message.prototype, "updateBody", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(json), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", Promise)], Message.prototype, "updateAttributes", null);
    __decorate([deprecationDecorator.deprecated("attachTemporaryUrlsFor", "getTemporaryContentUrlsForMedia"), __metadata("design:type", Function), __metadata("design:paramtypes", [Array]), __metadata("design:returntype", Promise)], Message.prototype, "attachTemporaryUrlsFor", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyArray("media", Media)), __metadata("design:type", Function), __metadata("design:paramtypes", [Array]), __metadata("design:returntype", mcsClient.CancellablePromise)], Message.prototype, "getTemporaryContentUrlsForMedia", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyArray("strings", "string")), __metadata("design:type", Function), __metadata("design:paramtypes", [Array]), __metadata("design:returntype", mcsClient.CancellablePromise)], Message.prototype, "getTemporaryContentUrlsForMediaSids", null);
    function ownKeys$3(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread$3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys$3(Object(source), true).forEach(function(key) {
          _defineProperty__default["default"](target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _createForOfIteratorHelper$4(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray$4(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      } };
    }
    function _unsupportedIterableToArray$4(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray$4(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen);
    }
    function _arrayLikeToArray$4(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _createSuper$5(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$5();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$5() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var log$2 = Logger.scope("Messages");
    var Messages = function(_ReplayEventEmitter) {
      _inherits__default["default"](Messages2, _ReplayEventEmitter);
      var _super = _createSuper$5(Messages2);
      function Messages2(conversation, configuration, services) {
        var _this;
        _classCallCheck__default["default"](this, Messages2);
        _this = _super.call(this);
        _this.conversation = conversation;
        _this.configuration = configuration;
        _this.services = services;
        _this.messagesByIndex = /* @__PURE__ */ new Map();
        _this.messagesListPromise = null;
        return _this;
      }
      _createClass__default["default"](Messages2, [{
        key: "subscribe",
        value: function() {
          var _subscribe = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee(arg) {
            var _this2 = this;
            var list;
            return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (!this.messagesListPromise) {
                      _context.next = 2;
                      break;
                    }
                    return _context.abrupt("return", this.messagesListPromise);
                  case 2:
                    this.messagesListPromise = typeof arg === "string" ? this.services.syncClient.list({
                      id: arg,
                      mode: "open_existing"
                    }) : Promise.resolve(arg);
                    _context.prev = 3;
                    _context.next = 6;
                    return this.messagesListPromise;
                  case 6:
                    list = _context.sent;
                    list.on("itemAdded", function(args) {
                      log$2.debug("".concat(_this2.conversation.sid, " itemAdded: ").concat(args.item.index));
                      var links = {
                        self: "".concat(_this2.conversation._links.messages, "/").concat(args.item.data.sid),
                        conversation: _this2.conversation._links.self,
                        messages_receipts: "".concat(_this2.conversation._links.messages, "/").concat(args.item.data.sid, "/Receipts")
                      };
                      var message = new Message(args.item.index, args.item.data, _this2.conversation, links, _this2.configuration, _this2.services);
                      if (_this2.messagesByIndex.has(message.index)) {
                        log$2.debug("Message arrived, but is already known and ignored", _this2.conversation.sid, message.index);
                        return;
                      }
                      _this2.messagesByIndex.set(message.index, message);
                      message.on("updated", function(args2) {
                        return _this2.emit("messageUpdated", args2);
                      });
                      _this2.emit("messageAdded", message);
                    });
                    list.on("itemRemoved", function(args) {
                      log$2.debug("#{this.conversation.sid} itemRemoved: ".concat(args.index));
                      var index = args.index;
                      if (_this2.messagesByIndex.has(index)) {
                        var message = _this2.messagesByIndex.get(index);
                        if (!message) {
                          return;
                        }
                        _this2.messagesByIndex.delete(message.index);
                        message.removeAllListeners("updated");
                        _this2.emit("messageRemoved", message);
                      }
                    });
                    list.on("itemUpdated", function(args) {
                      log$2.debug("".concat(_this2.conversation.sid, " itemUpdated: ").concat(args.item.index));
                      var message = _this2.messagesByIndex.get(args.item.index);
                      if (message) {
                        message._update(args.item.data);
                      }
                    });
                    return _context.abrupt("return", list);
                  case 13:
                    _context.prev = 13;
                    _context.t0 = _context["catch"](3);
                    this.messagesListPromise = null;
                    if (this.services.syncClient.connectionState !== "disconnected") {
                      log$2.error("Failed to get messages object for conversation", this.conversation.sid, _context.t0);
                    }
                    log$2.debug("ERROR: Failed to get messages object for conversation", this.conversation.sid, _context.t0);
                    throw _context.t0;
                  case 19:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[3, 13]]);
          }));
          function subscribe(_x) {
            return _subscribe.apply(this, arguments);
          }
          return subscribe;
        }()
      }, {
        key: "unsubscribe",
        value: function() {
          var _unsubscribe = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee2() {
            var entity;
            return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    if (this.messagesListPromise) {
                      _context2.next = 2;
                      break;
                    }
                    return _context2.abrupt("return");
                  case 2:
                    _context2.next = 4;
                    return this.messagesListPromise;
                  case 4:
                    entity = _context2.sent;
                    entity.close();
                    this.messagesListPromise = null;
                  case 7:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function unsubscribe() {
            return _unsubscribe.apply(this, arguments);
          }
          return unsubscribe;
        }()
        /**
         * Send a message to the conversation. The message could include text and multiple media attachments.
         * @param message Message to post
         */
      }, {
        key: "sendV2",
        value: function sendV2(message) {
          var _this3 = this;
          log$2.debug("Sending message V2", message.mediaContent, message.attributes, message.emailOptions);
          return new mcsClient.CancellablePromise(function() {
            var _ref = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee3(resolve, reject, onCancel) {
              var _message$emailOptions;
              var media, requests, _iterator, _step, _step$value, category, mediaContent, _mediaContent$content, _mediaContent$media, request, messagesPostRequest;
              return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      media = [];
                      requests = [];
                      onCancel(function() {
                        requests.forEach(function(request2) {
                          return request2.cancel();
                        });
                      });
                      _iterator = _createForOfIteratorHelper$4(message.mediaContent);
                      _context3.prev = 4;
                      _iterator.s();
                    case 6:
                      if ((_step = _iterator.n()).done) {
                        _context3.next = 25;
                        break;
                      }
                      _step$value = _slicedToArray__default["default"](_step.value, 2), category = _step$value[0], mediaContent = _step$value[1];
                      _context3.prev = 8;
                      log$2.debug("Adding media to a message as ".concat(mediaContent instanceof FormData ? "FormData" : "SendMediaOptions"), mediaContent);
                      request = mediaContent instanceof FormData ? _this3.services.mcsClient.postFormData(mediaContent, category) : _this3.services.mcsClient.post((_mediaContent$content = mediaContent.contentType) !== null && _mediaContent$content !== void 0 ? _mediaContent$content : "", (_mediaContent$media = mediaContent.media) !== null && _mediaContent$media !== void 0 ? _mediaContent$media : "", category, mediaContent.filename);
                      requests.push(request);
                      _context3.t0 = media;
                      _context3.next = 15;
                      return request;
                    case 15:
                      _context3.t1 = _context3.sent;
                      _context3.t0.push.call(_context3.t0, _context3.t1);
                      _context3.next = 23;
                      break;
                    case 19:
                      _context3.prev = 19;
                      _context3.t2 = _context3["catch"](8);
                      reject(_context3.t2);
                      return _context3.abrupt("return");
                    case 23:
                      _context3.next = 6;
                      break;
                    case 25:
                      _context3.next = 30;
                      break;
                    case 27:
                      _context3.prev = 27;
                      _context3.t3 = _context3["catch"](4);
                      _iterator.e(_context3.t3);
                    case 30:
                      _context3.prev = 30;
                      _iterator.f();
                      return _context3.finish(30);
                    case 33:
                      messagesPostRequest = _this3.services.commandExecutor.mutateResource("post", _this3.conversation._links.messages, {
                        body: message.text,
                        subject: (_message$emailOptions = message.emailOptions) === null || _message$emailOptions === void 0 ? void 0 : _message$emailOptions.subject,
                        media_sids: media.map(function(m) {
                          return m.sid;
                        }),
                        attributes: typeof message.attributes !== "undefined" ? JSON.stringify(message.attributes) : void 0,
                        content_sid: message.contentSid,
                        content_variables: typeof message.contentVariables !== "undefined" ? JSON.stringify(message.contentVariables.reduce(function(accum, current) {
                          return _objectSpread$3(_objectSpread$3({}, accum), {}, _defineProperty__default["default"]({}, current.name, current.value));
                        }, {})) : void 0
                      });
                      _context3.prev = 34;
                      _context3.t4 = resolve;
                      _context3.next = 38;
                      return messagesPostRequest;
                    case 38:
                      _context3.t5 = _context3.sent;
                      (0, _context3.t4)(_context3.t5);
                      _context3.next = 45;
                      break;
                    case 42:
                      _context3.prev = 42;
                      _context3.t6 = _context3["catch"](34);
                      reject(_context3.t6);
                    case 45:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _callee3, null, [[4, 27, 30, 33], [8, 19], [34, 42]]);
            }));
            return function(_x2, _x3, _x4) {
              return _ref.apply(this, arguments);
            };
          }());
        }
        /**
         * Send Message to the conversation
         * @param message Message to post
         * @param attributes Message attributes
         * @param emailOptions Options that modify E-mail integration behaviors.
         * @returns Returns promise which can fail
         */
      }, {
        key: "send",
        value: function() {
          var _send = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee4(message) {
            var attributes, emailOptions, _args4 = arguments;
            return _regeneratorRuntime__default["default"].wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    attributes = _args4.length > 1 && _args4[1] !== void 0 ? _args4[1] : {};
                    emailOptions = _args4.length > 2 ? _args4[2] : void 0;
                    log$2.debug("Sending text message", message, attributes, emailOptions);
                    return _context4.abrupt("return", this.services.commandExecutor.mutateResource("post", this.conversation._links.messages, {
                      body: message !== null && message !== void 0 ? message : "",
                      attributes: typeof attributes !== "undefined" ? JSON.stringify(attributes) : void 0,
                      subject: emailOptions === null || emailOptions === void 0 ? void 0 : emailOptions.subject
                    }));
                  case 4:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));
          function send(_x5) {
            return _send.apply(this, arguments);
          }
          return send;
        }()
        /**
         * Send Media Message to the conversation
         * @param mediaContent Media content to post
         * @param attributes Message attributes
         * @param emailOptions Email options
         * @returns Returns promise which can fail
         */
      }, {
        key: "sendMedia",
        value: function() {
          var _sendMedia = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee5(mediaContent) {
            var _mediaContent$content2, _mediaContent$media2;
            var attributes, emailOptions, media, _args5 = arguments;
            return _regeneratorRuntime__default["default"].wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    attributes = _args5.length > 1 && _args5[1] !== void 0 ? _args5[1] : {};
                    emailOptions = _args5.length > 2 ? _args5[2] : void 0;
                    log$2.debug("Sending media message", mediaContent, attributes, emailOptions);
                    log$2.debug("Sending media message as ".concat(mediaContent instanceof FormData ? "FormData" : "SendMediaOptions"), mediaContent, attributes);
                    if (!(mediaContent instanceof FormData)) {
                      _context5.next = 10;
                      break;
                    }
                    _context5.next = 7;
                    return this.services.mcsClient.postFormData(mediaContent);
                  case 7:
                    _context5.t0 = _context5.sent;
                    _context5.next = 13;
                    break;
                  case 10:
                    _context5.next = 12;
                    return this.services.mcsClient.post((_mediaContent$content2 = mediaContent.contentType) !== null && _mediaContent$content2 !== void 0 ? _mediaContent$content2 : "", (_mediaContent$media2 = mediaContent.media) !== null && _mediaContent$media2 !== void 0 ? _mediaContent$media2 : "", "media", mediaContent.filename);
                  case 12:
                    _context5.t0 = _context5.sent;
                  case 13:
                    media = _context5.t0;
                    _context5.next = 16;
                    return this.services.commandExecutor.mutateResource("post", this.conversation._links.messages, {
                      media_sids: [media.sid],
                      attributes: typeof attributes !== "undefined" ? JSON.stringify(attributes) : void 0
                    });
                  case 16:
                    return _context5.abrupt("return", _context5.sent);
                  case 17:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));
          function sendMedia(_x6) {
            return _sendMedia.apply(this, arguments);
          }
          return sendMedia;
        }()
        /**
         * Returns messages from conversation using paginator interface
         * @param pageSize Number of messages to return in single chunk. By default it's 30.
         * @param anchor Most early message id which is already known, or 'end' by default
         * @param direction Pagination order 'backwards' or 'forward', 'forward' by default
         * @returns Last page of messages by default
         */
      }, {
        key: "getMessages",
        value: function() {
          var _getMessages2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee6(pageSize, anchor) {
            var direction, _args6 = arguments;
            return _regeneratorRuntime__default["default"].wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    direction = _args6.length > 2 && _args6[2] !== void 0 ? _args6[2] : "backwards";
                    return _context6.abrupt("return", this._getMessages(pageSize, anchor, direction));
                  case 2:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, this);
          }));
          function getMessages(_x7, _x8) {
            return _getMessages2.apply(this, arguments);
          }
          return getMessages;
        }()
      }, {
        key: "_wrapPaginator",
        value: function _wrapPaginator(order, page, op) {
          var _this4 = this;
          var shouldReverse = order === "desc";
          var nextPage = function nextPage2() {
            return page.nextPage().then(function(page2) {
              return _this4._wrapPaginator(order, page2, op);
            });
          };
          var previousPage = function previousPage2() {
            return page.prevPage().then(function(page2) {
              return _this4._wrapPaginator(order, page2, op);
            });
          };
          return op(page.items).then(function(items) {
            return {
              items: items.sort(function(x, y) {
                return x.index - y.index;
              }),
              hasPrevPage: shouldReverse ? page.hasNextPage : page.hasPrevPage,
              hasNextPage: shouldReverse ? page.hasPrevPage : page.hasNextPage,
              prevPage: shouldReverse ? nextPage : previousPage,
              nextPage: shouldReverse ? previousPage : nextPage
            };
          });
        }
      }, {
        key: "_upsertMessage",
        value: function _upsertMessage(index, value) {
          var _this5 = this;
          var cachedMessage = this.messagesByIndex.get(index);
          if (cachedMessage) {
            return cachedMessage;
          }
          var links = {
            self: "".concat(this.conversation._links.messages, "/").concat(value.sid),
            conversation: this.conversation._links.self,
            messages_receipts: "".concat(this.conversation._links.messages, "/").concat(value.sid, "/Receipts")
          };
          var message = new Message(index, value, this.conversation, links, this.configuration, this.services);
          this.messagesByIndex.set(message.index, message);
          message.on("updated", function(args) {
            return _this5.emit("messageUpdated", args);
          });
          return message;
        }
        /**
         * Returns last messages from conversation
         * @param {Number} [pageSize] Number of messages to return in single chunk. By default it's 30.
         * @param {String} [anchor] Most early message id which is already known, or 'end' by default
         * @param {String} [direction] Pagination order 'backwards' or 'forward', or 'forward' by default
         * @returns {Promise<SyncPaginator<Message>>} last page of messages by default
         * @private
         */
      }, {
        key: "_getMessages",
        value: function() {
          var _getMessages3 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee7() {
            var _this6 = this;
            var pageSize, anchor, direction, order, list, page, _args7 = arguments;
            return _regeneratorRuntime__default["default"].wrap(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    pageSize = _args7.length > 0 && _args7[0] !== void 0 ? _args7[0] : 30;
                    anchor = _args7.length > 1 && _args7[1] !== void 0 ? _args7[1] : "end";
                    direction = _args7.length > 2 && _args7[2] !== void 0 ? _args7[2] : "forward";
                    order = direction === "backwards" ? "desc" : "asc";
                    _context7.next = 6;
                    return this.messagesListPromise;
                  case 6:
                    list = _context7.sent;
                    _context7.next = 9;
                    return list === null || list === void 0 ? void 0 : list.getItems({
                      from: anchor !== "end" ? anchor : void 0,
                      pageSize,
                      order,
                      limit: pageSize
                      // @todo Limit equals pageSize by default in Sync. This is probably not ideal.
                    });
                  case 9:
                    page = _context7.sent;
                    _context7.next = 12;
                    return this._wrapPaginator(order, page, function(items) {
                      return Promise.all(items.map(function(item) {
                        return _this6._upsertMessage(item.index, item.data);
                      }));
                    });
                  case 12:
                    return _context7.abrupt("return", _context7.sent);
                  case 13:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee7, this);
          }));
          function _getMessages() {
            return _getMessages3.apply(this, arguments);
          }
          return _getMessages;
        }()
      }]);
      return Messages2;
    }(replayEventEmitter.ReplayEventEmitter);
    var UnsentMessage = function() {
      function UnsentMessage2(messagesEntity) {
        _classCallCheck__default["default"](this, UnsentMessage2);
        _defineProperty__default["default"](this, "attributes", {});
        _defineProperty__default["default"](this, "mediaContent", []);
        _defineProperty__default["default"](this, "emailOptions", {});
        this.messagesEntity = messagesEntity;
      }
      _createClass__default["default"](UnsentMessage2, [{
        key: "send",
        value: function send() {
          var _this = this;
          return new mcsClient.CancellablePromise(function() {
            var _ref = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee(resolve, reject, onCancel) {
              var request, response;
              return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      request = _this.messagesEntity.sendV2(_this);
                      onCancel(function() {
                        return request.cancel();
                      });
                      _context.prev = 2;
                      _context.next = 5;
                      return request;
                    case 5:
                      response = _context.sent;
                      resolve(parseToNumber(response.index));
                      _context.next = 12;
                      break;
                    case 9:
                      _context.prev = 9;
                      _context.t0 = _context["catch"](2);
                      reject(_context.t0);
                    case 12:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, null, [[2, 9]]);
            }));
            return function(_x, _x2, _x3) {
              return _ref.apply(this, arguments);
            };
          }());
        }
      }]);
      return UnsentMessage2;
    }();
    var MessageBuilder = function() {
      function MessageBuilder2(limits, messagesEntity) {
        _classCallCheck__default["default"](this, MessageBuilder2);
        this.limits = limits;
        this.message = new UnsentMessage(messagesEntity);
        this.emailBodies = /* @__PURE__ */ new Map();
        this.emailHistories = /* @__PURE__ */ new Map();
      }
      _createClass__default["default"](MessageBuilder2, [{
        key: "setBody",
        value: function setBody(text) {
          this.message.text = text;
          return this;
        }
        /**
         * Sets the message subject.
         * @param subject Contents of the subject.
         */
      }, {
        key: "setSubject",
        value: function setSubject(subject) {
          this.message.emailOptions.subject = subject;
          return this;
        }
        /**
         * Sets the message attributes.
         * @param attributes Message attributes.
         */
      }, {
        key: "setAttributes",
        value: function setAttributes(attributes) {
          this.message.attributes = attributes;
          return this;
        }
        /**
         * Set the email body with a given content type.
         * @param contentType Format of the body to set (text/plain or text/html).
         * @param body Body payload in the selected format.
         */
      }, {
        key: "setEmailBody",
        value: function setEmailBody(contentType, body) {
          this.emailBodies.set(contentType, body);
          return this;
        }
        /**
         * Set the email history with a given content type.
         * @param contentType Format of the history to set (text/plain or text/html).
         * @param history History payload in the selected format.
         */
      }, {
        key: "setEmailHistory",
        value: function setEmailHistory(contentType, history) {
          this.emailHistories.set(contentType, history);
          return this;
        }
        /**
         * Adds {@link ContentTemplate} SID for the message alongside optional
         * variables. When no variables provided, the default values will be used.
         *
         * Adding the content SID converts the message to a rich message. In this
         * case, other fields are ignored and the message is sent using the content
         * from the the {@link ContentTemplate}.
         *
         * Use {@link Client.getContentTemplates} to request all available
         * {@link ContentTemplate}s.
         *
         * @param contentSid SID of the {@link ContentTemplate}
         * @param variables Custom variables to resolve the template.
         */
      }, {
        key: "setContentTemplate",
        value: function setContentTemplate(contentSid) {
          var contentVariables = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
          this.message.contentSid = contentSid;
          this.message.contentVariables = contentVariables;
          return this;
        }
        /**
         * Adds media to the message.
         * @param payload Media to add.
         */
      }, {
        key: "addMedia",
        value: function addMedia(payload) {
          if (typeof FormData === "undefined" && payload instanceof FormData) {
            throw new Error("Could not add FormData content whilst not in a browser");
          }
          if (!(payload instanceof FormData)) {
            var mediaOptions = payload;
            if (!mediaOptions.contentType || !mediaOptions.media) {
              throw new Error("Media content in SendMediaOptions must contain non-empty contentType and media");
            }
          }
          this.message.mediaContent.push(["media", payload]);
          return this;
        }
        /**
         * Builds the message, making it ready to be sent.
         */
      }, {
        key: "build",
        value: function build() {
          var _this = this;
          this.emailBodies.forEach(function(_, key) {
            if (!_this.limits.emailBodiesAllowedContentTypes.includes(key)) {
              throw new Error("Unsupported email body content type ".concat(key));
            }
          });
          this.emailHistories.forEach(function(_, key) {
            if (!_this.limits.emailHistoriesAllowedContentTypes.includes(key)) {
              throw new Error("Unsupported email history content type ".concat(key));
            }
          });
          if (this.emailBodies.size > this.limits.emailBodiesAllowedContentTypes.length) {
            throw new Error("Too many email bodies attached to the message (".concat(this.emailBodies.size, " > ").concat(this.limits.emailBodiesAllowedContentTypes.length, ")"));
          }
          if (this.emailHistories.size > this.limits.emailHistoriesAllowedContentTypes.length) {
            throw new Error("Too many email histories attached to the message (".concat(this.emailHistories.size, " > ").concat(this.limits.emailHistoriesAllowedContentTypes.length, ")"));
          }
          if (this.message.mediaContent.length > this.limits.mediaAttachmentsCountLimit) {
            throw new Error("Too many media attachments in the message (".concat(this.message.mediaContent.length, " > ").concat(this.limits.mediaAttachmentsCountLimit, ")"));
          }
          this.emailBodies.forEach(function(body) {
            _this.message.mediaContent.push(["body", body]);
          });
          this.emailHistories.forEach(function(history) {
            _this.message.mediaContent.push(["history", history]);
          });
          return this.message;
        }
        /**
         * Prepares a message and sends it to the conversation.
         */
      }, {
        key: "buildAndSend",
        value: function buildAndSend() {
          return this.build().send();
        }
      }]);
      return MessageBuilder2;
    }();
    __decorate([declarativeTypeValidator.validateTypes("string"), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", MessageBuilder)], MessageBuilder.prototype, "setBody", null);
    __decorate([declarativeTypeValidator.validateTypes("string"), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", MessageBuilder)], MessageBuilder.prototype, "setSubject", null);
    __decorate([declarativeTypeValidator.validateTypes(json), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", MessageBuilder)], MessageBuilder.prototype, "setAttributes", null);
    __decorate([declarativeTypeValidator.validateTypes("string", [FormData, sendMediaOptions]), __metadata("design:type", Function), __metadata("design:paramtypes", [String, Object]), __metadata("design:returntype", MessageBuilder)], MessageBuilder.prototype, "setEmailBody", null);
    __decorate([declarativeTypeValidator.validateTypes("string", [FormData, sendMediaOptions]), __metadata("design:type", Function), __metadata("design:paramtypes", [String, Object]), __metadata("design:returntype", MessageBuilder)], MessageBuilder.prototype, "setEmailHistory", null);
    __decorate([declarativeTypeValidator.validateTypes("string", [declarativeTypeValidator.array("content variables", ContentTemplateVariable), "undefined"]), __metadata("design:type", Function), __metadata("design:paramtypes", [String, Array]), __metadata("design:returntype", MessageBuilder)], MessageBuilder.prototype, "setContentTemplate", null);
    __decorate([declarativeTypeValidator.validateTypes([FormData, sendMediaOptions]), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", MessageBuilder)], MessageBuilder.prototype, "addMedia", null);
    function _createForOfIteratorHelper$3(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      } };
    }
    function _unsupportedIterableToArray$3(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray$3(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen);
    }
    function _arrayLikeToArray$3(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _createSuper$4(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$4();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$4() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var fieldMappings = {
      lastMessage: "lastMessage",
      attributes: "attributes",
      createdBy: "createdBy",
      dateCreated: "dateCreated",
      dateUpdated: "dateUpdated",
      friendlyName: "friendlyName",
      lastConsumedMessageIndex: "lastConsumedMessageIndex",
      notificationLevel: "notificationLevel",
      sid: "sid",
      status: "status",
      uniqueName: "uniqueName",
      state: "state",
      bindings: "bindings"
    };
    var Conversation = function(_ReplayEventEmitter) {
      _inherits__default["default"](Conversation2, _ReplayEventEmitter);
      var _super = _createSuper$4(Conversation2);
      function Conversation2(descriptor, sid, links, configuration, services) {
        var _descriptor$attribute, _descriptor$bindings;
        var _this;
        _classCallCheck__default["default"](this, Conversation2);
        _this = _super.call(this);
        _this.sid = sid;
        _this._links = links;
        _this._configuration = configuration;
        _this._services = services;
        _this._entityName = descriptor.channel;
        _this._internalState = {
          uniqueName: descriptor.uniqueName || null,
          status: "notParticipating",
          attributes: (_descriptor$attribute = descriptor.attributes) !== null && _descriptor$attribute !== void 0 ? _descriptor$attribute : {},
          createdBy: descriptor.createdBy,
          dateCreated: parseTime(descriptor.dateCreated),
          dateUpdated: parseTime(descriptor.dateUpdated),
          friendlyName: descriptor.friendlyName || null,
          lastReadMessageIndex: Number.isInteger(descriptor.lastConsumedMessageIndex) ? descriptor.lastConsumedMessageIndex : null,
          bindings: (_descriptor$bindings = descriptor.bindings) !== null && _descriptor$bindings !== void 0 ? _descriptor$bindings : {}
        };
        if (descriptor.notificationLevel) {
          _this._internalState.notificationLevel = descriptor.notificationLevel;
        }
        var participantsLinks = {
          participants: _this._links.participants
        };
        _this._participants = /* @__PURE__ */ new Map();
        _this._participantsEntity = new Participants(
          _assertThisInitialized__default["default"](_this),
          _this._participants,
          // state leak
          participantsLinks,
          _this._services
        );
        _this._participantsEntity.on(Conversation2.participantJoined, function(participant) {
          return (
            // @todo update participants map here??
            _this.emit(Conversation2.participantJoined, participant)
          );
        });
        _this._participantsEntity.on(Conversation2.participantLeft, function(participant) {
          return (
            // @todo update participants map here??
            _this.emit(Conversation2.participantLeft, participant)
          );
        });
        _this._participantsEntity.on(Conversation2.participantUpdated, function(args) {
          return (
            // @todo update participants map here??
            _this.emit(Conversation2.participantUpdated, args)
          );
        });
        _this._messagesEntity = new Messages(_assertThisInitialized__default["default"](_this), configuration, services);
        _this._messagesEntity.on(Conversation2.messageAdded, function(message) {
          return _this._onMessageAdded(message);
        });
        _this._messagesEntity.on(Conversation2.messageUpdated, function(args) {
          return _this.emit(Conversation2.messageUpdated, args);
        });
        _this._messagesEntity.on(Conversation2.messageRemoved, function(message) {
          return _this.emit(Conversation2.messageRemoved, message);
        });
        return _this;
      }
      _createClass__default["default"](Conversation2, [{
        key: "uniqueName",
        get: function get() {
          return this._internalState.uniqueName;
        }
        /**
         * Status of the conversation.
         */
      }, {
        key: "status",
        get: function get() {
          return this._internalState.status;
        }
        /**
         * Name of the conversation.
         */
      }, {
        key: "friendlyName",
        get: function get() {
          return this._internalState.friendlyName;
        }
        /**
         * Date this conversation was last updated on.
         */
      }, {
        key: "dateUpdated",
        get: function get() {
          return this._internalState.dateUpdated;
        }
        /**
         * Date this conversation was created on.
         */
      }, {
        key: "dateCreated",
        get: function get() {
          return this._internalState.dateCreated;
        }
        /**
         * Identity of the user that created this conversation.
         */
      }, {
        key: "createdBy",
        get: function get() {
          var _this$_internalState$;
          return (_this$_internalState$ = this._internalState.createdBy) !== null && _this$_internalState$ !== void 0 ? _this$_internalState$ : "";
        }
        /**
         * Custom attributes of the conversation.
         */
      }, {
        key: "attributes",
        get: function get() {
          return this._internalState.attributes;
        }
        /**
         * Index of the last message the user has read in this conversation.
         */
      }, {
        key: "lastReadMessageIndex",
        get: function get() {
          return this._internalState.lastReadMessageIndex;
        }
        /**
         * Last message sent to this conversation.
         */
      }, {
        key: "lastMessage",
        get: function get() {
          var _this$_internalState$2;
          return (_this$_internalState$2 = this._internalState.lastMessage) !== null && _this$_internalState$2 !== void 0 ? _this$_internalState$2 : void 0;
        }
        /**
         * User notification level for this conversation.
         */
      }, {
        key: "notificationLevel",
        get: function get() {
          var _this$_internalState$3;
          return (_this$_internalState$3 = this._internalState.notificationLevel) !== null && _this$_internalState$3 !== void 0 ? _this$_internalState$3 : "default";
        }
        /**
         * Conversation bindings. An undocumented feature (for now).
         * @internal
         */
      }, {
        key: "bindings",
        get: function get() {
          return this._internalState.bindings;
        }
        /**
         * Current conversation limits.
         */
      }, {
        key: "limits",
        get: function get() {
          return this._configuration.limits;
        }
        /**
         * State of the conversation.
         */
      }, {
        key: "state",
        get: function get() {
          return this._internalState.state;
        }
        /**
         * Source of the conversation update.
         * @internal
         */
      }, {
        key: "_statusSource",
        get: function get() {
          return this._dataSource;
        }
        /**
         * Preprocess the update object.
         * @param update The update object received from Sync.
         * @param conversationSid The SID of the conversation in question.
         */
      }, {
        key: "add",
        value: (
          /**
           * Add a participant to the conversation by its identity.
           * @param identity Identity of the Client to add.
           * @param attributes Attributes to be attached to the participant.
           * @returns The added participant.
           */
          function() {
            var _add = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee(identity, attributes) {
              return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      return _context.abrupt("return", this._participantsEntity.add(identity, attributes !== null && attributes !== void 0 ? attributes : {}));
                    case 1:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, this);
            }));
            function add(_x, _x2) {
              return _add.apply(this, arguments);
            }
            return add;
          }()
        )
        /**
         * Add a non-chat participant to the conversation.
         * @param proxyAddress Proxy (Twilio) address of the participant.
         * @param address User address of the participant.
         * @param attributes Attributes to be attached to the participant.
         * @param bindingOptions Options for adding email participants - name and
         * CC/To level.
         * @returns The added participant.
         */
      }, {
        key: "addNonChatParticipant",
        value: function() {
          var _addNonChatParticipant = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee2(proxyAddress, address) {
            var attributes, bindingOptions, _args2 = arguments;
            return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    attributes = _args2.length > 2 && _args2[2] !== void 0 ? _args2[2] : {};
                    bindingOptions = _args2.length > 3 && _args2[3] !== void 0 ? _args2[3] : {};
                    return _context2.abrupt("return", this._participantsEntity.addNonChatParticipant(proxyAddress, address, attributes !== null && attributes !== void 0 ? attributes : {}, bindingOptions !== null && bindingOptions !== void 0 ? bindingOptions : {}));
                  case 3:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function addNonChatParticipant(_x3, _x4) {
            return _addNonChatParticipant.apply(this, arguments);
          }
          return addNonChatParticipant;
        }()
        /**
         * Advance the conversation's last read message index to the current read
         * horizon. Rejects if the user is not a participant of the conversation. Last
         * read message index is updated only if the new index value is higher than
         * the previous.
         * @param index Message index to advance to.
         * @return Resulting unread messages count in the conversation.
         */
      }, {
        key: "advanceLastReadMessageIndex",
        value: function() {
          var _advanceLastReadMessageIndex = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee3(index) {
            var _this$lastReadMessage;
            return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    _context3.next = 2;
                    return this._subscribeStreams();
                  case 2:
                    if (!(index < ((_this$lastReadMessage = this.lastReadMessageIndex) !== null && _this$lastReadMessage !== void 0 ? _this$lastReadMessage : 0))) {
                      _context3.next = 6;
                      break;
                    }
                    _context3.next = 5;
                    return this._setLastReadMessageIndex(this.lastReadMessageIndex);
                  case 5:
                    return _context3.abrupt("return", _context3.sent);
                  case 6:
                    _context3.next = 8;
                    return this._setLastReadMessageIndex(index);
                  case 8:
                    return _context3.abrupt("return", _context3.sent);
                  case 9:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));
          function advanceLastReadMessageIndex(_x5) {
            return _advanceLastReadMessageIndex.apply(this, arguments);
          }
          return advanceLastReadMessageIndex;
        }()
        /**
         * Delete the conversation and unsubscribe from its events.
         */
      }, {
        key: "delete",
        value: function() {
          var _delete2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee4() {
            return _regeneratorRuntime__default["default"].wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    _context4.next = 2;
                    return this._services.commandExecutor.mutateResource("delete", this._links.self);
                  case 2:
                    return _context4.abrupt("return", this);
                  case 3:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));
          function _delete() {
            return _delete2.apply(this, arguments);
          }
          return _delete;
        }()
        /**
         * Get the custom attributes of this Conversation.
         */
      }, {
        key: "getAttributes",
        value: function() {
          var _getAttributes = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee5() {
            return _regeneratorRuntime__default["default"].wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    _context5.next = 2;
                    return this._subscribe();
                  case 2:
                    return _context5.abrupt("return", this.attributes);
                  case 3:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));
          function getAttributes() {
            return _getAttributes.apply(this, arguments);
          }
          return getAttributes;
        }()
        /**
         * Returns messages from the conversation using the paginator interface.
         * @param pageSize Number of messages to return in a single chunk. Default is
         * 30.
         * @param anchor Index of the newest message to fetch. Default is from the
         * end.
         * @param direction Query direction. By default, it queries backwards
         * from newer to older. The `"forward"` value will query in the opposite
         * direction.
         * @return A page of messages.
         */
      }, {
        key: "getMessages",
        value: function() {
          var _getMessages = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee6(pageSize, anchor, direction) {
            return _regeneratorRuntime__default["default"].wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    _context6.next = 2;
                    return this._subscribeStreams();
                  case 2:
                    return _context6.abrupt("return", this._messagesEntity.getMessages(pageSize, anchor, direction));
                  case 3:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, this);
          }));
          function getMessages(_x6, _x7, _x8) {
            return _getMessages.apply(this, arguments);
          }
          return getMessages;
        }()
        /**
         * Get a list of all the participants who are joined to this conversation.
         */
      }, {
        key: "getParticipants",
        value: function() {
          var _getParticipants = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee7() {
            return _regeneratorRuntime__default["default"].wrap(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    _context7.next = 2;
                    return this._subscribeStreams();
                  case 2:
                    return _context7.abrupt("return", this._participantsEntity.getParticipants());
                  case 3:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee7, this);
          }));
          function getParticipants() {
            return _getParticipants.apply(this, arguments);
          }
          return getParticipants;
        }()
        /**
         * Get conversation participants count.
         *
         * This method is semi-realtime. This means that this data will be eventually
         * correct, but will also be possibly incorrect for a few seconds. The
         * Conversations system does not provide real time events for counter values
         * changes.
         *
         * This is useful for any UI badges, but it is not recommended to build any
         * core application logic based on these counters being accurate in real time.
         */
      }, {
        key: "getParticipantsCount",
        value: function() {
          var _getParticipantsCount = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee8() {
            var _response$body$partic;
            var url, response;
            return _regeneratorRuntime__default["default"].wrap(function _callee8$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    url = new UriBuilder(this._configuration.links.conversations).path(this.sid).build();
                    _context8.next = 3;
                    return this._services.network.get(url);
                  case 3:
                    response = _context8.sent;
                    return _context8.abrupt("return", (_response$body$partic = response.body.participants_count) !== null && _response$body$partic !== void 0 ? _response$body$partic : 0);
                  case 5:
                  case "end":
                    return _context8.stop();
                }
              }
            }, _callee8, this);
          }));
          function getParticipantsCount() {
            return _getParticipantsCount.apply(this, arguments);
          }
          return getParticipantsCount;
        }()
        /**
         * Get a participant by its SID.
         * @param participantSid Participant SID.
         */
      }, {
        key: "getParticipantBySid",
        value: function() {
          var _getParticipantBySid = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee9(participantSid) {
            return _regeneratorRuntime__default["default"].wrap(function _callee9$(_context9) {
              while (1) {
                switch (_context9.prev = _context9.next) {
                  case 0:
                    return _context9.abrupt("return", this._participantsEntity.getParticipantBySid(participantSid));
                  case 1:
                  case "end":
                    return _context9.stop();
                }
              }
            }, _callee9, this);
          }));
          function getParticipantBySid(_x9) {
            return _getParticipantBySid.apply(this, arguments);
          }
          return getParticipantBySid;
        }()
        /**
         * Get a participant by its identity.
         * @param identity Participant identity.
         */
      }, {
        key: "getParticipantByIdentity",
        value: function() {
          var _getParticipantByIdentity = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee10() {
            var identity, _args10 = arguments;
            return _regeneratorRuntime__default["default"].wrap(function _callee10$(_context10) {
              while (1) {
                switch (_context10.prev = _context10.next) {
                  case 0:
                    identity = _args10.length > 0 && _args10[0] !== void 0 ? _args10[0] : "";
                    return _context10.abrupt("return", this._participantsEntity.getParticipantByIdentity(identity !== null && identity !== void 0 ? identity : ""));
                  case 2:
                  case "end":
                    return _context10.stop();
                }
              }
            }, _callee10, this);
          }));
          function getParticipantByIdentity() {
            return _getParticipantByIdentity.apply(this, arguments);
          }
          return getParticipantByIdentity;
        }()
        /**
         * Get the total message count in the conversation.
         *
         * This method is semi-realtime. This means that this data will be eventually
         * correct, but will also be possibly incorrect for a few seconds. The
         * Conversations system does not provide real time events for counter values
         * changes.
         *
         * This is useful for any UI badges, but it is not recommended to build any
         * core application logic based on these counters being accurate in real time.
         */
      }, {
        key: "getMessagesCount",
        value: function() {
          var _getMessagesCount = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee11() {
            var _response$body$messag;
            var url, response;
            return _regeneratorRuntime__default["default"].wrap(function _callee11$(_context11) {
              while (1) {
                switch (_context11.prev = _context11.next) {
                  case 0:
                    url = new UriBuilder(this._configuration.links.conversations).path(this.sid).build();
                    _context11.next = 3;
                    return this._services.network.get(url);
                  case 3:
                    response = _context11.sent;
                    return _context11.abrupt("return", (_response$body$messag = response.body.messages_count) !== null && _response$body$messag !== void 0 ? _response$body$messag : 0);
                  case 5:
                  case "end":
                    return _context11.stop();
                }
              }
            }, _callee11, this);
          }));
          function getMessagesCount() {
            return _getMessagesCount.apply(this, arguments);
          }
          return getMessagesCount;
        }()
        /**
         * Get count of unread messages for the user if they are a participant of this
         * conversation. Rejects if the user is not a participant of the conversation.
         *
         * Use this method to obtain the number of unread messages together with
         * {@link Conversation.updateLastReadMessageIndex} instead of relying on the
         * message indices which may have gaps. See {@link Message.index} for details.
         *
         * This method is semi-realtime. This means that this data will be eventually
         * correct, but it will also be possibly incorrect for a few seconds. The
         * Conversations system does not provide real time events for counter values
         * changes.
         *
         * This is useful for any UI badges, but it is not recommended to build any
         * core application logic based on these counters being accurate in real time.
         *
         * If the read horizon is not set, this function will return null. This could mean
         * that all messages in the conversation are unread, or that the read horizon system
         * is not being used. How to interpret this `null` value is up to the customer application.
         *
         * @return Number of unread messages based on the current read horizon set for
         * the user or `null` if the read horizon is not set.
         */
      }, {
        key: "getUnreadMessagesCount",
        value: function() {
          var _getUnreadMessagesCount = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee12() {
            var url, response, unreadMessageCount;
            return _regeneratorRuntime__default["default"].wrap(function _callee12$(_context12) {
              while (1) {
                switch (_context12.prev = _context12.next) {
                  case 0:
                    url = new UriBuilder(this._configuration.links.myConversations).path(this.sid).build();
                    _context12.next = 3;
                    return this._services.network.get(url);
                  case 3:
                    response = _context12.sent;
                    if (!(response.body.conversation_sid !== this.sid)) {
                      _context12.next = 6;
                      break;
                    }
                    throw new Error("Conversation was not found in the user conversations list");
                  case 6:
                    unreadMessageCount = response.body.unread_messages_count;
                    if (!(typeof unreadMessageCount === "number")) {
                      _context12.next = 9;
                      break;
                    }
                    return _context12.abrupt("return", unreadMessageCount);
                  case 9:
                    return _context12.abrupt("return", null);
                  case 10:
                  case "end":
                    return _context12.stop();
                }
              }
            }, _callee12, this);
          }));
          function getUnreadMessagesCount() {
            return _getUnreadMessagesCount.apply(this, arguments);
          }
          return getUnreadMessagesCount;
        }()
        /**
         * Join the conversation and subscribe to its events.
         */
      }, {
        key: "join",
        value: function() {
          var _join = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee13() {
            return _regeneratorRuntime__default["default"].wrap(function _callee13$(_context13) {
              while (1) {
                switch (_context13.prev = _context13.next) {
                  case 0:
                    _context13.next = 2;
                    return this._services.commandExecutor.mutateResource("post", this._links.participants, {
                      identity: this._configuration.userIdentity
                    });
                  case 2:
                    return _context13.abrupt("return", this);
                  case 3:
                  case "end":
                    return _context13.stop();
                }
              }
            }, _callee13, this);
          }));
          function join() {
            return _join.apply(this, arguments);
          }
          return join;
        }()
        /**
         * Leave the conversation.
         */
      }, {
        key: "leave",
        value: function() {
          var _leave = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee14() {
            return _regeneratorRuntime__default["default"].wrap(function _callee14$(_context14) {
              while (1) {
                switch (_context14.prev = _context14.next) {
                  case 0:
                    if (!(this._internalState.status === "joined")) {
                      _context14.next = 3;
                      break;
                    }
                    _context14.next = 3;
                    return this._services.commandExecutor.mutateResource("delete", "".concat(this._links.participants, "/").concat(encodeURIComponent(this._configuration.userIdentity)));
                  case 3:
                    return _context14.abrupt("return", this);
                  case 4:
                  case "end":
                    return _context14.stop();
                }
              }
            }, _callee14, this);
          }));
          function leave() {
            return _leave.apply(this, arguments);
          }
          return leave;
        }()
        /**
         * Remove a participant from the conversation. When a string is passed as the
         * argument, it will assume that the string is an identity or SID.
         * @param participant Identity, SID or the participant object to remove.
         */
      }, {
        key: "removeParticipant",
        value: function() {
          var _removeParticipant = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee15(participant) {
            return _regeneratorRuntime__default["default"].wrap(function _callee15$(_context15) {
              while (1) {
                switch (_context15.prev = _context15.next) {
                  case 0:
                    _context15.next = 2;
                    return this._participantsEntity.remove(typeof participant === "string" ? participant : participant.sid);
                  case 2:
                  case "end":
                    return _context15.stop();
                }
              }
            }, _callee15, this);
          }));
          function removeParticipant(_x10) {
            return _removeParticipant.apply(this, arguments);
          }
          return removeParticipant;
        }()
        /**
         * Send a message to the conversation.
         * @param message Message body for the text message,
         * `FormData` or {@link SendMediaOptions} for media content. Sending FormData
         * is supported only with the browser engine.
         * @param messageAttributes Attributes for the message.
         * @param emailOptions Email options for the message.
         * @return Index of the new message.
         */
      }, {
        key: "sendMessage",
        value: function() {
          var _sendMessage = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee16(message, messageAttributes, emailOptions) {
            var _parseToNumber2;
            var _parseToNumber, _response, response;
            return _regeneratorRuntime__default["default"].wrap(function _callee16$(_context16) {
              while (1) {
                switch (_context16.prev = _context16.next) {
                  case 0:
                    if (!(typeof message === "string" || message === null)) {
                      _context16.next = 5;
                      break;
                    }
                    _context16.next = 3;
                    return this._messagesEntity.send(message, messageAttributes, emailOptions);
                  case 3:
                    _response = _context16.sent;
                    return _context16.abrupt("return", (_parseToNumber = parseToNumber(_response.index)) !== null && _parseToNumber !== void 0 ? _parseToNumber : 0);
                  case 5:
                    _context16.next = 7;
                    return this._messagesEntity.sendMedia(message, messageAttributes, emailOptions);
                  case 7:
                    response = _context16.sent;
                    return _context16.abrupt("return", (_parseToNumber2 = parseToNumber(response.index)) !== null && _parseToNumber2 !== void 0 ? _parseToNumber2 : 0);
                  case 9:
                  case "end":
                    return _context16.stop();
                }
              }
            }, _callee16, this);
          }));
          function sendMessage(_x11, _x12, _x13) {
            return _sendMessage.apply(this, arguments);
          }
          return sendMessage;
        }()
        /**
         * New interface to prepare for sending a message.
         * Use this instead of {@link Conversation.sendMessage}.
         * @return A MessageBuilder to help set all message sending options.
         */
      }, {
        key: "prepareMessage",
        value: function prepareMessage() {
          return new MessageBuilder(this.limits, this._messagesEntity);
        }
        /**
         * Set last read message index of the conversation to the index of the last
         * known message.
         * @return Resulting unread messages count in the conversation.
         */
      }, {
        key: "setAllMessagesRead",
        value: function() {
          var _setAllMessagesRead = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee17() {
            var messagesPage;
            return _regeneratorRuntime__default["default"].wrap(function _callee17$(_context17) {
              while (1) {
                switch (_context17.prev = _context17.next) {
                  case 0:
                    _context17.next = 2;
                    return this._subscribeStreams();
                  case 2:
                    _context17.next = 4;
                    return this.getMessages(1);
                  case 4:
                    messagesPage = _context17.sent;
                    if (!(messagesPage.items.length > 0)) {
                      _context17.next = 7;
                      break;
                    }
                    return _context17.abrupt("return", this.advanceLastReadMessageIndex(messagesPage.items[0].index));
                  case 7:
                    return _context17.abrupt("return", 0);
                  case 8:
                  case "end":
                    return _context17.stop();
                }
              }
            }, _callee17, this);
          }));
          function setAllMessagesRead() {
            return _setAllMessagesRead.apply(this, arguments);
          }
          return setAllMessagesRead;
        }()
        /**
         * Set all messages in the conversation unread.
         * @returns New count of unread messages after this update.
         */
      }, {
        key: "setAllMessagesUnread",
        value: function() {
          var _setAllMessagesUnread = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee18() {
            return _regeneratorRuntime__default["default"].wrap(function _callee18$(_context18) {
              while (1) {
                switch (_context18.prev = _context18.next) {
                  case 0:
                    _context18.next = 2;
                    return this._subscribeStreams();
                  case 2:
                    _context18.next = 4;
                    return this._setLastReadMessageIndex(null);
                  case 4:
                    return _context18.abrupt("return", _context18.sent);
                  case 5:
                  case "end":
                    return _context18.stop();
                }
              }
            }, _callee18, this);
          }));
          function setAllMessagesUnread() {
            return _setAllMessagesUnread.apply(this, arguments);
          }
          return setAllMessagesUnread;
        }()
        /**
         * Set user notification level for this conversation.
         * @param notificationLevel New user notification level.
         */
      }, {
        key: "setUserNotificationLevel",
        value: function() {
          var _setUserNotificationLevel = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee19(notificationLevel) {
            return _regeneratorRuntime__default["default"].wrap(function _callee19$(_context19) {
              while (1) {
                switch (_context19.prev = _context19.next) {
                  case 0:
                    _context19.next = 2;
                    return this._services.commandExecutor.mutateResource("post", "".concat(this._configuration.links.myConversations, "/").concat(this.sid), {
                      notification_level: notificationLevel
                    });
                  case 2:
                  case "end":
                    return _context19.stop();
                }
              }
            }, _callee19, this);
          }));
          function setUserNotificationLevel(_x14) {
            return _setUserNotificationLevel.apply(this, arguments);
          }
          return setUserNotificationLevel;
        }()
        /**
         * Send a notification to the server indicating that this client is currently
         * typing in this conversation. Typing ended notification is sent after a
         * while automatically, but by calling this method again you ensure that
         * typing ended is not received.
         */
      }, {
        key: "typing",
        value: function typing() {
          return this._services.typingIndicator.send(this.sid);
        }
        /**
         * Update the attributes of the conversation.
         * @param attributes New attributes.
         */
      }, {
        key: "updateAttributes",
        value: function() {
          var _updateAttributes = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee20(attributes) {
            return _regeneratorRuntime__default["default"].wrap(function _callee20$(_context20) {
              while (1) {
                switch (_context20.prev = _context20.next) {
                  case 0:
                    _context20.next = 2;
                    return this._services.commandExecutor.mutateResource("post", this._links.self, {
                      attributes: attributes !== void 0 ? JSON.stringify(attributes) : void 0
                    });
                  case 2:
                    return _context20.abrupt("return", this);
                  case 3:
                  case "end":
                    return _context20.stop();
                }
              }
            }, _callee20, this);
          }));
          function updateAttributes(_x15) {
            return _updateAttributes.apply(this, arguments);
          }
          return updateAttributes;
        }()
        /**
         * Update the friendly name of the conversation.
         * @param friendlyName New friendly name.
         */
      }, {
        key: "updateFriendlyName",
        value: function() {
          var _updateFriendlyName = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee21(friendlyName) {
            return _regeneratorRuntime__default["default"].wrap(function _callee21$(_context21) {
              while (1) {
                switch (_context21.prev = _context21.next) {
                  case 0:
                    if (!(this._internalState.friendlyName !== friendlyName)) {
                      _context21.next = 3;
                      break;
                    }
                    _context21.next = 3;
                    return this._services.commandExecutor.mutateResource("post", this._links.self, {
                      friendly_name: friendlyName
                    });
                  case 3:
                    return _context21.abrupt("return", this);
                  case 4:
                  case "end":
                    return _context21.stop();
                }
              }
            }, _callee21, this);
          }));
          function updateFriendlyName(_x16) {
            return _updateFriendlyName.apply(this, arguments);
          }
          return updateFriendlyName;
        }()
        /**
         * Set the last read message index to the current read horizon.
         * @param index Message index to set as last read. If null is provided, then
         * the behavior is identical to {@link Conversation.setAllMessagesUnread}.
         * @returns New count of unread messages after this update.
         */
      }, {
        key: "updateLastReadMessageIndex",
        value: function() {
          var _updateLastReadMessageIndex = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee22(index) {
            return _regeneratorRuntime__default["default"].wrap(function _callee22$(_context22) {
              while (1) {
                switch (_context22.prev = _context22.next) {
                  case 0:
                    _context22.next = 2;
                    return this._subscribeStreams();
                  case 2:
                    return _context22.abrupt("return", this._setLastReadMessageIndex(index));
                  case 3:
                  case "end":
                    return _context22.stop();
                }
              }
            }, _callee22, this);
          }));
          function updateLastReadMessageIndex(_x17) {
            return _updateLastReadMessageIndex.apply(this, arguments);
          }
          return updateLastReadMessageIndex;
        }()
        /**
         * Update the unique name of the conversation.
         * @param uniqueName New unique name for the conversation. Setting unique name
         * to null removes it.
         */
      }, {
        key: "updateUniqueName",
        value: function() {
          var _updateUniqueName = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee23(uniqueName) {
            return _regeneratorRuntime__default["default"].wrap(function _callee23$(_context23) {
              while (1) {
                switch (_context23.prev = _context23.next) {
                  case 0:
                    if (!(this._internalState.uniqueName !== uniqueName)) {
                      _context23.next = 4;
                      break;
                    }
                    uniqueName || (uniqueName = "");
                    _context23.next = 4;
                    return this._services.commandExecutor.mutateResource("post", this._links.self, {
                      unique_name: uniqueName
                    });
                  case 4:
                    return _context23.abrupt("return", this);
                  case 5:
                  case "end":
                    return _context23.stop();
                }
              }
            }, _callee23, this);
          }));
          function updateUniqueName(_x18) {
            return _updateUniqueName.apply(this, arguments);
          }
          return updateUniqueName;
        }()
        /**
         * Get recipients of all messages in the conversation.
         * @param options Optional configuration, set pageSize to request a specific pagination page size. Page size specifies a number of messages to include in a single batch. Each message may include multiple recipients.
         */
      }, {
        key: "getMessageRecipients",
        value: function() {
          var _getMessageRecipients = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee24(options) {
            return _regeneratorRuntime__default["default"].wrap(function _callee24$(_context24) {
              while (1) {
                switch (_context24.prev = _context24.next) {
                  case 0:
                    _context24.next = 2;
                    return this._services.messageRecipientsClient.getRecipientsFromConversation(this.sid, options);
                  case 2:
                    return _context24.abrupt("return", _context24.sent);
                  case 3:
                  case "end":
                    return _context24.stop();
                }
              }
            }, _callee24, this);
          }));
          function getMessageRecipients(_x19) {
            return _getMessageRecipients.apply(this, arguments);
          }
          return getMessageRecipients;
        }()
        /**
         * Load and subscribe to this conversation and do not subscribe to its
         * participants and messages. This or _subscribeStreams will need to be called
         * before any events in the conversation will fire.
         * @internal
         */
      }, {
        key: "_subscribe",
        value: function() {
          var _subscribe2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee25() {
            var _this2 = this;
            return _regeneratorRuntime__default["default"].wrap(function _callee25$(_context25) {
              while (1) {
                switch (_context25.prev = _context25.next) {
                  case 0:
                    if (!this._entityPromise) {
                      _context25.next = 2;
                      break;
                    }
                    return _context25.abrupt("return", this._entityPromise);
                  case 2:
                    this._entityPromise = this._services.syncClient.document({
                      id: this._entityName,
                      mode: "open_existing"
                    });
                    _context25.prev = 3;
                    _context25.next = 6;
                    return this._entityPromise;
                  case 6:
                    this._entity = _context25.sent;
                    this._entity.on(twilioSync.SyncDocument.updated, function(args) {
                      return _this2._update(args.data);
                    });
                    this._entity.on(twilioSync.SyncDocument.removed, function() {
                      return _this2.emit(Conversation2.removed, _this2);
                    });
                    this._update(this._entity.data);
                    return _context25.abrupt("return", this._entity);
                  case 13:
                    _context25.prev = 13;
                    _context25.t0 = _context25["catch"](3);
                    this._entity = null;
                    this._entityPromise = null;
                    if (this._services.syncClient.connectionState != "disconnected") {
                      Conversation2._logger.error("Failed to get conversation object", _context25.t0);
                    }
                    Conversation2._logger.debug("ERROR: Failed to get conversation object", _context25.t0);
                    throw _context25.t0;
                  case 20:
                  case "end":
                    return _context25.stop();
                }
              }
            }, _callee25, this, [[3, 13]]);
          }));
          function _subscribe() {
            return _subscribe2.apply(this, arguments);
          }
          return _subscribe;
        }()
        /**
         * Fetch participants and messages of the conversation. This method needs to
         * be called during conversation initialization to catch broken conversations
         * (broken conversations are conversations that have essential Sync entities
         * missing, i.e. the conversation document, the messages list or the
         * participant map). In case of this conversation being broken, the method
         * will throw an exception that will be caught and handled gracefully.
         * @internal
         */
      }, {
        key: "_fetchStreams",
        value: function() {
          var _fetchStreams2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee26() {
            var _this$_entity, _this$_entity2;
            var data;
            return _regeneratorRuntime__default["default"].wrap(function _callee26$(_context26) {
              while (1) {
                switch (_context26.prev = _context26.next) {
                  case 0:
                    _context26.next = 2;
                    return this._subscribe();
                  case 2:
                    Conversation2._logger.trace("_streamsAvailable, this.entity.data=", (_this$_entity = this._entity) === null || _this$_entity === void 0 ? void 0 : _this$_entity.data);
                    data = (_this$_entity2 = this._entity) === null || _this$_entity2 === void 0 ? void 0 : _this$_entity2.data;
                    _context26.next = 6;
                    return this._services.syncClient.list({
                      id: data.messages,
                      mode: "open_existing"
                    });
                  case 6:
                    this._messagesList = _context26.sent;
                    _context26.next = 9;
                    return this._services.syncClient.map({
                      id: data.roster,
                      mode: "open_existing"
                    });
                  case 9:
                    this._participantsMap = _context26.sent;
                  case 10:
                  case "end":
                    return _context26.stop();
                }
              }
            }, _callee26, this);
          }));
          function _fetchStreams() {
            return _fetchStreams2.apply(this, arguments);
          }
          return _fetchStreams;
        }()
        /**
         * Load the attributes of this conversation and instantiate its participants
         * and messages. This or _subscribe will need to be called before any events
         * on the conversation will fire. This will need to be called before any
         * events on participants or messages will fire
         * @internal
         */
      }, {
        key: "_subscribeStreams",
        value: function() {
          var _subscribeStreams2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee27() {
            var _this$_entity3, _this$_entity4, _this$_messagesList, _this$_participantsMa, data, messagesObjectName, rosterObjectName;
            return _regeneratorRuntime__default["default"].wrap(function _callee27$(_context27) {
              while (1) {
                switch (_context27.prev = _context27.next) {
                  case 0:
                    _context27.prev = 0;
                    _context27.next = 3;
                    return this._subscribe();
                  case 3:
                    Conversation2._logger.trace("_subscribeStreams, this.entity.data=", (_this$_entity3 = this._entity) === null || _this$_entity3 === void 0 ? void 0 : _this$_entity3.data);
                    data = (_this$_entity4 = this._entity) === null || _this$_entity4 === void 0 ? void 0 : _this$_entity4.data;
                    messagesObjectName = data.messages;
                    rosterObjectName = data.roster;
                    _context27.next = 9;
                    return Promise.all([this._messagesEntity.subscribe((_this$_messagesList = this._messagesList) !== null && _this$_messagesList !== void 0 ? _this$_messagesList : messagesObjectName), this._participantsEntity.subscribe((_this$_participantsMa = this._participantsMap) !== null && _this$_participantsMa !== void 0 ? _this$_participantsMa : rosterObjectName)]);
                  case 9:
                    _context27.next = 16;
                    break;
                  case 11:
                    _context27.prev = 11;
                    _context27.t0 = _context27["catch"](0);
                    if (this._services.syncClient.connectionState !== "disconnected") {
                      Conversation2._logger.error("Failed to subscribe on conversation objects", this.sid, _context27.t0);
                    }
                    Conversation2._logger.debug("ERROR: Failed to subscribe on conversation objects", this.sid, _context27.t0);
                    throw _context27.t0;
                  case 16:
                  case "end":
                    return _context27.stop();
                }
              }
            }, _callee27, this, [[0, 11]]);
          }));
          function _subscribeStreams() {
            return _subscribeStreams2.apply(this, arguments);
          }
          return _subscribeStreams;
        }()
        /**
         * Stop listening for and firing events on this conversation.
         * @internal
         */
      }, {
        key: "_unsubscribe",
        value: function() {
          var _unsubscribe2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee28() {
            return _regeneratorRuntime__default["default"].wrap(function _callee28$(_context28) {
              while (1) {
                switch (_context28.prev = _context28.next) {
                  case 0:
                    if (this._entity) {
                      this._entity.close();
                      this._entity = null;
                      this._entityPromise = null;
                    }
                    return _context28.abrupt("return", Promise.all([this._participantsEntity.unsubscribe(), this._messagesEntity.unsubscribe()]));
                  case 2:
                  case "end":
                    return _context28.stop();
                }
              }
            }, _callee28, this);
          }));
          function _unsubscribe() {
            return _unsubscribe2.apply(this, arguments);
          }
          return _unsubscribe;
        }()
        /**
         * Set conversation status.
         * @internal
         */
      }, {
        key: "_setStatus",
        value: function _setStatus(status, source) {
          var _this3 = this;
          this._dataSource = source;
          if (this._internalState.status === status) {
            return;
          }
          this._internalState.status = status;
          if (status === "joined") {
            this._subscribeStreams().catch(function(err) {
              Conversation2._logger.debug("ERROR while setting conversation status " + status, err);
              if (_this3._services.syncClient.connectionState !== "disconnected") {
                throw err;
              }
            });
            return;
          }
          if (this._entityPromise) {
            this._unsubscribe().catch(function(err) {
              Conversation2._logger.debug("ERROR while setting conversation status " + status, err);
              if (_this3._services.syncClient.connectionState !== "disconnected") {
                throw err;
              }
            });
          }
        }
        /**
         * Update the local conversation object with new values.
         * @internal
         */
      }, {
        key: "_update",
        value: function _update(update) {
          var _update$lastMessage, _update$lastMessage2, _this$_internalState$4, _this$_internalState$5, _this$_internalState$6;
          Conversation2._logger.trace("_update", update);
          Conversation2.preprocessUpdate(update, this.sid);
          var updateReasons = /* @__PURE__ */ new Set();
          for (var _i = 0, _Object$keys = Object.keys(update); _i < _Object$keys.length; _i++) {
            var key = _Object$keys[_i];
            var localKey = fieldMappings[key];
            if (!localKey) {
              continue;
            }
            switch (localKey) {
              case fieldMappings.status:
                if (!update.status || update.status === "unknown" || this._internalState.status === update.status) {
                  break;
                }
                this._internalState.status = update.status;
                updateReasons.add(localKey);
                break;
              case fieldMappings.attributes:
                if (isEqual__default["default"](this._internalState.attributes, update.attributes)) {
                  break;
                }
                this._internalState.attributes = update.attributes;
                updateReasons.add(localKey);
                break;
              case fieldMappings.lastConsumedMessageIndex:
                if (update.lastConsumedMessageIndex === void 0 || update.lastConsumedMessageIndex === this._internalState.lastReadMessageIndex) {
                  break;
                }
                this._internalState.lastReadMessageIndex = update.lastConsumedMessageIndex;
                updateReasons.add("lastReadMessageIndex");
                break;
              case fieldMappings.lastMessage:
                if (this._internalState.lastMessage && !update.lastMessage) {
                  delete this._internalState.lastMessage;
                  updateReasons.add(localKey);
                  break;
                }
                this._internalState.lastMessage = this._internalState.lastMessage || {};
                if (((_update$lastMessage = update.lastMessage) === null || _update$lastMessage === void 0 ? void 0 : _update$lastMessage.index) !== void 0 && update.lastMessage.index !== this._internalState.lastMessage.index) {
                  this._internalState.lastMessage.index = update.lastMessage.index;
                  updateReasons.add(localKey);
                }
                if (((_update$lastMessage2 = update.lastMessage) === null || _update$lastMessage2 === void 0 ? void 0 : _update$lastMessage2.timestamp) !== void 0 && ((_this$_internalState$4 = this._internalState.lastMessage) === null || _this$_internalState$4 === void 0 ? void 0 : (_this$_internalState$5 = _this$_internalState$4.dateCreated) === null || _this$_internalState$5 === void 0 ? void 0 : _this$_internalState$5.getTime()) !== update.lastMessage.timestamp.getTime()) {
                  this._internalState.lastMessage.dateCreated = update.lastMessage.timestamp;
                  updateReasons.add(localKey);
                }
                if (isEqual__default["default"](this._internalState.lastMessage, {})) {
                  delete this._internalState.lastMessage;
                }
                break;
              case fieldMappings.state:
                var state = update.state || void 0;
                if (state !== void 0) {
                  state.dateUpdated = new Date(state.dateUpdated);
                }
                if (isEqual__default["default"](this._internalState.state, state)) {
                  break;
                }
                this._internalState.state = state;
                updateReasons.add(localKey);
                break;
              case fieldMappings.bindings:
                if (isEqual__default["default"](this._internalState.bindings, update.bindings)) {
                  break;
                }
                this._internalState.bindings = update.bindings;
                updateReasons.add(localKey);
                break;
              default:
                var isDate = update[key] instanceof Date;
                var keysMatchAsDates = isDate && ((_this$_internalState$6 = this._internalState[localKey]) === null || _this$_internalState$6 === void 0 ? void 0 : _this$_internalState$6.getTime()) === update[key].getTime();
                var keysMatchAsNonDates = !isDate && this[localKey] === update[key];
                if (keysMatchAsDates || keysMatchAsNonDates) {
                  break;
                }
                this._internalState[localKey] = update[key];
                updateReasons.add(localKey);
            }
          }
          if (updateReasons.size > 0) {
            this.emit(Conversation2.updated, {
              conversation: this,
              updateReasons: _toConsumableArray__default["default"](updateReasons)
            });
          }
        }
        /**
         * Handle onMessageAdded event.
         */
      }, {
        key: "_onMessageAdded",
        value: function _onMessageAdded(message) {
          var _iterator = _createForOfIteratorHelper$3(this._participants.values()), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var participant = _step.value;
              if (participant.identity === message.author) {
                participant._endTyping();
                break;
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          this.emit(Conversation2.messageAdded, message);
        }
        /**
         * Set last read message index.
         * @param index New index to set.
         */
      }, {
        key: "_setLastReadMessageIndex",
        value: function() {
          var _setLastReadMessageIndex2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee29(index) {
            var result;
            return _regeneratorRuntime__default["default"].wrap(function _callee29$(_context29) {
              while (1) {
                switch (_context29.prev = _context29.next) {
                  case 0:
                    _context29.next = 2;
                    return this._services.commandExecutor.mutateResource("post", "".concat(this._configuration.links.myConversations, "/").concat(this.sid), {
                      last_read_message_index: index
                    });
                  case 2:
                    result = _context29.sent;
                    return _context29.abrupt("return", result.unread_messages_count);
                  case 4:
                  case "end":
                    return _context29.stop();
                }
              }
            }, _callee29, this);
          }));
          function _setLastReadMessageIndex(_x20) {
            return _setLastReadMessageIndex2.apply(this, arguments);
          }
          return _setLastReadMessageIndex;
        }()
      }], [{
        key: "preprocessUpdate",
        value: function preprocessUpdate(update, conversationSid) {
          try {
            if (typeof update.attributes === "string") {
              update.attributes = JSON.parse(update.attributes);
            } else if (update.attributes) {
              JSON.stringify(update.attributes);
            }
          } catch (e) {
            Conversation2._logger.warn("Retrieved malformed attributes from the server for conversation: " + conversationSid);
            update.attributes = {};
          }
          try {
            if (update.dateCreated) {
              update.dateCreated = new Date(update.dateCreated);
            }
          } catch (e) {
            Conversation2._logger.warn("Retrieved malformed dateCreated from the server for conversation: " + conversationSid);
            delete update.dateCreated;
          }
          try {
            if (update.dateUpdated) {
              update.dateUpdated = new Date(update.dateUpdated);
            }
          } catch (e) {
            Conversation2._logger.warn("Retrieved malformed dateUpdated from the server for conversation: " + conversationSid);
            delete update.dateUpdated;
          }
          try {
            if (update.lastMessage && update.lastMessage.timestamp) {
              update.lastMessage.timestamp = new Date(update.lastMessage.timestamp);
            }
          } catch (e) {
            Conversation2._logger.warn("Retrieved malformed lastMessage.timestamp from the server for conversation: " + conversationSid);
            delete update.lastMessage.timestamp;
          }
        }
      }]);
      return Conversation2;
    }(replayEventEmitter.ReplayEventEmitter);
    _defineProperty__default["default"](Conversation, "participantJoined", "participantJoined");
    _defineProperty__default["default"](Conversation, "participantLeft", "participantLeft");
    _defineProperty__default["default"](Conversation, "participantUpdated", "participantUpdated");
    _defineProperty__default["default"](Conversation, "messageAdded", "messageAdded");
    _defineProperty__default["default"](Conversation, "messageRemoved", "messageRemoved");
    _defineProperty__default["default"](Conversation, "messageUpdated", "messageUpdated");
    _defineProperty__default["default"](Conversation, "typingEnded", "typingEnded");
    _defineProperty__default["default"](Conversation, "typingStarted", "typingStarted");
    _defineProperty__default["default"](Conversation, "updated", "updated");
    _defineProperty__default["default"](Conversation, "removed", "removed");
    _defineProperty__default["default"](Conversation, "_logger", Logger.scope("Conversation"));
    __decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString, optionalJson), __metadata("design:type", Function), __metadata("design:paramtypes", [String, Object]), __metadata("design:returntype", Promise)], Conversation.prototype, "add", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString, declarativeTypeValidator.nonEmptyString, optionalJson, optionalJson), __metadata("design:type", Function), __metadata("design:paramtypes", [String, String, Object, Object]), __metadata("design:returntype", Promise)], Conversation.prototype, "addNonChatParticipant", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger), __metadata("design:type", Function), __metadata("design:paramtypes", [Number]), __metadata("design:returntype", Promise)], Conversation.prototype, "advanceLastReadMessageIndex", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(["undefined", declarativeTypeValidator.nonNegativeInteger], ["undefined", declarativeTypeValidator.nonNegativeInteger], ["undefined", declarativeTypeValidator.literal("backwards", "forward")]), __metadata("design:type", Function), __metadata("design:paramtypes", [Number, Number, String]), __metadata("design:returntype", Promise)], Conversation.prototype, "getMessages", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", Promise)], Conversation.prototype, "getParticipantBySid", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", Promise)], Conversation.prototype, "getParticipantByIdentity", null);
    __decorate([declarativeTypeValidator.validateTypesAsync([declarativeTypeValidator.nonEmptyString, Participant]), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", Promise)], Conversation.prototype, "removeParticipant", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(["string", FormData, declarativeTypeValidator.literal(null), declarativeTypeValidator.objectSchema("media options", {
      contentType: declarativeTypeValidator.nonEmptyString,
      media: declarativeTypeValidator.custom(function(value) {
        var isValid = typeof value === "string" && value.length > 0 || value instanceof Uint8Array || value instanceof ArrayBuffer;
        if (typeof Blob === "function") {
          isValid = isValid || value instanceof Blob;
        }
        return [isValid, "a non-empty string, an instance of Buffer or an instance of Blob"];
      })
    })], optionalJson, ["undefined", declarativeTypeValidator.literal(null), declarativeTypeValidator.objectSchema("email attributes", {
      subject: [declarativeTypeValidator.nonEmptyString, "undefined"]
    })]), __metadata("design:type", Function), __metadata("design:paramtypes", [Object, Object, Object]), __metadata("design:returntype", Promise)], Conversation.prototype, "sendMessage", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.literal("default", "muted")), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", Promise)], Conversation.prototype, "setUserNotificationLevel", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(json), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", Promise)], Conversation.prototype, "updateAttributes", null);
    __decorate([declarativeTypeValidator.validateTypesAsync("string"), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", Promise)], Conversation.prototype, "updateFriendlyName", null);
    __decorate([declarativeTypeValidator.validateTypesAsync([declarativeTypeValidator.literal(null), declarativeTypeValidator.nonNegativeInteger]), __metadata("design:type", Function), __metadata("design:paramtypes", [Number]), __metadata("design:returntype", Promise)], Conversation.prototype, "updateLastReadMessageIndex", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(["string", declarativeTypeValidator.literal(null)]), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", Promise)], Conversation.prototype, "updateUniqueName", null);
    var Deferred = function() {
      function Deferred2() {
        var _this = this;
        _classCallCheck__default["default"](this, Deferred2);
        this._promise = new Promise(function(resolve, reject) {
          _this._resolve = resolve;
          _this._reject = reject;
        });
      }
      _createClass__default["default"](Deferred2, [{
        key: "promise",
        get: function get() {
          return this._promise;
        }
      }, {
        key: "update",
        value: function update(value) {
          this._resolve(value);
        }
      }, {
        key: "set",
        value: function set(value) {
          this.current = value;
          this._resolve(value);
        }
      }, {
        key: "fail",
        value: function fail(e) {
          this._reject(e);
        }
      }]);
      return Deferred2;
    }();
    function _createForOfIteratorHelper$2(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      } };
    }
    function _unsupportedIterableToArray$2(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray$2(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen);
    }
    function _arrayLikeToArray$2(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function ownKeys$2(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread$2(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys$2(Object(source), true).forEach(function(key) {
          _defineProperty__default["default"](target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _createSuper$3(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$3() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var log$1 = Logger.scope("Conversations");
    var Conversations = function(_ReplayEventEmitter) {
      _inherits__default["default"](Conversations2, _ReplayEventEmitter);
      var _super = _createSuper$3(Conversations2);
      function Conversations2(configuration, services) {
        var _this;
        _classCallCheck__default["default"](this, Conversations2);
        _this = _super.call(this);
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "conversations", /* @__PURE__ */ new Map());
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "myConversationsRead", new Deferred());
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "tombstones", /* @__PURE__ */ new Set());
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "myConversationsFetched", false);
        _this.configuration = configuration;
        _this.services = services;
        return _this;
      }
      _createClass__default["default"](Conversations2, [{
        key: "addConversation",
        value: function() {
          var _addConversation = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee(options) {
            var _response$sid, _response$sync_object, _response$sync_object2;
            var attributes, response, conversationSid, conversationDocument, links, existingConversation, conversation;
            return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    attributes = typeof (options === null || options === void 0 ? void 0 : options.attributes) !== "undefined" ? options.attributes : {};
                    _context.next = 3;
                    return this.services.commandExecutor.mutateResource("post", this.configuration.links.conversations, {
                      friendly_name: options.friendlyName,
                      unique_name: options.uniqueName,
                      access: options.access,
                      attributes: typeof attributes !== "undefined" ? JSON.stringify(attributes) : void 0
                    });
                  case 3:
                    response = _context.sent;
                    conversationSid = (_response$sid = response.sid) !== null && _response$sid !== void 0 ? _response$sid : null;
                    conversationDocument = (_response$sync_object = (_response$sync_object2 = response.sync_objects) === null || _response$sync_object2 === void 0 ? void 0 : _response$sync_object2.conversation) !== null && _response$sync_object !== void 0 ? _response$sync_object : null;
                    links = _objectSpread$2({
                      self: response.url
                    }, response.links);
                    existingConversation = this.conversations.get(conversationSid);
                    if (!existingConversation) {
                      _context.next = 12;
                      break;
                    }
                    _context.next = 11;
                    return existingConversation._subscribe();
                  case 11:
                    return _context.abrupt("return", existingConversation);
                  case 12:
                    conversation = new Conversation({
                      channel: conversationDocument,
                      entityName: "",
                      uniqueName: "",
                      attributes: null,
                      createdBy: "",
                      friendlyName: "",
                      lastConsumedMessageIndex: 0,
                      dateCreated: null,
                      dateUpdated: null
                    }, conversationSid, links, this.configuration, this.services);
                    this.conversations.set(conversation.sid, conversation);
                    this._registerForEvents(conversation);
                    _context.next = 17;
                    return conversation._subscribe();
                  case 17:
                    this.emit("conversationAdded", conversation);
                    return _context.abrupt("return", conversation);
                  case 19:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function addConversation(_x) {
            return _addConversation.apply(this, arguments);
          }
          return addConversation;
        }()
        /**
         * Fetch conversations' list and instantiate all necessary objects
         */
      }, {
        key: "fetchConversations",
        value: function() {
          var _fetchConversations = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee2() {
            var _this2 = this;
            var map, myConversations, upserts, _iterator, _step, conversation, errorMessage;
            return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.prev = 0;
                    _context2.next = 3;
                    return this._getMap();
                  case 3:
                    map = _context2.sent;
                    map.on(twilioSync.SyncMap.itemAdded, function(args) {
                      log$1.debug("itemAdded: ".concat(args.item.key));
                      _this2._upsertConversation("sync", args.item.key, args.item.data);
                    });
                    map.on(twilioSync.SyncMap.itemRemoved, function(args) {
                      log$1.debug("itemRemoved: ".concat(args.key));
                      var sid = args.key;
                      if (!_this2.myConversationsFetched) {
                        _this2.tombstones.add(sid);
                      }
                      var conversation2 = _this2.conversations.get(sid);
                      if (!conversation2) {
                        return;
                      }
                      if (conversation2.status === "joined") {
                        conversation2._setStatus("notParticipating", "sync");
                        _this2.emit("conversationLeft", conversation2);
                      }
                      _this2.conversations.delete(sid);
                      _this2.emit("conversationRemoved", conversation2);
                      conversation2.emit("removed", conversation2);
                    });
                    map.on(twilioSync.SyncMap.itemUpdated, function(args) {
                      log$1.debug("itemUpdated: ".concat(args.item.key));
                      _this2._upsertConversation("sync", args.item.key, args.item.data);
                    });
                    _context2.next = 9;
                    return this._fetchMyConversations();
                  case 9:
                    myConversations = _context2.sent;
                    upserts = [];
                    _iterator = _createForOfIteratorHelper$2(myConversations);
                    try {
                      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                        conversation = _step.value;
                        upserts.push(this._upsertConversation("rest", conversation["channel_sid"], conversation));
                      }
                    } catch (err) {
                      _iterator.e(err);
                    } finally {
                      _iterator.f();
                    }
                    this.myConversationsRead.set(true);
                    _context2.next = 16;
                    return Promise.all(upserts);
                  case 16:
                    this.myConversationsFetched = true;
                    this.tombstones.clear();
                    log$1.debug("The conversations list has been successfully fetched");
                    return _context2.abrupt("return", this);
                  case 22:
                    _context2.prev = 22;
                    _context2.t0 = _context2["catch"](0);
                    errorMessage = "Failed to fetch the conversations list";
                    if (this.services.syncClient.connectionState !== "disconnected") {
                      log$1.error(errorMessage, _context2.t0);
                    }
                    log$1.debug("ERROR: ".concat(errorMessage), _context2.t0);
                    throw _context2.t0;
                  case 28:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this, [[0, 22]]);
          }));
          function fetchConversations() {
            return _fetchConversations.apply(this, arguments);
          }
          return fetchConversations;
        }()
      }, {
        key: "getConversations",
        value: function() {
          var _getConversations = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee3() {
            var _this3 = this;
            var conversationsMap, page;
            return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    _context3.next = 2;
                    return this._getMap();
                  case 2:
                    conversationsMap = _context3.sent;
                    _context3.next = 5;
                    return conversationsMap.getItems();
                  case 5:
                    page = _context3.sent;
                    return _context3.abrupt("return", this._wrapPaginator(page, function(items) {
                      return Promise.all(items.map(function(item) {
                        return _this3._upsertConversation("sync", item.key, item.data);
                      }));
                    }));
                  case 7:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));
          function getConversations() {
            return _getConversations.apply(this, arguments);
          }
          return getConversations;
        }()
      }, {
        key: "getConversation",
        value: function() {
          var _getConversation = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee4(sid) {
            var _this4 = this;
            var conversationsMap, page, items;
            return _regeneratorRuntime__default["default"].wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    _context4.next = 2;
                    return this._getMap();
                  case 2:
                    conversationsMap = _context4.sent;
                    _context4.next = 5;
                    return conversationsMap.getItems({
                      key: sid
                    });
                  case 5:
                    page = _context4.sent;
                    items = page.items.map(function(item) {
                      return _this4._upsertConversation("sync", item.key, item.data);
                    });
                    return _context4.abrupt("return", items.length > 0 ? items[0] : null);
                  case 8:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));
          function getConversation(_x2) {
            return _getConversation.apply(this, arguments);
          }
          return getConversation;
        }()
      }, {
        key: "getConversationByUniqueName",
        value: function() {
          var _getConversationByUniqueName = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee5(uniqueName) {
            var url, response, body, sid, data;
            return _regeneratorRuntime__default["default"].wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    url = new UriBuilder(this.configuration.links.myConversations).path(uniqueName).build();
                    _context5.next = 3;
                    return this.services.network.get(url);
                  case 3:
                    response = _context5.sent;
                    body = response.body;
                    sid = body.conversation_sid;
                    data = {
                      entityName: null,
                      lastConsumedMessageIndex: body.last_read_message_index,
                      status: (body === null || body === void 0 ? void 0 : body.status) || "unknown",
                      friendlyName: body.friendly_name,
                      dateUpdated: body.date_updated,
                      dateCreated: body.date_created,
                      uniqueName: body.unique_name,
                      createdBy: body.created_by,
                      attributes: body.attributes,
                      channel: body.sync_objects.conversation,
                      roster: body.sync_objects.participants,
                      messages: body.sync_objects.messages,
                      notificationLevel: body === null || body === void 0 ? void 0 : body.notification_level,
                      sid
                    };
                    return _context5.abrupt("return", sid ? this._upsertConversation("sync", sid, data) : null);
                  case 8:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));
          function getConversationByUniqueName(_x3) {
            return _getConversationByUniqueName.apply(this, arguments);
          }
          return getConversationByUniqueName;
        }()
      }, {
        key: "peekConversation",
        value: function() {
          var _peekConversation = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee6(sid) {
            var url, response, body, data;
            return _regeneratorRuntime__default["default"].wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    url = new UriBuilder(this.configuration.links.conversations).path(sid).build();
                    _context6.next = 3;
                    return this.services.network.get(url);
                  case 3:
                    response = _context6.sent;
                    body = response.body;
                    data = {
                      entityName: null,
                      // lastConsumedMessageIndex: body.last_read_message_index,
                      status: (body === null || body === void 0 ? void 0 : body.status) || "unknown",
                      friendlyName: body.friendly_name,
                      dateUpdated: body.date_updated,
                      dateCreated: body.date_created,
                      uniqueName: body.unique_name,
                      createdBy: body.created_by,
                      attributes: body.attributes,
                      channel: body.sync_objects.conversation || "".concat(sid, ".channel"),
                      roster: body.sync_objects.participants,
                      messages: body.sync_objects.messages,
                      notificationLevel: body === null || body === void 0 ? void 0 : body.notification_level,
                      sid
                    };
                    return _context6.abrupt("return", this._upsertConversation("sync", sid, data));
                  case 7:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, this);
          }));
          function peekConversation(_x4) {
            return _peekConversation.apply(this, arguments);
          }
          return peekConversation;
        }()
      }, {
        key: "_getMap",
        value: function() {
          var _getMap2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee7() {
            return _regeneratorRuntime__default["default"].wrap(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    _context7.next = 2;
                    return this.services.syncClient.map({
                      id: this.configuration.myConversations,
                      mode: "open_existing"
                    });
                  case 2:
                    return _context7.abrupt("return", _context7.sent);
                  case 3:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee7, this);
          }));
          function _getMap() {
            return _getMap2.apply(this, arguments);
          }
          return _getMap;
        }()
      }, {
        key: "_wrapPaginator",
        value: function() {
          var _wrapPaginator2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee8(page, op) {
            var _this5 = this;
            var items;
            return _regeneratorRuntime__default["default"].wrap(function _callee8$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    _context8.next = 2;
                    return op(page.items);
                  case 2:
                    items = _context8.sent;
                    return _context8.abrupt("return", {
                      items: items.filter(function(item) {
                        return item !== null;
                      }),
                      hasNextPage: page.hasNextPage,
                      hasPrevPage: page.hasPrevPage,
                      nextPage: function nextPage() {
                        return page.nextPage().then(function(x) {
                          return _this5._wrapPaginator(x, op);
                        });
                      },
                      prevPage: function prevPage() {
                        return page.prevPage().then(function(x) {
                          return _this5._wrapPaginator(x, op);
                        });
                      }
                    });
                  case 4:
                  case "end":
                    return _context8.stop();
                }
              }
            }, _callee8);
          }));
          function _wrapPaginator(_x5, _x6) {
            return _wrapPaginator2.apply(this, arguments);
          }
          return _wrapPaginator;
        }()
      }, {
        key: "_updateConversation",
        value: function() {
          var _updateConversation2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee9(source, conversation, data) {
            var areSourcesDifferent, isChannelSourceSync, updateData;
            return _regeneratorRuntime__default["default"].wrap(function _callee9$(_context9) {
              while (1) {
                switch (_context9.prev = _context9.next) {
                  case 0:
                    areSourcesDifferent = conversation._statusSource !== void 0 && source !== conversation._statusSource;
                    isChannelSourceSync = source !== "rest" || conversation._statusSource === "sync";
                    if (!(areSourcesDifferent && isChannelSourceSync && source !== "sync")) {
                      _context9.next = 5;
                      break;
                    }
                    log$1.trace("upsertConversation: conversation is known from sync and came from REST, ignoring", {
                      sid: conversation.sid,
                      data: data.status,
                      conversation: conversation.status
                    });
                    return _context9.abrupt("return");
                  case 5:
                    if (!(data.status === "joined" && conversation.status !== "joined")) {
                      _context9.next = 15;
                      break;
                    }
                    conversation._setStatus("joined", source);
                    updateData = {};
                    if (typeof data.notificationLevel !== "undefined") {
                      updateData.notificationLevel = data.notificationLevel;
                    }
                    if (typeof data.lastConsumedMessageIndex !== "undefined") {
                      updateData.lastConsumedMessageIndex = data.lastConsumedMessageIndex;
                    }
                    if (!isEqual__default["default"](updateData, {})) {
                      conversation._update(updateData);
                    }
                    _context9.next = 13;
                    return conversation._subscribe();
                  case 13:
                    this.emit("conversationJoined", conversation);
                    return _context9.abrupt("return");
                  case 15:
                    if (!(data.status === "notParticipating" && conversation.status === "joined")) {
                      _context9.next = 22;
                      break;
                    }
                    conversation._setStatus("notParticipating", source);
                    conversation._update(data);
                    _context9.next = 20;
                    return conversation._subscribe();
                  case 20:
                    this.emit("conversationLeft", conversation);
                    return _context9.abrupt("return");
                  case 22:
                    if (!(data.status === "notParticipating")) {
                      _context9.next = 26;
                      break;
                    }
                    _context9.next = 25;
                    return conversation._subscribe();
                  case 25:
                    return _context9.abrupt("return");
                  case 26:
                    conversation._update(data);
                  case 27:
                  case "end":
                    return _context9.stop();
                }
              }
            }, _callee9, this);
          }));
          function _updateConversation(_x7, _x8, _x9) {
            return _updateConversation2.apply(this, arguments);
          }
          return _updateConversation;
        }()
      }, {
        key: "_upsertConversation",
        value: function() {
          var _upsertConversation2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee10(source, sid, data) {
            var conversation, baseLink, links, newConversation;
            return _regeneratorRuntime__default["default"].wrap(function _callee10$(_context10) {
              while (1) {
                switch (_context10.prev = _context10.next) {
                  case 0:
                    log$1.trace("upsertConversation called for ".concat(sid), data);
                    conversation = this.conversations.get(sid);
                    if (!conversation) {
                      _context10.next = 9;
                      break;
                    }
                    log$1.trace("upsertConversation: the conversation ".concat(conversation.sid, " is known;") + "its status is known from the source ".concat(conversation._statusSource, " ") + "and the update came from the source ".concat(source), conversation);
                    _context10.next = 6;
                    return this._updateConversation(source, conversation, data);
                  case 6:
                    _context10.next = 8;
                    return conversation._subscribe();
                  case 8:
                    return _context10.abrupt("return", conversation);
                  case 9:
                    if (!(source === "rest" && this.tombstones.has(sid))) {
                      _context10.next = 12;
                      break;
                    }
                    log$1.trace("upsertChannel: the conversation is deleted but reappeared again from REST, ignoring", sid);
                    return _context10.abrupt("return", null);
                  case 12:
                    log$1.trace("upsertConversation: creating a local conversation object with sid " + sid, data);
                    baseLink = "".concat(this.configuration.links.conversations, "/").concat(sid);
                    links = {
                      self: baseLink,
                      messages: "".concat(baseLink, "/Messages"),
                      participants: "".concat(baseLink, "/Participants")
                    };
                    newConversation = new Conversation(data, sid, links, this.configuration, this.services);
                    this.conversations.set(sid, newConversation);
                    _context10.prev = 17;
                    _context10.next = 20;
                    return newConversation._subscribe();
                  case 20:
                    if (!(data.status === "joined")) {
                      _context10.next = 23;
                      break;
                    }
                    _context10.next = 23;
                    return newConversation._fetchStreams();
                  case 23:
                    _context10.next = 32;
                    break;
                  case 25:
                    _context10.prev = 25;
                    _context10.t0 = _context10["catch"](17);
                    if (!(_context10.t0.name !== "SyncError")) {
                      _context10.next = 29;
                      break;
                    }
                    throw _context10.t0;
                  case 29:
                    log$1.trace("upsertChannel: the conversation is missing some Sync entity(ies), ignoring", sid, _context10.t0);
                    this.conversations.delete(sid);
                    return _context10.abrupt("return", null);
                  case 32:
                    this._registerForEvents(newConversation);
                    this.emit("conversationAdded", newConversation);
                    if (data.status === "joined") {
                      newConversation._setStatus("joined", source);
                      this.emit("conversationJoined", newConversation);
                    }
                    return _context10.abrupt("return", newConversation);
                  case 36:
                  case "end":
                    return _context10.stop();
                }
              }
            }, _callee10, this, [[17, 25]]);
          }));
          function _upsertConversation(_x10, _x11, _x12) {
            return _upsertConversation2.apply(this, arguments);
          }
          return _upsertConversation;
        }()
      }, {
        key: "_fetchMyConversations",
        value: function() {
          var _fetchMyConversations2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee11() {
            var conversations, pageToken, _response$body, url, response, receivedConversations;
            return _regeneratorRuntime__default["default"].wrap(function _callee11$(_context11) {
              while (1) {
                switch (_context11.prev = _context11.next) {
                  case 0:
                    conversations = [];
                    pageToken = null;
                  case 2:
                    url = new UriBuilder(this.configuration.links.myConversations);
                    if (pageToken) {
                      url.arg("PageToken", pageToken);
                    }
                    _context11.next = 6;
                    return this.services.network.get(url.build());
                  case 6:
                    response = _context11.sent;
                    receivedConversations = (_response$body = response.body) === null || _response$body === void 0 ? void 0 : _response$body.conversations.map(function(conversationDescriptor) {
                      return {
                        descriptor: conversationDescriptor,
                        channel_sid: conversationDescriptor.conversation_sid,
                        status: conversationDescriptor.status,
                        channel: conversationDescriptor.sync_objects.conversation,
                        messages: conversationDescriptor.sync_objects.messages,
                        roster: conversationDescriptor.sync_objects.participants || "".concat(conversationDescriptor.conversation_sid, ".roster"),
                        lastConsumedMessageIndex: conversationDescriptor.last_read_message_index,
                        notificationLevel: conversationDescriptor.notification_level
                      };
                    });
                    pageToken = response.body.meta.next_token;
                    conversations = [].concat(_toConsumableArray__default["default"](conversations), _toConsumableArray__default["default"](receivedConversations));
                  case 10:
                    if (pageToken) {
                      _context11.next = 2;
                      break;
                    }
                  case 11:
                    return _context11.abrupt("return", conversations);
                  case 12:
                  case "end":
                    return _context11.stop();
                }
              }
            }, _callee11, this);
          }));
          function _fetchMyConversations() {
            return _fetchMyConversations2.apply(this, arguments);
          }
          return _fetchMyConversations;
        }()
      }, {
        key: "_onConversationRemoved",
        value: function _onConversationRemoved(sid) {
          var conversation = this.conversations.get(sid);
          if (conversation) {
            this.conversations.delete(sid);
            this.emit("conversationRemoved", conversation);
          }
        }
      }, {
        key: "_registerForEvents",
        value: function _registerForEvents(conversation) {
          var _this6 = this;
          conversation.on("removed", function() {
            return _this6._onConversationRemoved(conversation.sid);
          });
          conversation.on("updated", function(args) {
            return _this6.emit("conversationUpdated", args);
          });
          conversation.on("participantJoined", function(participant) {
            return _this6.emit("participantJoined", participant);
          });
          conversation.on("participantLeft", function(participant) {
            return _this6.emit("participantLeft", participant);
          });
          conversation.on("participantUpdated", function(args) {
            return _this6.emit("participantUpdated", args);
          });
          conversation.on("messageAdded", function(message) {
            return _this6.emit("messageAdded", message);
          });
          conversation.on("messageUpdated", function(args) {
            return _this6.emit("messageUpdated", args);
          });
          conversation.on("messageRemoved", function(message) {
            return _this6.emit("messageRemoved", message);
          });
          conversation.on("typingStarted", function(participant) {
            return _this6.emit("typingStarted", participant);
          });
          conversation.on("typingEnded", function(participant) {
            return _this6.emit("typingEnded", participant);
          });
        }
      }]);
      return Conversations2;
    }(replayEventEmitter.ReplayEventEmitter);
    function _createSuper$2(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$2() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var Users = function(_ReplayEventEmitter) {
      _inherits__default["default"](Users2, _ReplayEventEmitter);
      var _super = _createSuper$2(Users2);
      function Users2(myself, configuration, services) {
        var _this;
        _classCallCheck__default["default"](this, Users2);
        _this = _super.call(this);
        _this.configuration = configuration;
        _this.services = services;
        _this.fifoStack = [];
        _this.myself = myself;
        _this.myself.on("updated", function(args) {
          return _this.emit("userUpdated", args);
        });
        _this.myself.on("userSubscribed", function() {
          return _this.emit("userSubscribed", _this.myself);
        });
        _this.myself.on("userUnsubscribed", function() {
          _this.emit("userUnsubscribed", _this.myself);
          _this.myself._ensureFetched();
        });
        _this.subscribedUsers = /* @__PURE__ */ new Map();
        return _this;
      }
      _createClass__default["default"](Users2, [{
        key: "handleUnsubscribeUser",
        value: function handleUnsubscribeUser(user) {
          if (this.subscribedUsers.has(user.identity)) {
            this.subscribedUsers.delete(user.identity);
          }
          var foundItemIndex = 0;
          var foundItem = this.fifoStack.find(function(item, index) {
            if (item == user.identity) {
              foundItemIndex = index;
              return true;
            }
            return false;
          });
          if (foundItem) {
            this.fifoStack.splice(foundItemIndex, 1);
          }
          this.emit("userUnsubscribed", user);
        }
      }, {
        key: "handleSubscribeUser",
        value: function handleSubscribeUser(user) {
          if (this.subscribedUsers.has(user.identity)) {
            return;
          }
          if (this.fifoStack.length >= this.configuration.userInfosToSubscribe) {
            var _this$subscribedUsers, _this$subscribedUsers2;
            var item = this.fifoStack.shift();
            (_this$subscribedUsers = this.subscribedUsers) === null || _this$subscribedUsers === void 0 ? void 0 : (_this$subscribedUsers2 = _this$subscribedUsers.get(item)) === null || _this$subscribedUsers2 === void 0 ? void 0 : _this$subscribedUsers2.unsubscribe();
          }
          this.fifoStack.push(user.identity);
          this.subscribedUsers.set(user.identity, user);
          this.emit("userSubscribed", user);
        }
        /**
         * Gets user, if it's in subscribed list - then return the user object from it,
         * if not - then subscribes and adds user to the FIFO stack
         * @returns {Promise<User>} Fully initialized user
         */
      }, {
        key: "getUser",
        value: function() {
          var _getUser = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee(identity, entityName) {
            var _entityName, _this2 = this;
            var user, newUser;
            return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return this.myself._ensureFetched();
                  case 2:
                    if (!(identity == this.myself.identity)) {
                      _context.next = 4;
                      break;
                    }
                    return _context.abrupt("return", this.myself);
                  case 4:
                    user = this.subscribedUsers.get(identity);
                    if (!user) {
                      _context.next = 7;
                      break;
                    }
                    return _context.abrupt("return", user);
                  case 7:
                    if (!((_entityName = entityName) !== null && _entityName !== void 0)) {
                      _context.next = 11;
                      break;
                    }
                    _context.next = 14;
                    break;
                  case 11:
                    _context.next = 13;
                    return this.getSyncUniqueName(identity);
                  case 13:
                    entityName = _context.sent;
                  case 14:
                    newUser = new User(identity, entityName, this.configuration, this.services);
                    newUser.on("updated", function(args) {
                      return _this2.emit("userUpdated", args);
                    });
                    newUser.on("userSubscribed", function() {
                      return _this2.handleSubscribeUser(newUser);
                    });
                    newUser.on("userUnsubscribed", function() {
                      return _this2.handleUnsubscribeUser(newUser);
                    });
                    _context.next = 20;
                    return newUser._ensureFetched();
                  case 20:
                    return _context.abrupt("return", newUser);
                  case 21:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function getUser(_x, _x2) {
            return _getUser.apply(this, arguments);
          }
          return getUser;
        }()
        /**
         * @returns {Promise<Array<User>>} returns list of subscribed User objects {@see User}
         */
      }, {
        key: "getSubscribedUsers",
        value: function() {
          var _getSubscribedUsers = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee2() {
            var users;
            return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.next = 2;
                    return this.myself._ensureFetched();
                  case 2:
                    users = [this.myself];
                    this.subscribedUsers.forEach(function(user) {
                      return users.push(user);
                    });
                    return _context2.abrupt("return", users);
                  case 5:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function getSubscribedUsers() {
            return _getSubscribedUsers.apply(this, arguments);
          }
          return getSubscribedUsers;
        }()
        /**
         * @returns {Promise<string>} User's sync unique name
         */
      }, {
        key: "getSyncUniqueName",
        value: function() {
          var _getSyncUniqueName = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee3(identity) {
            var _response$body$sync_o, _response$body;
            var url, response;
            return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    url = new UriBuilder(this.configuration.links.users).path(identity).build();
                    _context3.next = 3;
                    return this.services.network.get(url);
                  case 3:
                    response = _context3.sent;
                    return _context3.abrupt("return", (_response$body$sync_o = (_response$body = response.body) === null || _response$body === void 0 ? void 0 : _response$body.sync_objects.user_info_map) !== null && _response$body$sync_o !== void 0 ? _response$body$sync_o : "");
                  case 5:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));
          function getSyncUniqueName(_x3) {
            return _getSyncUniqueName.apply(this, arguments);
          }
          return getSyncUniqueName;
        }()
      }]);
      return Users2;
    }(replayEventEmitter.ReplayEventEmitter);
    var log = Logger.scope("TypingIndicator");
    var TypingIndicator = function() {
      function TypingIndicator2(getConversation, config, services) {
        _classCallCheck__default["default"](this, TypingIndicator2);
        this.configuration = config;
        this.services = services;
        this.getConversation = getConversation;
        this.serviceTypingTimeout = null;
        this.sentUpdates = /* @__PURE__ */ new Map();
      }
      _createClass__default["default"](TypingIndicator2, [{
        key: "typingTimeout",
        get: function get() {
          return this.configuration.typingIndicatorTimeoutOverride || this.serviceTypingTimeout || this.configuration.typingIndicatorTimeoutDefault;
        }
        /**
         * Initialize TypingIndicator controller
         * Registers for needed message types and sets listeners
         * @private
         */
      }, {
        key: "initialize",
        value: function initialize() {
          var _this = this;
          this.services.notificationClient.on("message", function() {
            var _ref = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee(type, message) {
              return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      if (!(type === NotificationTypes.TYPING_INDICATOR)) {
                        _context.next = 3;
                        break;
                      }
                      _context.next = 3;
                      return _this._handleRemoteTyping(message);
                    case 3:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee);
            }));
            return function(_x, _x2) {
              return _ref.apply(this, arguments);
            };
          }());
        }
        /**
         * Remote participants typing events handler
         */
      }, {
        key: "_handleRemoteTyping",
        value: function() {
          var _handleRemoteTyping2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee2(message) {
            var _this2 = this;
            return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    log.trace("Got new typing indicator ", message);
                    this.getConversation(message.channel_sid).then(function(conversation) {
                      if (!conversation) {
                        return;
                      }
                      conversation._participants.forEach(function(participant) {
                        if (participant.identity !== message.identity && participant.type !== "apple") {
                          return;
                        }
                        var timeout = _this2.configuration.typingIndicatorTimeoutOverride ? _this2.configuration.typingIndicatorTimeoutOverride + 1e3 : message.typing_timeout * 1e3;
                        participant._startTyping(timeout);
                      });
                    }).catch(function(err) {
                      log.error(err);
                      throw err;
                    });
                  case 2:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function _handleRemoteTyping(_x3) {
            return _handleRemoteTyping2.apply(this, arguments);
          }
          return _handleRemoteTyping;
        }()
        /**
         * Send typing event for the given conversation sid
         * @param {String} conversationSid
         */
      }, {
        key: "send",
        value: function send(conversationSid) {
          var lastUpdate = this.sentUpdates.get(conversationSid);
          if (lastUpdate && lastUpdate > Date.now() - this.typingTimeout) {
            return Promise.resolve();
          }
          this.sentUpdates.set(conversationSid, Date.now());
          return this._send(conversationSid);
        }
      }, {
        key: "_send",
        value: function _send(conversationSid) {
          var _this3 = this;
          log.trace("Sending typing indicator");
          var url = this.configuration.links.typing;
          var headers = {
            "Content-Type": "application/x-www-form-urlencoded"
          };
          var body = "ChannelSid=".concat(conversationSid);
          return this.services.twilsockClient.post(url, headers, body, this.configuration.productId).then(function(response) {
            if (response.body.hasOwnProperty("typing_timeout")) {
              _this3.serviceTypingTimeout = response.body.typing_timeout * 1e3;
            }
          }).catch(function(err) {
            log.error("Failed to send typing indicator:", err);
            throw err;
          });
        }
      }]);
      return TypingIndicator2;
    }();
    var PushNotification = _createClass__default["default"](
      /**
       * Title of the notification.
       */
      /**
       * Text of the notification.
       */
      /**
       * Sound of the notification.
       */
      /**
       * Number of the badge.
       */
      /**
       * Notification action (`click_action` in FCM terms and `category` in APN terms).
       */
      /**
       * Type of the notification.
       */
      /**
       * Additional data of the conversation.
       */
      /**
       * @internal
       */
      function PushNotification2(data) {
        _classCallCheck__default["default"](this, PushNotification2);
        this.title = data.title || null;
        this.body = data.body || null;
        this.sound = data.sound || null;
        this.badge = data.badge || null;
        this.action = data.action || null;
        this.type = data.type || null;
        this.data = data.data || {};
      }
    );
    var version = "2.6.2";
    function ownKeys$1(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread$1(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys$1(Object(source), true).forEach(function(key) {
          _defineProperty__default["default"](target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _createSuper$1(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct$1() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var trimSlashes = function trimSlashes2(url) {
      return url.replace(/(^\/+|\/+$)/g, "");
    };
    var isMutationConflictResponse = function isMutationConflictResponse2(response) {
      return response.status.code === 202;
    };
    var ChannelMetadataNotFoundError = function(_Error) {
      _inherits__default["default"](ChannelMetadataNotFoundError2, _Error);
      var _super = _createSuper$1(ChannelMetadataNotFoundError2);
      function ChannelMetadataNotFoundError2(message) {
        _classCallCheck__default["default"](this, ChannelMetadataNotFoundError2);
        return _super.call(this, message);
      }
      return _createClass__default["default"](ChannelMetadataNotFoundError2);
    }(_wrapNativeSuper__default["default"](Error));
    var CommandExecutor = function() {
      function CommandExecutor2(_serviceUrl, _services, _productId) {
        _classCallCheck__default["default"](this, CommandExecutor2);
        this._serviceUrl = _serviceUrl;
        this._services = _services;
        this._productId = _productId;
      }
      _createClass__default["default"](CommandExecutor2, [{
        key: "_preProcessUrl",
        value: function _preProcessUrl(url) {
          var trimmedUrl = trimSlashes(url);
          if (/^https?:\/\//.test(url)) {
            return trimmedUrl;
          }
          return "".concat(trimSlashes(this._serviceUrl), "/").concat(trimmedUrl);
        }
      }, {
        key: "_makeRequest",
        value: function() {
          var _makeRequest2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee(method, url, requestBody, headers) {
            var preProcessedUrl, finalHeaders, response, getUrl;
            return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    preProcessedUrl = this._preProcessUrl(url);
                    finalHeaders = _objectSpread$1({
                      "Content-Type": "application/json; charset=utf-8"
                    }, headers || {});
                    _context.t0 = method;
                    _context.next = _context.t0 === "get" ? 5 : _context.t0 === "post" ? 11 : _context.t0 === "delete" ? 15 : 19;
                    break;
                  case 5:
                    getUrl = preProcessedUrl;
                    if (requestBody) {
                      getUrl += "?" + Object.entries(requestBody).map(function(entry) {
                        return entry.map(encodeURIComponent).join("=");
                      }).join("&");
                    }
                    _context.next = 9;
                    return this._services.transport.get(getUrl, finalHeaders, this._productId);
                  case 9:
                    response = _context.sent;
                    return _context.abrupt("break", 19);
                  case 11:
                    _context.next = 13;
                    return this._services.transport.post(preProcessedUrl, finalHeaders, JSON.stringify(requestBody), this._productId);
                  case 13:
                    response = _context.sent;
                    return _context.abrupt("break", 19);
                  case 15:
                    _context.next = 17;
                    return this._services.transport.delete(preProcessedUrl, finalHeaders, {}, this._productId);
                  case 17:
                    response = _context.sent;
                    return _context.abrupt("break", 19);
                  case 19:
                    if (!(response.status.code < 200 || response.status.code >= 300)) {
                      _context.next = 21;
                      break;
                    }
                    throw new Error("Request responded with a non-success code ".concat(response.status.code));
                  case 21:
                    return _context.abrupt("return", response);
                  case 22:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function _makeRequest(_x, _x2, _x3, _x4) {
            return _makeRequest2.apply(this, arguments);
          }
          return _makeRequest;
        }()
      }, {
        key: "fetchResource",
        value: function() {
          var _fetchResource = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee3(url, requestBody) {
            var _this = this;
            var maxAttemptsCount, retrier, resolution;
            return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    maxAttemptsCount = 6;
                    retrier = new operationRetrier.AsyncRetrier({
                      min: 50,
                      max: 1600,
                      maxAttemptsCount
                    });
                    _context3.prev = 2;
                    _context3.next = 5;
                    return retrier.run(_asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee2() {
                      var response, _e$body, _e$body2;
                      return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
                        while (1) {
                          switch (_context2.prev = _context2.next) {
                            case 0:
                              _context2.prev = 0;
                              _context2.next = 3;
                              return _this._makeRequest("get", url, requestBody);
                            case 3:
                              response = _context2.sent;
                              return _context2.abrupt("return", {
                                type: "success",
                                data: response.body
                              });
                            case 7:
                              _context2.prev = 7;
                              _context2.t0 = _context2["catch"](0);
                              if (!((_context2.t0 === null || _context2.t0 === void 0 ? void 0 : (_e$body = _context2.t0.body) === null || _e$body === void 0 ? void 0 : _e$body.status) === 404 && (_context2.t0 === null || _context2.t0 === void 0 ? void 0 : (_e$body2 = _context2.t0.body) === null || _e$body2 === void 0 ? void 0 : _e$body2.code) === 50530)) {
                                _context2.next = 11;
                                break;
                              }
                              return _context2.abrupt("return", {
                                type: "noMetadata"
                              });
                            case 11:
                              throw _context2.t0;
                            case 12:
                            case "end":
                              return _context2.stop();
                          }
                        }
                      }, _callee2, null, [[0, 7]]);
                    })));
                  case 5:
                    resolution = _context3.sent;
                    _context3.next = 11;
                    break;
                  case 8:
                    _context3.prev = 8;
                    _context3.t0 = _context3["catch"](2);
                    throw new Error('Fetch resource from "'.concat(url, '" failed.'));
                  case 11:
                    if (!(resolution.type === "noMetadata")) {
                      _context3.next = 13;
                      break;
                    }
                    throw new ChannelMetadataNotFoundError("No metadata found.");
                  case 13:
                    return _context3.abrupt("return", resolution.data);
                  case 14:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, null, [[2, 8]]);
          }));
          function fetchResource(_x5, _x6) {
            return _fetchResource.apply(this, arguments);
          }
          return fetchResource;
        }()
      }, {
        key: "mutateResource",
        value: function() {
          var _mutateResource = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee4(method, url, requestBody) {
            var result;
            return _regeneratorRuntime__default["default"].wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    _context4.next = 2;
                    return this._makeRequest(method, url, requestBody, {
                      "X-Twilio-Mutation-Id": uuid.v4()
                    });
                  case 2:
                    result = _context4.sent;
                    if (!isMutationConflictResponse(result)) {
                      _context4.next = 7;
                      break;
                    }
                    _context4.next = 6;
                    return this.fetchResource(result.body.resource_url);
                  case 6:
                    return _context4.abrupt("return", _context4.sent);
                  case 7:
                    return _context4.abrupt("return", result.body);
                  case 8:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));
          function mutateResource(_x7, _x8, _x9) {
            return _mutateResource.apply(this, arguments);
          }
          return mutateResource;
        }()
      }]);
      return CommandExecutor2;
    }();
    var ContentClient = function() {
      function ContentClient2(_services) {
        var _pageSize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 100;
        var _cacheTtlMs = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 5e3;
        _classCallCheck__default["default"](this, ContentClient2);
        _defineProperty__default["default"](this, "_cachedTemplates", null);
        this._services = _services;
        this._pageSize = _pageSize;
        this._cacheTtlMs = _cacheTtlMs;
      }
      _createClass__default["default"](ContentClient2, [{
        key: "getContentTemplates",
        value: function() {
          var _getContentTemplates = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee() {
            var _this = this;
            var _yield$this$_fetchCon, _yield$this$_fetchCon2, templatesPage, nextToken, templates, _yield$this$_fetchCon3, _yield$this$_fetchCon4;
            return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (!(this._cachedTemplates !== null)) {
                      _context.next = 2;
                      break;
                    }
                    return _context.abrupt("return", this._cachedTemplates);
                  case 2:
                    _context.next = 4;
                    return this._fetchContentTemplates();
                  case 4:
                    _yield$this$_fetchCon = _context.sent;
                    _yield$this$_fetchCon2 = _slicedToArray__default["default"](_yield$this$_fetchCon, 2);
                    templatesPage = _yield$this$_fetchCon2[0];
                    nextToken = _yield$this$_fetchCon2[1];
                    templates = templatesPage;
                  case 9:
                    if (!(nextToken !== null)) {
                      _context.next = 19;
                      break;
                    }
                    _context.next = 12;
                    return this._fetchContentTemplates(nextToken);
                  case 12:
                    _yield$this$_fetchCon3 = _context.sent;
                    _yield$this$_fetchCon4 = _slicedToArray__default["default"](_yield$this$_fetchCon3, 2);
                    templatesPage = _yield$this$_fetchCon4[0];
                    nextToken = _yield$this$_fetchCon4[1];
                    templates = [].concat(_toConsumableArray__default["default"](templates), _toConsumableArray__default["default"](templatesPage));
                    _context.next = 9;
                    break;
                  case 19:
                    this._cachedTemplates = Object.freeze(templates);
                    setTimeout(function() {
                      _this._cachedTemplates = null;
                    }, this._cacheTtlMs);
                    return _context.abrupt("return", templates);
                  case 22:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function getContentTemplates() {
            return _getContentTemplates.apply(this, arguments);
          }
          return getContentTemplates;
        }()
      }, {
        key: "_fetchContentTemplates",
        value: function() {
          var _fetchContentTemplates2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee2(pageToken) {
            var contentTemplatesUrl, url, response;
            return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    contentTemplatesUrl = "Client/v2/ContentTemplates";
                    url = new UriBuilder(contentTemplatesUrl);
                    url.arg("PageSize", this._pageSize);
                    if (pageToken !== void 0) {
                      url.arg("PageToken", pageToken);
                    }
                    _context2.next = 6;
                    return this._services.commandExecutor.fetchResource(url.build());
                  case 6:
                    response = _context2.sent;
                    return _context2.abrupt("return", [response.templates.map(function(template) {
                      return new ContentTemplate(template);
                    }), response.meta.next_token]);
                  case 8:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function _fetchContentTemplates(_x) {
            return _fetchContentTemplates2.apply(this, arguments);
          }
          return _fetchContentTemplates;
        }()
      }]);
      return ContentClient2;
    }();
    function _createForOfIteratorHelper$1(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      } };
    }
    function _unsupportedIterableToArray$1(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
    }
    function _arrayLikeToArray$1(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var QuickLRU = function(_Symbol$iterator) {
      function QuickLRU2() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck__default["default"](this, QuickLRU2);
        if (!(options.maxSize && options.maxSize > 0)) {
          throw new TypeError("`maxSize` must be a number greater than 0");
        }
        this.maxSize = options.maxSize;
        this.onEviction = options.onEviction;
        this.cache = /* @__PURE__ */ new Map();
        this.oldCache = /* @__PURE__ */ new Map();
        this._size = 0;
      }
      _createClass__default["default"](QuickLRU2, [{
        key: "_set",
        value: function _set(key, value) {
          this.cache.set(key, value);
          this._size++;
          if (this._size >= this.maxSize) {
            this._size = 0;
            if (typeof this.onEviction === "function") {
              var _iterator = _createForOfIteratorHelper$1(this.oldCache.entries()), _step;
              try {
                for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                  var _step$value = _slicedToArray__default["default"](_step.value, 2), _key = _step$value[0], _value = _step$value[1];
                  this.onEviction(_key, _value);
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
            }
            this.oldCache = this.cache;
            this.cache = /* @__PURE__ */ new Map();
          }
        }
      }, {
        key: "get",
        value: function get(key) {
          if (this.cache.has(key)) {
            return this.cache.get(key);
          }
          if (this.oldCache.has(key)) {
            var value = this.oldCache.get(key);
            this.oldCache.delete(key);
            this._set(key, value);
            return value;
          }
        }
      }, {
        key: "set",
        value: function set(key, value) {
          if (this.cache.has(key)) {
            this.cache.set(key, value);
          } else {
            this._set(key, value);
          }
          return this;
        }
      }, {
        key: "has",
        value: function has(key) {
          return this.cache.has(key) || this.oldCache.has(key);
        }
      }, {
        key: "peek",
        value: function peek(key) {
          if (this.cache.has(key)) {
            return this.cache.get(key);
          }
          if (this.oldCache.has(key)) {
            return this.oldCache.get(key);
          }
        }
      }, {
        key: "delete",
        value: function _delete(key) {
          var deleted = this.cache.delete(key);
          if (deleted) {
            this._size--;
          }
          return this.oldCache.delete(key) || deleted;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.cache.clear();
          this.oldCache.clear();
          this._size = 0;
        }
      }, {
        key: "keys",
        value: _regeneratorRuntime__default["default"].mark(function keys() {
          var _iterator2, _step2, _step2$value, key;
          return _regeneratorRuntime__default["default"].wrap(function keys$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _iterator2 = _createForOfIteratorHelper$1(this);
                  _context.prev = 1;
                  _iterator2.s();
                case 3:
                  if ((_step2 = _iterator2.n()).done) {
                    _context.next = 9;
                    break;
                  }
                  _step2$value = _slicedToArray__default["default"](_step2.value, 1), key = _step2$value[0];
                  _context.next = 7;
                  return key;
                case 7:
                  _context.next = 3;
                  break;
                case 9:
                  _context.next = 14;
                  break;
                case 11:
                  _context.prev = 11;
                  _context.t0 = _context["catch"](1);
                  _iterator2.e(_context.t0);
                case 14:
                  _context.prev = 14;
                  _iterator2.f();
                  return _context.finish(14);
                case 17:
                case "end":
                  return _context.stop();
              }
            }
          }, keys, this, [[1, 11, 14, 17]]);
        })
      }, {
        key: "values",
        value: _regeneratorRuntime__default["default"].mark(function values() {
          var _iterator3, _step3, _step3$value, value;
          return _regeneratorRuntime__default["default"].wrap(function values$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _iterator3 = _createForOfIteratorHelper$1(this);
                  _context2.prev = 1;
                  _iterator3.s();
                case 3:
                  if ((_step3 = _iterator3.n()).done) {
                    _context2.next = 9;
                    break;
                  }
                  _step3$value = _slicedToArray__default["default"](_step3.value, 2), value = _step3$value[1];
                  _context2.next = 7;
                  return value;
                case 7:
                  _context2.next = 3;
                  break;
                case 9:
                  _context2.next = 14;
                  break;
                case 11:
                  _context2.prev = 11;
                  _context2.t0 = _context2["catch"](1);
                  _iterator3.e(_context2.t0);
                case 14:
                  _context2.prev = 14;
                  _iterator3.f();
                  return _context2.finish(14);
                case 17:
                case "end":
                  return _context2.stop();
              }
            }
          }, values, this, [[1, 11, 14, 17]]);
        })
      }, {
        key: _Symbol$iterator,
        value: _regeneratorRuntime__default["default"].mark(function value() {
          var _iterator4, _step4, item, _iterator5, _step5, _item, _item2, key;
          return _regeneratorRuntime__default["default"].wrap(function value$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _iterator4 = _createForOfIteratorHelper$1(this.cache);
                  _context3.prev = 1;
                  _iterator4.s();
                case 3:
                  if ((_step4 = _iterator4.n()).done) {
                    _context3.next = 9;
                    break;
                  }
                  item = _step4.value;
                  _context3.next = 7;
                  return item;
                case 7:
                  _context3.next = 3;
                  break;
                case 9:
                  _context3.next = 14;
                  break;
                case 11:
                  _context3.prev = 11;
                  _context3.t0 = _context3["catch"](1);
                  _iterator4.e(_context3.t0);
                case 14:
                  _context3.prev = 14;
                  _iterator4.f();
                  return _context3.finish(14);
                case 17:
                  _iterator5 = _createForOfIteratorHelper$1(this.oldCache);
                  _context3.prev = 18;
                  _iterator5.s();
                case 20:
                  if ((_step5 = _iterator5.n()).done) {
                    _context3.next = 28;
                    break;
                  }
                  _item = _step5.value;
                  _item2 = _slicedToArray__default["default"](_item, 1), key = _item2[0];
                  if (this.cache.has(key)) {
                    _context3.next = 26;
                    break;
                  }
                  _context3.next = 26;
                  return _item;
                case 26:
                  _context3.next = 20;
                  break;
                case 28:
                  _context3.next = 33;
                  break;
                case 30:
                  _context3.prev = 30;
                  _context3.t1 = _context3["catch"](18);
                  _iterator5.e(_context3.t1);
                case 33:
                  _context3.prev = 33;
                  _iterator5.f();
                  return _context3.finish(33);
                case 36:
                case "end":
                  return _context3.stop();
              }
            }
          }, value, this, [[1, 11, 14, 17], [18, 30, 33, 36]]);
        })
      }, {
        key: "size",
        get: function get() {
          var oldCacheSize = 0;
          var _iterator6 = _createForOfIteratorHelper$1(this.oldCache.keys()), _step6;
          try {
            for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
              var key = _step6.value;
              if (!this.cache.has(key)) {
                oldCacheSize++;
              }
            }
          } catch (err) {
            _iterator6.e(err);
          } finally {
            _iterator6.f();
          }
          return Math.min(this._size + oldCacheSize, this.maxSize);
        }
      }]);
      return QuickLRU2;
    }(Symbol.iterator);
    var quickLru = QuickLRU;
    var ChannelMetadata = _createClass__default["default"](
      /**
       * Communication channel type.
       */
      /**
       * The actual metadata.
       */
      /**
       * @internal
       */
      function ChannelMetadata2(type, data) {
        _classCallCheck__default["default"](this, ChannelMetadata2);
        this.type = type;
        this.data = data;
        Object.freeze(data);
      }
    );
    var ChannelMetadataClient = function() {
      function ChannelMetadataClient2(services, configuration) {
        _classCallCheck__default["default"](this, ChannelMetadataClient2);
        this._services = services;
        this._configuration = configuration;
        this._cache = new quickLru({
          maxSize: configuration.channelMetadataCacheCapacity
        });
      }
      _createClass__default["default"](ChannelMetadataClient2, [{
        key: "getChannelMetadata",
        value: function() {
          var _getChannelMetadata = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee(conversationSid, messageSid) {
            var key, cachedItem, url, metadataResponse, metadata;
            return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    key = "".concat(conversationSid, ",").concat(messageSid);
                    cachedItem = this._cache.get(key);
                    if (!cachedItem) {
                      _context.next = 4;
                      break;
                    }
                    return _context.abrupt("return", cachedItem.item);
                  case 4:
                    url = "".concat(this._configuration.links.conversations, "/").concat(conversationSid, "/Messages/").concat(messageSid, "/ChannelMetadata");
                    _context.prev = 5;
                    _context.next = 8;
                    return this._services.commandExecutor.fetchResource(url);
                  case 8:
                    metadataResponse = _context.sent;
                    _context.next = 17;
                    break;
                  case 11:
                    _context.prev = 11;
                    _context.t0 = _context["catch"](5);
                    if (!(_context.t0 instanceof ChannelMetadataNotFoundError)) {
                      _context.next = 16;
                      break;
                    }
                    this._cache.set(key, {
                      item: null
                    });
                    return _context.abrupt("return", null);
                  case 16:
                    throw new Error(_context.t0);
                  case 17:
                    metadata = new ChannelMetadata(metadataResponse.type, metadataResponse.data);
                    this._cache.set(key, {
                      item: metadata
                    });
                    return _context.abrupt("return", metadata);
                  case 20:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[5, 11]]);
          }));
          function getChannelMetadata(_x, _x2) {
            return _getChannelMetadata.apply(this, arguments);
          }
          return getChannelMetadata;
        }()
      }]);
      return ChannelMetadataClient2;
    }();
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var EmailRecipientDescriptor = _createClass__default["default"](
      /**
       * Type of recipient.
       */
      /**
       * Sid of the message that this recipient belongs to.
       */
      /**
       * Email recipient level.
       */
      /**
       * Name of the recipient.
       */
      /**
       * Address of the recipient.
       */
      /**
       * @internal
       */
      function EmailRecipientDescriptor2(recipient) {
        _classCallCheck__default["default"](this, EmailRecipientDescriptor2);
        _defineProperty__default["default"](this, "type", "email");
        this.messageSid = recipient.message_sid;
        this.level = recipient.level;
        this.name = recipient.name;
        this.address = recipient.address;
      }
    );
    var UnknownRecipientDescriptor = _createClass__default["default"](
      /**
       * Type of recipient.
       */
      /**
       * Sid of the message that this recipient belongs to.
       */
      /**
       * Recipient data as a JSON string.
       */
      /**
       * @internal
       */
      function UnknownRecipientDescriptor2(recipient) {
        _classCallCheck__default["default"](this, UnknownRecipientDescriptor2);
        this.type = recipient.type;
        this.messageSid = recipient.message_sid;
        this.rawData = JSON.stringify(recipient);
      }
    );
    var MessageRecipientsClient = function() {
      function MessageRecipientsClient2(services, configuration) {
        _classCallCheck__default["default"](this, MessageRecipientsClient2);
        this._services = services;
        this._configuration = configuration;
        this._cache = new quickLru({
          maxSize: configuration.messageRecipientsCacheCapacity
        });
      }
      _createClass__default["default"](MessageRecipientsClient2, [{
        key: "getRecipientsFromMessage",
        value: function() {
          var _getRecipientsFromMessage = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee(conversationSid, messageSid) {
            var _this = this;
            var key, cachedItem, url, recipientsResponse, recipients;
            return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    key = "".concat(conversationSid, ",").concat(messageSid);
                    cachedItem = this._cache.get(key);
                    if (!cachedItem) {
                      _context.next = 4;
                      break;
                    }
                    return _context.abrupt("return", cachedItem.item);
                  case 4:
                    url = new UriBuilder(this._configuration.links.conversations).path(conversationSid).path("MessageRecipients").arg("MessageSid", messageSid).build();
                    _context.next = 7;
                    return this._services.commandExecutor.fetchResource(url);
                  case 7:
                    recipientsResponse = _context.sent;
                    recipients = recipientsResponse.message_recipients.map(function(recipient) {
                      return _this._wrapResponse(recipient);
                    });
                    if (recipients.length > 0) {
                      this._cache.set(key, {
                        item: recipients
                      });
                    }
                    return _context.abrupt("return", recipients);
                  case 11:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function getRecipientsFromMessage(_x, _x2) {
            return _getRecipientsFromMessage.apply(this, arguments);
          }
          return getRecipientsFromMessage;
        }()
      }, {
        key: "getRecipientsFromConversation",
        value: function() {
          var _getRecipientsFromConversation = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee2(conversationSid, paginatorOptions) {
            var _paginatorOptions$pag, _paginatorOptions$pag2, _this2 = this;
            var url, recipientsResponse, allRecipients, _iterator, _step, _this$_cache$get$item, _this$_cache$get, recipient, key, existingMessageRecipients;
            return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    url = new UriBuilder(this._configuration.links.conversations).path(conversationSid).path("MessageRecipients").arg("PageToken", (_paginatorOptions$pag = paginatorOptions === null || paginatorOptions === void 0 ? void 0 : paginatorOptions.pageToken) !== null && _paginatorOptions$pag !== void 0 ? _paginatorOptions$pag : void 0).arg("PageSize", (_paginatorOptions$pag2 = paginatorOptions === null || paginatorOptions === void 0 ? void 0 : paginatorOptions.pageSize) !== null && _paginatorOptions$pag2 !== void 0 ? _paginatorOptions$pag2 : void 0).build();
                    _context2.next = 3;
                    return this._services.commandExecutor.fetchResource(url);
                  case 3:
                    recipientsResponse = _context2.sent;
                    allRecipients = recipientsResponse.message_recipients.map(function(recipient2) {
                      return _this2._wrapResponse(recipient2);
                    });
                    _iterator = _createForOfIteratorHelper(allRecipients);
                    try {
                      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                        recipient = _step.value;
                        key = "".concat(conversationSid, ",").concat(recipient.messageSid);
                        existingMessageRecipients = (_this$_cache$get$item = (_this$_cache$get = this._cache.get(key)) === null || _this$_cache$get === void 0 ? void 0 : _this$_cache$get.item) !== null && _this$_cache$get$item !== void 0 ? _this$_cache$get$item : [];
                        this._cache.set(key, {
                          item: [].concat(_toConsumableArray__default["default"](existingMessageRecipients), [recipient])
                        });
                      }
                    } catch (err) {
                      _iterator.e(err);
                    } finally {
                      _iterator.f();
                    }
                    return _context2.abrupt("return", new RestPaginator(allRecipients, function(pageToken, pageSize) {
                      return _this2.getRecipientsFromConversation(conversationSid, {
                        pageToken,
                        pageSize
                      });
                    }, recipientsResponse.meta.previous_token, recipientsResponse.meta.next_token));
                  case 8:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function getRecipientsFromConversation(_x3, _x4) {
            return _getRecipientsFromConversation.apply(this, arguments);
          }
          return getRecipientsFromConversation;
        }()
      }, {
        key: "_wrapResponse",
        value: function _wrapResponse(recipient) {
          switch (recipient.type) {
            case "email":
              return new EmailRecipientDescriptor(recipient);
            default:
              return new UnknownRecipientDescriptor(recipient);
          }
        }
      }]);
      return MessageRecipientsClient2;
    }();
    var _class;
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty__default["default"](target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default["default"](this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn__default["default"](this, result);
      };
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var Client_1;
    var ClientServices = _createClass__default["default"](function ClientServices2() {
      _classCallCheck__default["default"](this, ClientServices2);
    });
    exports.Client = Client_1 = (_class = function(_ReplayEventEmitter) {
      _inherits__default["default"](Client, _ReplayEventEmitter);
      var _super = _createSuper(Client);
      function Client(fpaToken) {
        var _this$_options$logLev, _this$_options$twilso, _this$_options$transp, _this$_options$notifi, _this$_options$syncCl;
        var _this;
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        _classCallCheck__default["default"](this, Client);
        _this = _super.call(this);
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "version", version);
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "connectionState", "unknown");
        _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "parsePushNotification", Client_1.parsePushNotification);
        _this._fpaToken = fpaToken !== null && fpaToken !== void 0 ? fpaToken : "";
        _this._options = options !== null && options !== void 0 ? options : {};
        if (!_this._options.disableDeepClone) {
          var _options = _objectSpread(_objectSpread({}, _this._options), {}, {
            transport: void 0,
            twilsockClient: void 0
          });
          _options = deepClone(_options);
          _options.transport = _this._options.transport;
          _options.twilsockClient = _this._options.twilsockClient;
          _this._options = _options;
        }
        _this._options.logLevel = (_this$_options$logLev = _this._options.logLevel) !== null && _this$_options$logLev !== void 0 ? _this$_options$logLev : "silent";
        Client_1._logger.setLevel(_this._options.logLevel);
        var productId = _this._options.productId = "ip_messaging";
        _this._options.clientMetadata = _this._options.clientMetadata || {};
        if (!_this._options.clientMetadata.hasOwnProperty("type")) {
          _this._options.clientMetadata.type = "conversations";
        }
        if (!_this._options.clientMetadata.hasOwnProperty("sdk")) {
          _this._options.clientMetadata.sdk = "JS";
          _this._options.clientMetadata.sdkv = version;
        }
        _this._options.Sync = _this._options.Sync || {};
        if (typeof _this._options.Sync.enableSessionStorage === "undefined") {
          _this._options.Sync.enableSessionStorage = true;
        }
        if (_this._options.region) {
          _this._options.Sync.region = _this._options.region;
        }
        if (!fpaToken) {
          throw new Error("A valid Twilio token should be provided");
        }
        _this._services = new ClientServices();
        _this._myself = new User("", "", null, _this._services);
        var startTwilsock = !_this._options.twilsockClient;
        if (!_this._options.initRegistrations) {
          var initRegistration = new twilsock.InitRegistration(productId);
          Client_1.populateInitRegistrations(initRegistration);
          _this._options.initRegistrations = [initRegistration];
        }
        _this._services.twilsockClient = _this._options.twilsockClient = (_this$_options$twilso = _this._options.twilsockClient) !== null && _this$_options$twilso !== void 0 ? _this$_options$twilso : new twilsock.TwilsockClient(fpaToken, productId, _this._options);
        _this._services.twilsockClient.on(Client_1.tokenAboutToExpire, function() {
          return _this.emit(Client_1.tokenAboutToExpire);
        });
        _this._services.twilsockClient.on(Client_1.tokenExpired, function() {
          return _this.emit(Client_1.tokenExpired);
        });
        _this._services.twilsockClient.on(Client_1.connectionError, function(error) {
          return _this.emit(Client_1.connectionError, error);
        });
        _this._services.twilsockClient.on("stateChanged", function(state) {
          Client_1._logger.debug("Handling stateChanged for ConversationsClient: new state ".concat(state));
          if (state !== _this.connectionState) {
            _this.connectionState = state;
            _this.emit(Client_1.connectionStateChanged, _this.connectionState);
          }
        });
        _this._services.transport = _this._options.transport = (_this$_options$transp = _this._options.transport) !== null && _this$_options$transp !== void 0 ? _this$_options$transp : _this._options.twilsockClient;
        _this._services.notificationClient = _this._options.notificationsClient = (_this$_options$notifi = _this._options.notificationsClient) !== null && _this$_options$notifi !== void 0 ? _this$_options$notifi : new notifications.Notifications(fpaToken, _this._options);
        _this._services.syncClient = _this._options.syncClient = (_this$_options$syncCl = _this._options.syncClient) !== null && _this$_options$syncCl !== void 0 ? _this$_options$syncCl : new twilioSync.SyncClient(fpaToken, _this._options);
        var configurationOptions = (options === null || options === void 0 ? void 0 : options.Chat) || (options === null || options === void 0 ? void 0 : options.IPMessaging) || options || {};
        var region = configurationOptions.region || (options === null || options === void 0 ? void 0 : options.region);
        var baseUrl = configurationOptions.apiUri || configurationOptions.typingUri || "https://aim.".concat(region || "us1", ".twilio.com");
        _this._services.commandExecutor = new CommandExecutor(baseUrl, {
          transport: _this._options.transport
        }, productId);
        _this._services.contentClient = new ContentClient(_this._services);
        var emitFailed = function emitFailed2(error) {
          _this._rejectEnsureReady(error);
          _this.emit(Client_1.stateChanged, "failed");
          _this.emit(Client_1.initFailed, {
            error
          });
        };
        var emitDisconnected = function emitDisconnected2() {
          emitFailed({
            terminal: true,
            message: "Twilsock has disconnected."
          });
          _this._initializeEnsureReady((options === null || options === void 0 ? void 0 : options.throwErrorsAlways) || false);
        };
        _this._services.twilsockClient.once("connectionError", emitFailed);
        _this._services.twilsockClient.once("disconnected", emitDisconnected);
        _this._services.twilsockClient.once("connected", _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee() {
          var startupEvent, connectionError;
          return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  Client_1._logger.debug("ConversationsClient started INITIALIZING");
                  _this._services.twilsockClient.off("connectionError", emitFailed);
                  _this._services.twilsockClient.off("disconnected", emitDisconnected);
                  _context.prev = 3;
                  startupEvent = "conversations.client.startup";
                  _this._services.twilsockClient.addPartialTelemetryEvent(new twilsock.TelemetryEventDescription(startupEvent, "Conversations client startup", /* @__PURE__ */ new Date()), startupEvent, twilsock.TelemetryPoint.Start);
                  _context.next = 8;
                  return _this._initialize();
                case 8:
                  _this._services.twilsockClient.addPartialTelemetryEvent(new twilsock.TelemetryEventDescription("", "", /* @__PURE__ */ new Date()), startupEvent, twilsock.TelemetryPoint.End);
                  _context.next = 17;
                  break;
                case 11:
                  _context.prev = 11;
                  _context.t0 = _context["catch"](3);
                  connectionError = {
                    terminal: true,
                    message: _context.t0.message
                  };
                  _this._rejectEnsureReady(connectionError);
                  _this.emit(Client_1.stateChanged, "failed");
                  _this.emit(Client_1.initFailed, {
                    error: connectionError
                  });
                case 17:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[3, 11]]);
        })));
        _this._initializeEnsureReady((options === null || options === void 0 ? void 0 : options.throwErrorsAlways) || false);
        if (startTwilsock) {
          _this._services.twilsockClient.connect();
        }
        return _this;
      }
      _createClass__default["default"](Client, [{
        key: "user",
        get: function get() {
          return this._myself;
        }
        /**
         * Client reachability state. Throws an error if accessed before the client
         * initialization was completed.
         */
      }, {
        key: "reachabilityEnabled",
        get: function get() {
          if (!this._configuration) {
            throw new Error("Reachability information could not yet be accessed as the client has not yet been initialized. Subscribe to the 'stateChanged' event to properly react to the client initialization.");
          }
          return this._configuration.reachabilityEnabled;
        }
        /**
         * @deprecated
         * Current token.
         * @internal
         */
      }, {
        key: "token",
        get: function get() {
          return this._fpaToken;
        }
        /**
         * @deprecated Call constructor directly.
         *
         * Factory method to create a Conversations client instance.
         *
         * The factory method will automatically trigger connection.
         * Do not use it if you need finer-grained control.
         *
         * Since this method returns an already-initialized client, some of the events
         * will be lost because they happen *before* the initialization. It is
         * recommended that `client.onWithReplay` is used as opposed to `client.on`
         * for subscribing to client events. The `client.onWithReplay` will re-emit
         * the most recent value for a given event if it emitted before the
         * subscription.
         *
         * @param token Access token.
         * @param options Options to customize the client.
         * @returns Returns a fully initialized client.
         */
      }, {
        key: "shutdown",
        value: (
          /**
           * Gracefully shut down the client.
           */
          function() {
            var _shutdown = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee2() {
              return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      _context2.next = 2;
                      return this._ensureReady;
                    case 2:
                      _context2.next = 4;
                      return this._services.twilsockClient.disconnect();
                    case 4:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2, this);
            }));
            function shutdown() {
              return _shutdown.apply(this, arguments);
            }
            return shutdown;
          }()
        )
        /**
         * Update the token used by the client and re-register with the Conversations services.
         * @param token New access token.
         */
      }, {
        key: "updateToken",
        value: function() {
          var _updateToken = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee3(token) {
            return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    _context3.next = 2;
                    return this._ensureReady;
                  case 2:
                    Client_1._logger.info("updateToken");
                    if (!(this._fpaToken === token)) {
                      _context3.next = 5;
                      break;
                    }
                    return _context3.abrupt("return", this);
                  case 5:
                    _context3.next = 7;
                    return this._services.twilsockClient.updateToken(token);
                  case 7:
                    _context3.next = 9;
                    return this._services.notificationClient.updateToken(token);
                  case 9:
                    _context3.next = 11;
                    return this._services.mcsClient.updateToken(token);
                  case 11:
                    this._fpaToken = token;
                    return _context3.abrupt("return", this);
                  case 13:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));
          function updateToken(_x) {
            return _updateToken.apply(this, arguments);
          }
          return updateToken;
        }()
        /**
         * Get a known conversation by its SID.
         * @param conversationSid Conversation sid
         */
      }, {
        key: "getConversationBySid",
        value: function() {
          var _getConversationBySid = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee4(conversationSid) {
            var conversation;
            return _regeneratorRuntime__default["default"].wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    _context4.next = 2;
                    return this._ensureReady;
                  case 2:
                    _context4.next = 4;
                    return this._conversationsEntity.myConversationsRead.promise;
                  case 4:
                    _context4.next = 6;
                    return this._conversationsEntity.getConversation(conversationSid);
                  case 6:
                    conversation = _context4.sent;
                    if (conversation) {
                      _context4.next = 12;
                      break;
                    }
                    _context4.next = 10;
                    return this.peekConversationBySid(conversationSid);
                  case 10:
                    conversation = _context4.sent;
                    if (conversation) {
                      deprecationDecorator.deprecationWarning("The method getConversationBySid is deprecated to retrieve conversations you're not part of. Use peekConversationBySid instead.");
                    }
                  case 12:
                    if (conversation) {
                      _context4.next = 14;
                      break;
                    }
                    throw new Error("Conversation with SID ".concat(conversationSid, " was not found."));
                  case 14:
                    return _context4.abrupt("return", conversation);
                  case 15:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));
          function getConversationBySid(_x2) {
            return _getConversationBySid.apply(this, arguments);
          }
          return getConversationBySid;
        }()
        /**
         * Peek a conversation by its SID.
         * @param conversationSid Conversation sid
         * @internal
         */
      }, {
        key: "peekConversationBySid",
        value: function() {
          var _peekConversationBySid = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee5(conversationSid) {
            var conversation;
            return _regeneratorRuntime__default["default"].wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    _context5.next = 2;
                    return this._ensureReady;
                  case 2:
                    _context5.next = 4;
                    return this._conversationsEntity.peekConversation(conversationSid);
                  case 4:
                    conversation = _context5.sent;
                    if (conversation) {
                      _context5.next = 7;
                      break;
                    }
                    throw new Error("Conversation with SID ".concat(conversationSid, " was not found."));
                  case 7:
                    return _context5.abrupt("return", conversation);
                  case 8:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));
          function peekConversationBySid(_x3) {
            return _peekConversationBySid.apply(this, arguments);
          }
          return peekConversationBySid;
        }()
        /**
         * Get a known conversation by its unique identifier name.
         * @param uniqueName The unique identifier name of the conversation.
         */
      }, {
        key: "getConversationByUniqueName",
        value: function() {
          var _getConversationByUniqueName = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee6(uniqueName) {
            var conversation;
            return _regeneratorRuntime__default["default"].wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    _context6.next = 2;
                    return this._ensureReady;
                  case 2:
                    _context6.next = 4;
                    return this._conversationsEntity.myConversationsRead.promise;
                  case 4:
                    _context6.next = 6;
                    return this._conversationsEntity.getConversationByUniqueName(uniqueName);
                  case 6:
                    conversation = _context6.sent;
                    if (conversation) {
                      _context6.next = 9;
                      break;
                    }
                    throw new Error("Conversation with unique name ".concat(uniqueName, " was not found."));
                  case 9:
                    return _context6.abrupt("return", conversation);
                  case 10:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, this);
          }));
          function getConversationByUniqueName(_x4) {
            return _getConversationByUniqueName.apply(this, arguments);
          }
          return getConversationByUniqueName;
        }()
        /**
         * Get the current list of all the subscribed conversations.
         */
      }, {
        key: "getSubscribedConversations",
        value: function() {
          var _getSubscribedConversations = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee7() {
            return _regeneratorRuntime__default["default"].wrap(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    _context7.next = 2;
                    return this._ensureReady;
                  case 2:
                    return _context7.abrupt("return", this._conversationsPromise.then(function(conversations) {
                      return conversations.getConversations();
                    }));
                  case 3:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee7, this);
          }));
          function getSubscribedConversations() {
            return _getSubscribedConversations.apply(this, arguments);
          }
          return getSubscribedConversations;
        }()
        /**
         * Create a conversation on the server and subscribe to its events.
         * The default is a conversation with an empty friendly name.
         * @param options Options for the conversation.
         */
      }, {
        key: "createConversation",
        value: function() {
          var _createConversation = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee8(options) {
            return _regeneratorRuntime__default["default"].wrap(function _callee8$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    _context8.next = 2;
                    return this._ensureReady;
                  case 2:
                    options = options || {};
                    return _context8.abrupt("return", this._conversationsPromise.then(function(conversationsEntity) {
                      return conversationsEntity.addConversation(options);
                    }));
                  case 4:
                  case "end":
                    return _context8.stop();
                }
              }
            }, _callee8, this);
          }));
          function createConversation(_x5) {
            return _createConversation.apply(this, arguments);
          }
          return createConversation;
        }()
        /**
         * Register for push notifications.
         * @param channelType Channel type.
         * @param registrationId Push notification ID provided by the FCM/APNS service
         * on the platform.
         */
      }, {
        key: "setPushRegistrationId",
        value: function() {
          var _setPushRegistrationId = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee9(channelType, registrationId) {
            return _regeneratorRuntime__default["default"].wrap(function _callee9$(_context9) {
              while (1) {
                switch (_context9.prev = _context9.next) {
                  case 0:
                    _context9.next = 2;
                    return this._ensureReady;
                  case 2:
                    this._subscribeToPushNotifications(channelType);
                    this._services.notificationClient.setPushRegistrationId(channelType, registrationId);
                    _context9.next = 6;
                    return this._services.notificationClient.commitChanges();
                  case 6:
                  case "end":
                    return _context9.stop();
                }
              }
            }, _callee9, this);
          }));
          function setPushRegistrationId(_x6, _x7) {
            return _setPushRegistrationId.apply(this, arguments);
          }
          return setPushRegistrationId;
        }()
        /**
         * Unregister from push notifications.
         * @param channelType Channel type.
         * @deprecated Use removePushRegistrations() instead.
         */
      }, {
        key: "unsetPushRegistrationId",
        value: function() {
          var _unsetPushRegistrationId = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee10(channelType) {
            return _regeneratorRuntime__default["default"].wrap(function _callee10$(_context10) {
              while (1) {
                switch (_context10.prev = _context10.next) {
                  case 0:
                    _context10.next = 2;
                    return this._ensureReady;
                  case 2:
                    this._unsubscribeFromPushNotifications(channelType);
                    _context10.next = 5;
                    return this._services.notificationClient.commitChanges();
                  case 5:
                  case "end":
                    return _context10.stop();
                }
              }
            }, _callee10, this);
          }));
          function unsetPushRegistrationId(_x8) {
            return _unsetPushRegistrationId.apply(this, arguments);
          }
          return unsetPushRegistrationId;
        }()
        /**
         * Clear existing registrations directly using provided device token.
         * This is useful to ensure stopped subscriptions without resubscribing.
         *
         * This function goes completely beside the state machine and removes all
         * registrations.
         * Use with caution: if it races with current state machine operations,
         * madness will ensue.
         *
         * @param channelType Channel type.
         * @param registrationId Push notification ID provided by the FCM/APNS service
         * on the platform.
         */
      }, {
        key: "removePushRegistrations",
        value: function() {
          var _removePushRegistrations = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee11(channelType, registrationId) {
            return _regeneratorRuntime__default["default"].wrap(function _callee11$(_context11) {
              while (1) {
                switch (_context11.prev = _context11.next) {
                  case 0:
                    _context11.next = 2;
                    return this._services.notificationClient.removeRegistrations(channelType, registrationId);
                  case 2:
                  case "end":
                    return _context11.stop();
                }
              }
            }, _callee11, this);
          }));
          function removePushRegistrations(_x9, _x10) {
            return _removePushRegistrations.apply(this, arguments);
          }
          return removePushRegistrations;
        }()
        /**
         * Parse a push notification payload.
         */
      }, {
        key: "handlePushNotification",
        value: (
          /**
           * Handle push notification payload parsing and emit the
           * {@link Client.pushNotification} event on this {@link Client} instance.
           * @param notificationPayload Push notification payload
           */
          function() {
            var _handlePushNotification = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee12(notificationPayload) {
              return _regeneratorRuntime__default["default"].wrap(function _callee12$(_context12) {
                while (1) {
                  switch (_context12.prev = _context12.next) {
                    case 0:
                      _context12.next = 2;
                      return this._ensureReady;
                    case 2:
                      Client_1._logger.debug("handlePushNotification, notificationPayload=", notificationPayload);
                      this.emit("pushNotification", Client_1.parsePushNotification(notificationPayload));
                    case 4:
                    case "end":
                      return _context12.stop();
                  }
                }
              }, _callee12, this);
            }));
            function handlePushNotification(_x11) {
              return _handlePushNotification.apply(this, arguments);
            }
            return handlePushNotification;
          }()
        )
        /**
         * Gets a user with the given identity. If it's in the subscribed list, then
         * return the user object from it;
         * if not, then subscribe and add user to the subscribed list.
         * @param identity Identity of the user.
         * @returns A fully initialized user.
         */
      }, {
        key: "getUser",
        value: function() {
          var _getUser = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee13(identity) {
            return _regeneratorRuntime__default["default"].wrap(function _callee13$(_context13) {
              while (1) {
                switch (_context13.prev = _context13.next) {
                  case 0:
                    _context13.next = 2;
                    return this._ensureReady;
                  case 2:
                    return _context13.abrupt("return", this._services.users.getUser(identity));
                  case 3:
                  case "end":
                    return _context13.stop();
                }
              }
            }, _callee13, this);
          }));
          function getUser(_x12) {
            return _getUser.apply(this, arguments);
          }
          return getUser;
        }()
        /**
         * Get a list of subscribed user objects.
         */
      }, {
        key: "getSubscribedUsers",
        value: function() {
          var _getSubscribedUsers = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee14() {
            return _regeneratorRuntime__default["default"].wrap(function _callee14$(_context14) {
              while (1) {
                switch (_context14.prev = _context14.next) {
                  case 0:
                    _context14.next = 2;
                    return this._ensureReady;
                  case 2:
                    return _context14.abrupt("return", this._services.users.getSubscribedUsers());
                  case 3:
                  case "end":
                    return _context14.stop();
                }
              }
            }, _callee14, this);
          }));
          function getSubscribedUsers() {
            return _getSubscribedUsers.apply(this, arguments);
          }
          return getSubscribedUsers;
        }()
        /**
         * Get content URLs for all media attachments in the given set of media sids
         * using a single operation.
         * @param mediaSids Set of media sids to query for the content URL.
         */
      }, {
        key: "getTemporaryContentUrlsForMediaSids",
        value: function getTemporaryContentUrlsForMediaSids(mediaSids) {
          var _this2 = this;
          return new mcsClient.CancellablePromise(function() {
            var _ref2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee15(resolve, reject, onCancel) {
              var request, urls;
              return _regeneratorRuntime__default["default"].wrap(function _callee15$(_context15) {
                while (1) {
                  switch (_context15.prev = _context15.next) {
                    case 0:
                      if (!(!_this2._services.mcsClient || !mediaSids)) {
                        _context15.next = 3;
                        break;
                      }
                      reject(new Error("Media Content Service is unavailable"));
                      return _context15.abrupt("return");
                    case 3:
                      request = _this2._services.mcsClient.mediaSetGetContentUrls(mediaSids);
                      onCancel(function() {
                        request.cancel();
                      });
                      _context15.prev = 5;
                      _context15.next = 8;
                      return request;
                    case 8:
                      urls = _context15.sent;
                      resolve(urls);
                      _context15.next = 15;
                      break;
                    case 12:
                      _context15.prev = 12;
                      _context15.t0 = _context15["catch"](5);
                      reject(_context15.t0);
                    case 15:
                    case "end":
                      return _context15.stop();
                  }
                }
              }, _callee15, null, [[5, 12]]);
            }));
            return function(_x13, _x14, _x15) {
              return _ref2.apply(this, arguments);
            };
          }());
        }
        /**
         * Get content URLs for all media attachments in the given set using a single
         * operation.
         * @param contentSet Set of media attachments to query content URLs.
         */
      }, {
        key: "getTemporaryContentUrlsForMedia",
        value: function getTemporaryContentUrlsForMedia(contentSet) {
          var sids = contentSet.map(function(m) {
            return m.sid;
          });
          return this.getTemporaryContentUrlsForMediaSids(sids);
        }
        /**
         * Returns rich content templates belonging to the account. Rich content
         * templates can be created via the Twilio console or the REST API.
         */
      }, {
        key: "getContentTemplates",
        value: function() {
          var _getContentTemplates = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee16() {
            return _regeneratorRuntime__default["default"].wrap(function _callee16$(_context16) {
              while (1) {
                switch (_context16.prev = _context16.next) {
                  case 0:
                    _context16.next = 2;
                    return this._ensureReady;
                  case 2:
                    _context16.next = 4;
                    return this._services.contentClient.getContentTemplates();
                  case 4:
                    return _context16.abrupt("return", _context16.sent);
                  case 5:
                  case "end":
                    return _context16.stop();
                }
              }
            }, _callee16, this);
          }));
          function getContentTemplates() {
            return _getContentTemplates.apply(this, arguments);
          }
          return getContentTemplates;
        }()
        /**
         * Initialize the client.
         */
      }, {
        key: "_initialize",
        value: function() {
          var _initialize2 = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee17() {
            var _this3 = this;
            var configurationResponse;
            return _regeneratorRuntime__default["default"].wrap(function _callee17$(_context17) {
              while (1) {
                switch (_context17.prev = _context17.next) {
                  case 0:
                    _context17.next = 2;
                    return this._services.commandExecutor.fetchResource("Client/v2/Configuration");
                  case 2:
                    configurationResponse = _context17.sent;
                    this._configuration = new Configuration(this._options, configurationResponse, Client_1._logger);
                    this._services.channelMetadataClient = new ChannelMetadataClient(this._services, this._configuration);
                    this._services.messageRecipientsClient = new MessageRecipientsClient(this._services, this._configuration);
                    this._myself._resolveInitialization(this._configuration, this._configuration.userIdentity, this._configuration.userInfo, true);
                    this._services.typingIndicator = new TypingIndicator(this.getConversationBySid.bind(this), this._configuration, this._services);
                    this._services.network = new Network(this._configuration, this._services);
                    this._services.users = new Users(this._myself, this._configuration, this._services);
                    this._services.users.on("userSubscribed", function(user) {
                      _this3.emit("userSubscribed", user);
                    });
                    this._services.users.on("userUpdated", function(args) {
                      return _this3.emit("userUpdated", args);
                    });
                    this._services.users.on("userUnsubscribed", function(user) {
                      _this3.emit("userUnsubscribed", user);
                    });
                    this._conversationsEntity = new Conversations(this._configuration, this._services);
                    this._conversationsEntity.on("conversationAdded", function(conversation) {
                      _this3.emit("conversationAdded", conversation);
                    });
                    this._conversationsEntity.on("conversationRemoved", function(conversation) {
                      _this3.emit("conversationRemoved", conversation);
                    });
                    this._conversationsEntity.on("conversationJoined", function(conversation) {
                      _this3.emit("conversationJoined", conversation);
                    });
                    this._conversationsEntity.on("conversationLeft", function(conversation) {
                      _this3.emit("conversationLeft", conversation);
                    });
                    this._conversationsEntity.on("conversationUpdated", function(args) {
                      return _this3.emit("conversationUpdated", args);
                    });
                    this._conversationsEntity.on("participantJoined", function(participant) {
                      _this3.emit("participantJoined", participant);
                    });
                    this._conversationsEntity.on("participantLeft", function(participant) {
                      _this3.emit("participantLeft", participant);
                    });
                    this._conversationsEntity.on("participantUpdated", function(args) {
                      return _this3.emit("participantUpdated", args);
                    });
                    this._conversationsEntity.on("messageAdded", function(message) {
                      return _this3.emit("messageAdded", message);
                    });
                    this._conversationsEntity.on("messageUpdated", function(args) {
                      return _this3.emit("messageUpdated", args);
                    });
                    this._conversationsEntity.on("messageRemoved", function(message) {
                      return _this3.emit("messageRemoved", message);
                    });
                    this._conversationsEntity.on("typingStarted", function(participant) {
                      return _this3.emit("typingStarted", participant);
                    });
                    this._conversationsEntity.on("typingEnded", function(participant) {
                      return _this3.emit("typingEnded", participant);
                    });
                    this._conversationsPromise = this._conversationsEntity.fetchConversations().then(function() {
                      return _this3._conversationsEntity;
                    }).catch(function(error) {
                      console.error("Failed to fetch conversations _conversationsPromise -> client.ts", error);
                      throw error;
                    });
                    _context17.next = 30;
                    return this._services.users.myself._ensureFetched();
                  case 30:
                    Client_1._supportedPushChannels.forEach(function(channelType) {
                      return _this3._subscribeToPushNotifications(channelType);
                    });
                    this._services.typingIndicator.initialize();
                    this._services.mcsClient = new mcsClient.McsClient(this._fpaToken, this._configuration.links.mediaService, this._configuration.links.mediaSetService, _objectSpread(_objectSpread({}, this._options), {}, {
                      transport: void 0
                    }));
                    this._resolveEnsureReady();
                    this.emit(Client_1.stateChanged, "initialized");
                    this.emit(Client_1.initialized);
                  case 36:
                  case "end":
                    return _context17.stop();
                }
              }
            }, _callee17, this);
          }));
          function _initialize() {
            return _initialize2.apply(this, arguments);
          }
          return _initialize;
        }()
        /**
         * Subscribe to push notifications.
         * @param channelType The channel type to subscribe to.
         */
      }, {
        key: "_subscribeToPushNotifications",
        value: function _subscribeToPushNotifications(channelType) {
          var _this4 = this;
          [NotificationTypes.NEW_MESSAGE, NotificationTypes.ADDED_TO_CONVERSATION, NotificationTypes.REMOVED_FROM_CONVERSATION, NotificationTypes.TYPING_INDICATOR, NotificationTypes.CONSUMPTION_UPDATE].forEach(function(messageType) {
            _this4._services.notificationClient.subscribe(channelType, messageType);
          });
        }
        /**
         * Unsubscribe from push notifications.
         * @param channelType The channel type to unsubscribe from.
         */
      }, {
        key: "_unsubscribeFromPushNotifications",
        value: function _unsubscribeFromPushNotifications(channelType) {
          var _this5 = this;
          [NotificationTypes.NEW_MESSAGE, NotificationTypes.ADDED_TO_CONVERSATION, NotificationTypes.REMOVED_FROM_CONVERSATION, NotificationTypes.TYPING_INDICATOR, NotificationTypes.CONSUMPTION_UPDATE].forEach(function(messageType) {
            _this5._services.notificationClient.unsubscribe(channelType, messageType);
          });
        }
        /**
         * Initialize the ensureReady promise.
         */
      }, {
        key: "_initializeEnsureReady",
        value: function _initializeEnsureReady(throwErrorsAlways) {
          var _this6 = this;
          this._ensureReady = new Promise(function(resolve, reject) {
            _this6._resolveEnsureReady = resolve;
            _this6._rejectEnsureReady = reject;
          }).catch(function(error) {
            if (throwErrorsAlways) {
              throw error;
            } else {
              return void 0;
            }
          });
        }
      }], [{
        key: "create",
        value: function() {
          var _create = _asyncToGenerator__default["default"](_regeneratorRuntime__default["default"].mark(function _callee18(token, options) {
            var client;
            return _regeneratorRuntime__default["default"].wrap(function _callee18$(_context18) {
              while (1) {
                switch (_context18.prev = _context18.next) {
                  case 0:
                    if (!(options !== null && options !== void 0 && options.twilsockClient)) {
                      _context18.next = 2;
                      break;
                    }
                    throw new Error("Obsolete usage of ConversationsClient.create() factory method: if you pass twilsock from the outside then you must use ConversationsClient constructor and be prepared to work with uninitialized client.");
                  case 2:
                    client = new Client_1(token, options);
                    _context18.next = 5;
                    return client._ensureReady;
                  case 5:
                    return _context18.abrupt("return", client);
                  case 6:
                  case "end":
                    return _context18.stop();
                }
              }
            }, _callee18);
          }));
          function create(_x16, _x17) {
            return _create.apply(this, arguments);
          }
          return create;
        }()
        /**
         * Static method for push notification payload parsing. Returns parsed push as
         * a {@link PushNotification} object.
         * @param notificationPayload Push notification payload.
         */
      }, {
        key: "parsePushNotification",
        value: function parsePushNotification(notificationPayload) {
          Client_1._logger.debug("parsePushNotification, notificationPayload=", notificationPayload);
          if (typeof notificationPayload.aps !== "undefined") {
            if (!notificationPayload.twi_message_type) {
              throw new Error("Provided push notification payload does not contain Programmable Chat push notification type");
            }
            var data = Client_1._parsePushNotificationChatData(notificationPayload);
            var apsPayload = notificationPayload.aps;
            var body;
            var title = null;
            if (typeof apsPayload.alert === "string") {
              body = apsPayload.alert || null;
            } else {
              var _apsPayload$alert, _apsPayload$alert2;
              body = ((_apsPayload$alert = apsPayload.alert) === null || _apsPayload$alert === void 0 ? void 0 : _apsPayload$alert.body) || null;
              title = ((_apsPayload$alert2 = apsPayload.alert) === null || _apsPayload$alert2 === void 0 ? void 0 : _apsPayload$alert2.title) || null;
            }
            return new PushNotification({
              title,
              body,
              sound: apsPayload.sound || null,
              badge: apsPayload.badge || null,
              action: apsPayload.category || null,
              type: notificationPayload.twi_message_type,
              data
            });
          }
          if (typeof notificationPayload.data !== "undefined") {
            var dataPayload = notificationPayload.data;
            if (!dataPayload.twi_message_type) {
              throw new Error("Provided push notification payload does not contain Programmable Chat push notification type");
            }
            var _data = Client_1._parsePushNotificationChatData(notificationPayload.data);
            return new PushNotification({
              title: dataPayload.twi_title || null,
              body: dataPayload.twi_body || null,
              sound: dataPayload.twi_sound || null,
              badge: null,
              action: dataPayload.twi_action || null,
              type: dataPayload.twi_message_type,
              data: _data
            });
          }
          throw new Error("Provided push notification payload is not Programmable Chat notification");
        }
        /**
         * Static method for parsing push notification chat data.
         * @param data Data to parse
         */
      }, {
        key: "_parsePushNotificationChatData",
        value: function _parsePushNotificationChatData(data) {
          var result = {};
          for (var key in Client_1._supportedPushDataFields) {
            var value = data[key];
            if (typeof value === "undefined" || value === null) {
              continue;
            }
            if (key === "message_index" || key === "media_count") {
              var number = parseToNumber(value);
              if (number !== null) {
                result[Client_1._supportedPushDataFields[key]] = number;
              }
              continue;
            }
            if (key === "media") {
              if (typeof value === "string") {
                try {
                  result[Client_1._supportedPushDataFields[key]] = JSON.parse(value);
                } catch (_unused) {
                  Client_1._logger.debug("Media message notification parsing error");
                }
              }
              continue;
            }
            result[Client_1._supportedPushDataFields[key]] = value;
          }
          return result;
        }
        /**
         * Populate the client with init registrations.
         * @param reg The init registration to populate.
         */
      }, {
        key: "populateInitRegistrations",
        value: function populateInitRegistrations(reg) {
          reg.populateInitRegistrations([NotificationTypes.TYPING_INDICATOR]);
          twilioSync.SyncClient.populateInitRegistrations(reg);
        }
      }]);
      return Client;
    }(replayEventEmitter.ReplayEventEmitter), _defineProperty__default["default"](_class, "conversationAdded", "conversationAdded"), _defineProperty__default["default"](_class, "conversationJoined", "conversationJoined"), _defineProperty__default["default"](_class, "conversationLeft", "conversationLeft"), _defineProperty__default["default"](_class, "conversationRemoved", "conversationRemoved"), _defineProperty__default["default"](_class, "conversationUpdated", "conversationUpdated"), _defineProperty__default["default"](_class, "participantJoined", "participantJoined"), _defineProperty__default["default"](_class, "participantLeft", "participantLeft"), _defineProperty__default["default"](_class, "participantUpdated", "participantUpdated"), _defineProperty__default["default"](_class, "messageAdded", "messageAdded"), _defineProperty__default["default"](_class, "messageRemoved", "messageRemoved"), _defineProperty__default["default"](_class, "messageUpdated", "messageUpdated"), _defineProperty__default["default"](_class, "tokenAboutToExpire", "tokenAboutToExpire"), _defineProperty__default["default"](_class, "tokenExpired", "tokenExpired"), _defineProperty__default["default"](_class, "typingEnded", "typingEnded"), _defineProperty__default["default"](_class, "typingStarted", "typingStarted"), _defineProperty__default["default"](_class, "pushNotification", "pushNotification"), _defineProperty__default["default"](_class, "userSubscribed", "userSubscribed"), _defineProperty__default["default"](_class, "userUnsubscribed", "userUnsubscribed"), _defineProperty__default["default"](_class, "userUpdated", "userUpdated"), _defineProperty__default["default"](_class, "stateChanged", "stateChanged"), _defineProperty__default["default"](_class, "initialized", "initialized"), _defineProperty__default["default"](_class, "initFailed", "initFailed"), _defineProperty__default["default"](_class, "connectionStateChanged", "connectionStateChanged"), _defineProperty__default["default"](_class, "connectionError", "connectionError"), _defineProperty__default["default"](_class, "version", version), _defineProperty__default["default"](_class, "_logger", Logger.scope("Client")), _defineProperty__default["default"](_class, "_supportedPushChannels", ["fcm", "apn"]), _defineProperty__default["default"](_class, "_supportedPushDataFields", {
      conversation_sid: "conversationSid",
      conversation_title: "conversationTitle",
      message_sid: "messageSid",
      message_index: "messageIndex",
      media_count: "mediaCount",
      media: "media"
      // object
    }), _class);
    __decorate([deprecationDecorator.deprecated("token"), __metadata("design:type", String), __metadata("design:paramtypes", [])], exports.Client.prototype, "token", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", Promise)], exports.Client.prototype, "updateToken", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", Promise)], exports.Client.prototype, "getConversationBySid", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", Promise)], exports.Client.prototype, "peekConversationBySid", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", Promise)], exports.Client.prototype, "getConversationByUniqueName", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(["undefined", declarativeTypeValidator.objectSchema("conversation options", {
      friendlyName: ["string", "undefined"],
      isPrivate: ["boolean", "undefined"],
      uniqueName: ["string", "undefined"]
    })]), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", Promise)], exports.Client.prototype, "createConversation", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.literal("fcm", "apn"), "string"), __metadata("design:type", Function), __metadata("design:paramtypes", [String, String]), __metadata("design:returntype", Promise)], exports.Client.prototype, "setPushRegistrationId", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.literal("fcm", "apn")), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", Promise)], exports.Client.prototype, "unsetPushRegistrationId", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.literal("fcm", "apn"), declarativeTypeValidator.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String, String]), __metadata("design:returntype", Promise)], exports.Client.prototype, "removePushRegistrations", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.pureObject), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", Promise)], exports.Client.prototype, "handlePushNotification", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", Promise)], exports.Client.prototype, "getUser", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyArray("strings", "string")), __metadata("design:type", Function), __metadata("design:paramtypes", [Array]), __metadata("design:returntype", mcsClient.CancellablePromise)], exports.Client.prototype, "getTemporaryContentUrlsForMediaSids", null);
    __decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyArray("media", Media)), __metadata("design:type", Function), __metadata("design:paramtypes", [Array]), __metadata("design:returntype", mcsClient.CancellablePromise)], exports.Client.prototype, "getTemporaryContentUrlsForMedia", null);
    __decorate([deprecationDecorator.deprecated("Client.create()", "new Client()"), declarativeTypeValidator.validateTypesAsync("string", ["undefined", declarativeTypeValidator.pureObject]), __metadata("design:type", Function), __metadata("design:paramtypes", [String, Object]), __metadata("design:returntype", Promise)], exports.Client, "create", null);
    __decorate([declarativeTypeValidator.validateTypes(declarativeTypeValidator.pureObject), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", PushNotification)], exports.Client, "parsePushNotification", null);
    exports.Client = Client_1 = __decorate([declarativeTypeValidator.validateConstructorTypes(declarativeTypeValidator.nonEmptyString, [declarativeTypeValidator.pureObject, "undefined"]), __metadata("design:paramtypes", [String, Object])], exports.Client);
    Object.defineProperty(exports, "CancellablePromise", {
      enumerable: true,
      get: function() {
        return mcsClient.CancellablePromise;
      }
    });
    exports.AggregatedDeliveryReceipt = AggregatedDeliveryReceipt;
    exports.ChannelMetadata = ChannelMetadata;
    exports.ContentTemplate = ContentTemplate;
    exports.ContentTemplateVariable = ContentTemplateVariable;
    exports.Conversation = Conversation;
    exports.DetailedDeliveryReceipt = DetailedDeliveryReceipt;
    exports.EmailRecipientDescriptor = EmailRecipientDescriptor;
    exports.Media = Media;
    exports.Message = Message;
    exports.MessageBuilder = MessageBuilder;
    exports.NotificationTypes = NotificationTypes;
    exports.Participant = Participant;
    exports.PushNotification = PushNotification;
    exports.RestPaginator = RestPaginator;
    exports.UnknownRecipientDescriptor = UnknownRecipientDescriptor;
    exports.UnsentMessage = UnsentMessage;
    exports.User = User;
  }
});
export default require_browser12();
/*! Bundled license information:

@babel/runtime/helpers/regenerator.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE *)

@twilio/declarative-type-validator/builds/browser.js:
  (*
  @license
  Copyright (c) 2021 Twilio Inc.
  
  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  
  
  *)

@twilio/replay-event-emitter/builds/browser.js:
  (*
  @license
  Copyright (c) 2021 Twilio Inc.
  
  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  
  *)

@twilio/operation-retrier/builds/browser.js:
  (*
  @license
  Copyright (c) 2016, Twilio, Inc.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted, provided that the above
  copyright notice and this permission notice appear in all copies.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
  SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
  OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
  CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  
  *)

@twilio/declarative-type-validator/builds/browser.js:
  (*
  @license
  Copyright (c) 2021 Twilio Inc.
  
  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  
  
  *)

platform/platform.js:
  (*!
   * Platform.js v1.3.6
   * Copyright 2014-2020 Benjamin Tan
   * Copyright 2011-2013 John-David Dalton
   * Available under MIT license
   *)

twilsock/builds/browser.js:
  (*
  @license
  The following license applies to all parts of this software except as
  documented below.
  
      Copyright (c) 2016, Twilio, inc.
      All rights reserved.
  
      Redistribution and use in source and binary forms, with or without
      modification, are permitted provided that the following conditions are
      met:
  
        1. Redistributions of source code must retain the above copyright
           notice, this list of conditions and the following disclaimer.
  
        2. Redistributions in binary form must reproduce the above copyright
           notice, this list of conditions and the following disclaimer in
           the documentation and/or other materials provided with the
           distribution.
  
        3. Neither the name of Twilio nor the names of its contributors may
           be used to endorse or promote products derived from this software
           without specific prior written permission.
  
      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
      "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
      LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
      A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
      HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
      SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
      LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
      DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
      THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
      OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  
  This software includes javascript-state-machine under the following license.
  
      Copyright (c) 2012, 2013, 2014, 2015, Jake Gordon and contributors
  
      Permission is hereby granted, free of charge, to any person obtaining a copy
      of this software and associated documentation files (the "Software"), to deal
      in the Software without restriction, including without limitation the rights
      to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
      copies of the Software, and to permit persons to whom the Software is
      furnished to do so, subject to the following conditions:
  
      The above copyright notice and this permission notice shall be included in all
      copies or substantial portions of the Software.
  
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
      OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  
  This software includes loglevel under the following license.
  
      Copyright (c) 2013 Tim Perry
  
      Permission is hereby granted, free of charge, to any person
      obtaining a copy of this software and associated documentation
      files (the "Software"), to deal in the Software without
      restriction, including without limitation the rights to use,
      copy, modify, merge, publish, distribute, sublicense, and/or sell
      copies of the Software, and to permit persons to whom the
      Software is furnished to do so, subject to the following
      conditions:
  
      The above copyright notice and this permission notice shall be
      included in all copies or substantial portions of the Software.
  
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
      OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
      HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
      WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
      FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
      OTHER DEALINGS IN THE SOFTWARE.
  
  
  *)

@twilio/notifications/builds/browser.js:
  (*
  @license
  The MIT License (MIT)
  
  Copyright (c) 2016 Twilio Inc.
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
  
  *)

@twilio/declarative-type-validator/builds/browser.js:
  (*
  @license
  Copyright (c) 2021 Twilio Inc.
  
  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  
  
  *)

twilio-sync/builds/browser.js:
  (*
  @license
  The following license applies to all parts of this software except as
  documented below.
  
      Copyright (c) 2016, Twilio, inc.
      All rights reserved.
  
      Redistribution and use in source and binary forms, with or without
      modification, are permitted provided that the following conditions are
      met:
  
        1. Redistributions of source code must retain the above copyright
           notice, this list of conditions and the following disclaimer.
  
        2. Redistributions in binary form must reproduce the above copyright
           notice, this list of conditions and the following disclaimer in
           the documentation and/or other materials provided with the
           distribution.
  
        3. Neither the name of Twilio nor the names of its contributors may
           be used to endorse or promote products derived from this software
           without specific prior written permission.
  
      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
      "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
      LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
      A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
      HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
      SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
      LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
      DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
      THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
      OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  
  This software includes loglevel under the following license.
  
      Copyright (c) 2013 Tim Perry
  
      Permission is hereby granted, free of charge, to any person
      obtaining a copy of this software and associated documentation
      files (the "Software"), to deal in the Software without
      restriction, including without limitation the rights to use,
      copy, modify, merge, publish, distribute, sublicense, and/or sell
      copies of the Software, and to permit persons to whom the
      Software is furnished to do so, subject to the following
      conditions:
  
      The above copyright notice and this permission notice shall be
      included in all copies or substantial portions of the Software.
  
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
      OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
      HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
      WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
      FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
      OTHER DEALINGS IN THE SOFTWARE.
  
  This software includes Backoff library under the following license
  
      Copyright (C) 2012 Mathieu Turcotte
  
      Permission is hereby granted, free of charge, to any person obtaining a copy of
      this software and associated documentation files (the "Software"), to deal in
      the Software without restriction, including without limitation the rights to
      use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
      of the Software, and to permit persons to whom the Software is furnished to do
      so, subject to the following conditions:
  
      The above copyright notice and this permission notice shall be included in all
      copies or substantial portions of the Software.
  
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
      OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
      SOFTWARE.
  
  This software includes Event-to-Promise library under the following license
  
      Copyright (c) 2014, Julien Fontanet <julien.fontanet@isonoe.net>.
  
      Permission to use, copy, modify, and/or distribute this software for any purpose
      with or without fee is hereby granted, provided that the above copyright notice
      and this permission notice appear in all copies.
  
      THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
      REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
      FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
      INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
      OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
      TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
      THIS SOFTWARE.
  
  *)

@twilio/mcs-client/builds/browser.js:
  (*
  @license
  Copyright (c) 2018, Twilio, Inc.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted, provided that the above
  copyright notice and this permission notice appear in all copies.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
  SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
  OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
  CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  
  *)

@twilio/deprecation-decorator/builds/browser.js:
  (*
  @license
  Copyright (c) 2022 Twilio Inc.
  
  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  
  
  *)

@twilio/conversations/builds/browser.js:
  (*
  @license
  The following license applies to all parts of this software except as
  documented below.
  
      Copyright (c) 2019, Twilio, inc.
      All rights reserved.
  
      Redistribution and use in source and binary forms, with or without
      modification, are permitted provided that the following conditions are
      met:
  
        1. Redistributions of source code must retain the above copyright
           notice, this list of conditions and the following disclaimer.
  
        2. Redistributions in binary form must reproduce the above copyright
           notice, this list of conditions and the following disclaimer in
           the documentation and/or other materials provided with the
           distribution.
  
        3. Neither the name of Twilio nor the names of its contributors may
           be used to endorse or promote products derived from this software
           without specific prior written permission.
  
      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
      "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
      LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
      A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
      HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
      SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
      LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
      DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
      THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
      OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  
  This software includes javascript-state-machine under the following license.
  
      Copyright (c) 2012, 2013, 2014, 2015, Jake Gordon and contributors
  
      Permission is hereby granted, free of charge, to any person obtaining a copy
      of this software and associated documentation files (the "Software"), to deal
      in the Software without restriction, including without limitation the rights
      to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
      copies of the Software, and to permit persons to whom the Software is
      furnished to do so, subject to the following conditions:
  
      The above copyright notice and this permission notice shall be included in all
      copies or substantial portions of the Software.
  
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
      OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  
  This software includes loglevel under the following license.
  
      Copyright (c) 2013 Tim Perry
  
      Permission is hereby granted, free of charge, to any person
      obtaining a copy of this software and associated documentation
      files (the "Software"), to deal in the Software without
      restriction, including without limitation the rights to use,
      copy, modify, merge, publish, distribute, sublicense, and/or sell
      copies of the Software, and to permit persons to whom the
      Software is furnished to do so, subject to the following
      conditions:
  
      The above copyright notice and this permission notice shall be
      included in all copies or substantial portions of the Software.
  
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
      OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
      HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
      WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
      FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
      OTHER DEALINGS IN THE SOFTWARE.
  
  This software includes q under the following license.
  
      Copyright 2009â2014 Kristopher Michael Kowal. All rights reserved.
      Permission is hereby granted, free of charge, to any person obtaining a copy
      of this software and associated documentation files (the "Software"), to
      deal in the Software without restriction, including without limitation the
      rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
      sell copies of the Software, and to permit persons to whom the Software is
      furnished to do so, subject to the following conditions:
  
      The above copyright notice and this permission notice shall be included in
      all copies or substantial portions of the Software.
  
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
      FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
      IN THE SOFTWARE.
  
  This software includes platform.js under the following license.
  
      Copyright 2014 Benjamin Tan <https://d10.github.io/>
      Copyright 2011-2015 John-David Dalton <http://allyoucanleet.com/>
  
      Permission is hereby granted, free of charge, to any person obtaining
      a copy of this software and associated documentation files (the
      "Software"), to deal in the Software without restriction, including
      without limitation the rights to use, copy, modify, merge, publish,
      distribute, sublicense, and/or sell copies of the Software, and to
      permit persons to whom the Software is furnished to do so, subject to
      the following conditions:
  
      The above copyright notice and this permission notice shall be
      included in all copies or substantial portions of the Software.
  
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  
  *)
*/
//# sourceMappingURL=@twilio_conversations.js.map
